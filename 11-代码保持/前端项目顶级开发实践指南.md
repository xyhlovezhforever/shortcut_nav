# 前端项目顶级开发实践指南

> 十年前端开发经验总结 - 从Vue到React，从CSS到性能优化的完整方案

---

## 目录

1. [现代前端技术栈选型](#1-现代前端技术栈选型)
2. [项目搭建与工程化](#2-项目搭建与工程化)
3. [Vue3开发最佳实践](#3-vue3开发最佳实践)
4. [React开发最佳实践](#4-react开发最佳实践)
5. [通用组件设计模式](#5-通用组件设计模式)
6. [CSS架构与样式方案](#6-css架构与样式方案)
7. [状态管理深度对比](#7-状态管理深度对比)
8. [性能优化全方位](#8-性能优化全方位)
9. [TypeScript实战技巧](#9-typescript实战技巧)
10. [HTTP请求与数据管理](#10-http请求与数据管理)
11. [浏览器API与原生JS](#11-浏览器api与原生js)
12. [构建优化与部署](#12-构建优化与部署)

---

## 1. 现代前端技术栈选型

### 1.1 框架选择指南

```
项目规模 | 团队情况 | 推荐方案
---------|---------|----------
小型项目 | 1-2人   | Vue3 + Vite + Pinia
中型SPA  | 3-5人   | React + Next.js + Zustand
大型应用 | 5+人    | React + Nx + Micro Frontend
营销页面 | -       | Astro + Tailwind
```

**技术栈对比**

```typescript
// Vue3 - 渐进式、上手快、template语法直观
<script setup lang="ts">
import { ref, computed } from 'vue'

const count = ref(0)
const double = computed(() => count.value * 2)
</script>

<template>
  <div>{{ count }} x 2 = {{ double }}</div>
  <button @click="count++">增加</button>
</template>


// React - 生态丰富、JSX灵活、适合大型项目
import { useState, useMemo } from 'react'

function Counter() {
  const [count, setCount] = useState(0)
  const double = useMemo(() => count * 2, [count])

  return (
    <div>
      {count} x 2 = {double}
      <button onClick={() => setCount(count + 1)}>增加</button>
    </div>
  )
}


// Svelte - 编译时框架、性能极致、代码简洁
<script lang="ts">
  let count = 0
  $: double = count * 2
</script>

<div>{count} x 2 = {double}</div>
<button on:click={() => count++}>增加</button>
```

### 1.2 构建工具选择

```bash
# ❌ 2024年不要用了
Webpack - 配置复杂，构建慢

# ✅ 现代构建工具
Vite - 开发体验极佳，适合大多数项目
Turbopack - Next.js 13+内置，极速HMR
Rspack - 兼容Webpack生态的Rust构建工具
```

---

## 2. 项目搭建与工程化

### 2.1 项目初始化

```bash
# Vue3项目
npm create vue@latest my-vue-app
# 选择：TypeScript、Router、Pinia、ESLint、Prettier

# React项目（推荐Next.js）
npx create-next-app@latest my-next-app --typescript --tailwind --app

# 或纯React（用Vite）
npm create vite@latest my-react-app -- --template react-ts

# Svelte项目
npm create vite@latest my-svelte-app -- --template svelte-ts
```

### 2.2 统一的项目结构

```
src/
├── assets/              # 静态资源
│   ├── images/
│   ├── fonts/
│   └── icons/
├── components/          # 通用组件
│   ├── ui/             # UI组件库（Button、Input等）
│   ├── layout/         # 布局组件（Header、Footer）
│   └── common/         # 业务组件
├── composables/         # Vue3组合式函数 / React Hooks
│   ├── useAuth.ts
│   ├── useDebounce.ts
│   └── useLocalStorage.ts
├── features/            # 功能模块（推荐！）
│   ├── auth/
│   │   ├── components/
│   │   ├── composables/
│   │   ├── api/
│   │   └── types/
│   ├── dashboard/
│   └── profile/
├── layouts/             # 页面布局
├── pages/               # 页面组件（路由页面）
├── router/              # 路由配置
├── stores/              # 状态管理
├── services/            # API服务
├── utils/               # 工具函数
│   ├── request.ts      # HTTP封装
│   ├── format.ts       # 格式化
│   └── validation.ts   # 验证
├── types/               # TypeScript类型
├── styles/              # 全局样式
│   ├── variables.css   # CSS变量
│   ├── reset.css       # 重置样式
│   └── global.css      # 全局样式
├── constants/           # 常量配置
└── plugins/             # 插件配置
```

### 2.3 package.json最佳配置

```json
{
  "name": "my-app",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc --noEmit && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext .vue,.js,.jsx,.ts,.tsx --fix",
    "format": "prettier --write \"src/**/*.{vue,ts,tsx,js,jsx,css,scss}\"",
    "type-check": "vue-tsc --noEmit",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "prepare": "husky install"
  },
  "dependencies": {
    "vue": "^3.4.0",
    "vue-router": "^4.2.5",
    "pinia": "^2.1.7",
    "axios": "^1.6.7",
    "dayjs": "^1.11.10",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.3",
    "@vue/tsconfig": "^0.5.1",
    "typescript": "^5.3.3",
    "vite": "^5.1.0",
    "vitest": "^1.2.2",
    "eslint": "^8.56.0",
    "prettier": "^3.2.4",
    "husky": "^9.0.10",
    "lint-staged": "^15.2.0"
  }
}
```

### 2.4 必备配置文件

```javascript
// .eslintrc.cjs
module.exports = {
  root: true,
  extends: [
    'plugin:vue/vue3-recommended',
    'eslint:recommended',
    '@vue/typescript/recommended',
    '@vue/prettier'
  ],
  rules: {
    'vue/multi-word-component-names': 'off',
    'vue/require-default-prop': 'off',
    '@typescript-eslint/no-unused-vars': ['error', {
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^_'
    }],
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off'
  }
}
```

```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "printWidth": 100,
  "trailingComma": "es5",
  "arrowParens": "always",
  "vueIndentScriptAndStyle": false
}
```

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@components/*": ["./src/components/*"],
      "@composables/*": ["./src/composables/*"]
    }
  }
}
```

---

## 3. Vue3开发最佳实践

### 3.1 组合式API vs 选项式API

```vue
<!-- ❌ 选项式API - 逻辑分散 -->
<script lang="ts">
export default {
  data() {
    return {
      count: 0,
      user: null,
      loading: false
    }
  },
  computed: {
    double() {
      return this.count * 2
    }
  },
  methods: {
    increment() {
      this.count++
    },
    async fetchUser() {
      this.loading = true
      // ...
    }
  },
  mounted() {
    this.fetchUser()
  }
}
</script>


<!-- ✅ 组合式API - 逻辑聚合 -->
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'

// 计数器逻辑
const count = ref(0)
const double = computed(() => count.value * 2)
const increment = () => count.value++

// 用户逻辑
const user = ref<User | null>(null)
const loading = ref(false)

const fetchUser = async () => {
  loading.value = true
  try {
    const res = await fetch('/api/user')
    user.value = await res.json()
  } finally {
    loading.value = false
  }
}

onMounted(() => {
  fetchUser()
})
</script>
```

### 3.2 自定义Composables

```typescript
// composables/useUser.ts
import { ref, computed } from 'vue'
import type { User } from '@/types'

export function useUser(userId: string) {
  const user = ref<User | null>(null)
  const loading = ref(false)
  const error = ref<Error | null>(null)

  const isAdmin = computed(() => user.value?.role === 'admin')

  const fetchUser = async () => {
    loading.value = true
    error.value = null

    try {
      const res = await fetch(`/api/users/${userId}`)
      user.value = await res.json()
    } catch (e) {
      error.value = e as Error
    } finally {
      loading.value = false
    }
  }

  return {
    user,
    loading,
    error,
    isAdmin,
    fetchUser,
  }
}


// 使用
<script setup lang="ts">
import { useUser } from '@/composables/useUser'

const { user, loading, isAdmin, fetchUser } = useUser('123')

onMounted(() => {
  fetchUser()
})
</script>
```

### 3.3 响应式最佳实践

```typescript
// ❌ 常见错误
const state = {
  count: 0  // 不是响应式！
}

const user = ref({ name: 'John' })
user.name = 'Jane'  // ❌ 丢失响应式

const list = ref([1, 2, 3])
list[0] = 100  // ❌ 不推荐


// ✅ 正确做法
const state = reactive({
  count: 0  // 响应式
})

const user = ref({ name: 'John' })
user.value = { name: 'Jane' }  // ✅ 整个替换

const list = ref([1, 2, 3])
list.value[0] = 100  // ✅ 通过.value访问


// ✅ 解构响应式对象
import { toRefs } from 'vue'

const state = reactive({ count: 0, name: 'John' })
const { count, name } = toRefs(state)  // 保持响应式


// ✅ watch vs watchEffect
// watch - 明确依赖，惰性执行
watch(() => user.value.id, async (newId) => {
  await fetchUserDetails(newId)
})

// watchEffect - 自动追踪，立即执行
watchEffect(async () => {
  if (user.value?.id) {
    await fetchUserDetails(user.value.id)
  }
})
```

### 3.4 组件通信模式

```vue
<!-- ✅ Props + Emits -->
<!-- Child.vue -->
<script setup lang="ts">
interface Props {
  modelValue: string
  disabled?: boolean
}

interface Emits {
  (e: 'update:modelValue', value: string): void
  (e: 'submit', value: string): void
}

const props = withDefaults(defineProps<Props>(), {
  disabled: false
})

const emit = defineEmits<Emits>()

const handleInput = (e: Event) => {
  const value = (e.target as HTMLInputElement).value
  emit('update:modelValue', value)
}
</script>

<template>
  <input
    :value="modelValue"
    :disabled="disabled"
    @input="handleInput"
  />
</template>


<!-- Parent.vue -->
<script setup lang="ts">
const text = ref('')
</script>

<template>
  <Child v-model="text" @submit="handleSubmit" />
</template>


<!-- ✅ Provide / Inject -->
<!-- Parent.vue -->
<script setup lang="ts">
import { provide } from 'vue'

const theme = ref('dark')
provide('theme', theme)  // 提供给所有后代
</script>

<!-- Grandchild.vue -->
<script setup lang="ts">
import { inject } from 'vue'

const theme = inject<Ref<string>>('theme')
</script>
```

### 3.5 性能优化

```vue
<!-- ✅ 使用v-memo避免重渲染 -->
<template>
  <div v-for="item in list" :key="item.id" v-memo="[item.id, item.name]">
    <!-- 只有id或name变化才重新渲染 -->
    {{ item.name }}
  </div>
</template>


<!-- ✅ 使用v-once渲染静态内容 -->
<template>
  <div v-once>
    <!-- 只渲染一次，永不更新 -->
    <h1>{{ staticTitle }}</h1>
  </div>
</template>


<!-- ✅ 异步组件 -->
<script setup lang="ts">
import { defineAsyncComponent } from 'vue'

const HeavyComponent = defineAsyncComponent(() =>
  import('./HeavyComponent.vue')
)
</script>


<!-- ✅ KeepAlive缓存组件 -->
<template>
  <RouterView v-slot="{ Component }">
    <KeepAlive :max="10">
      <component :is="Component" />
    </KeepAlive>
  </RouterView>
</template>
```

---

## 4. React开发最佳实践

### 4.1 函数组件与Hooks

```tsx
// ❌ 类组件已过时
class Counter extends React.Component {
  state = { count: 0 }

  increment = () => {
    this.setState({ count: this.state.count + 1 })
  }

  render() {
    return (
      <div>
        {this.state.count}
        <button onClick={this.increment}>+</button>
      </div>
    )
  }
}


// ✅ 函数组件 + Hooks
function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      {count}
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  )
}
```

### 4.2 自定义Hooks

```typescript
// hooks/useDebounce.ts
import { useEffect, useState } from 'react'

export function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState(value)

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => clearTimeout(timer)
  }, [value, delay])

  return debouncedValue
}


// hooks/useLocalStorage.ts
export function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch {
      return initialValue
    }
  })

  const setStoredValue = (value: T | ((val: T) => T)) => {
    const valueToStore = value instanceof Function ? value(value) : value
    setValue(valueToStore)
    window.localStorage.setItem(key, JSON.stringify(valueToStore))
  }

  return [value, setStoredValue] as const
}


// hooks/useFetch.ts
import { useEffect, useState } from 'react'

interface FetchState<T> {
  data: T | null
  loading: boolean
  error: Error | null
}

export function useFetch<T>(url: string): FetchState<T> {
  const [state, setState] = useState<FetchState<T>>({
    data: null,
    loading: true,
    error: null,
  })

  useEffect(() => {
    let cancelled = false

    const fetchData = async () => {
      try {
        const res = await fetch(url)
        const data = await res.json()

        if (!cancelled) {
          setState({ data, loading: false, error: null })
        }
      } catch (error) {
        if (!cancelled) {
          setState({ data: null, loading: false, error: error as Error })
        }
      }
    }

    fetchData()

    return () => {
      cancelled = true  // 清理：避免内存泄漏
    }
  }, [url])

  return state
}
```

### 4.3 性能优化技巧

```tsx
// ❌ 每次渲染都创建新函数/对象
function Parent() {
  const [count, setCount] = useState(0)

  const config = { theme: 'dark' }  // 每次都是新对象
  const handleClick = () => {}      // 每次都是新函数

  return <Child config={config} onClick={handleClick} />
}


// ✅ 使用useMemo和useCallback
function Parent() {
  const [count, setCount] = useState(0)

  const config = useMemo(() => ({ theme: 'dark' }), [])
  const handleClick = useCallback(() => {
    console.log('clicked')
  }, [])

  return <Child config={config} onClick={handleClick} />
}


// ✅ React.memo避免不必要的重渲染
const Child = memo(function Child({
  config,
  onClick
}: ChildProps) {
  console.log('Child rendered')
  return <button onClick={onClick}>Click</button>
})


// ✅ 组件拆分
// 这样count变化不会重渲染ExpensiveChild
function Parent() {
  return (
    <div>
      <Counter />
      <ExpensiveChild />
    </div>
  )
}

function Counter() {
  const [count, setCount] = useState(0)
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>
}
```

### 4.4 Context使用技巧

```tsx
// ✅ 分离Context避免不必要的重渲染
// 问题：Theme变化会导致所有使用ThemeContext的组件重渲染
const ThemeContext = createContext({ theme: 'dark', setTheme: () => {} })


// 解决方案：拆分成两个Context
const ThemeValueContext = createContext('dark')
const ThemeUpdateContext = createContext<(theme: string) => void>(() => {})

function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState('dark')

  return (
    <ThemeValueContext.Provider value={theme}>
      <ThemeUpdateContext.Provider value={setTheme}>
        {children}
      </ThemeUpdateContext.Provider>
    </ThemeValueContext.Provider>
  )
}

// 只读取theme的组件不会因为setTheme变化而重渲染
function useTheme() {
  return useContext(ThemeValueContext)
}

function useThemeUpdate() {
  return useContext(ThemeUpdateContext)
}
```

---

## 5. 通用组件设计模式

### 5.1 复合组件模式（Compound Components）

```tsx
// ✅ React实现
type TabsContextType = {
  activeTab: string
  setActiveTab: (tab: string) => void
}

const TabsContext = createContext<TabsContextType | undefined>(undefined)

function Tabs({ children, defaultTab }: TabsProps) {
  const [activeTab, setActiveTab] = useState(defaultTab)

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  )
}

Tabs.List = function TabsList({ children }: { children: ReactNode }) {
  return <div className="tabs-list">{children}</div>
}

Tabs.Tab = function Tab({ value, children }: TabProps) {
  const { activeTab, setActiveTab } = useContext(TabsContext)!

  return (
    <button
      className={activeTab === value ? 'active' : ''}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  )
}

Tabs.Panel = function TabPanel({ value, children }: PanelProps) {
  const { activeTab } = useContext(TabsContext)!

  if (activeTab !== value) return null

  return <div className="tab-panel">{children}</div>
}

// 使用
<Tabs defaultTab="profile">
  <Tabs.List>
    <Tabs.Tab value="profile">Profile</Tabs.Tab>
    <Tabs.Tab value="settings">Settings</Tabs.Tab>
  </Tabs.List>
  <Tabs.Panel value="profile">Profile content</Tabs.Panel>
  <Tabs.Panel value="settings">Settings content</Tabs.Panel>
</Tabs>
```

```vue
<!-- ✅ Vue3实现 -->
<!-- Tabs.vue -->
<script setup lang="ts">
import { provide, ref } from 'vue'

const activeTab = ref('profile')
provide('activeTab', activeTab)
</script>

<template>
  <div class="tabs">
    <slot />
  </div>
</template>

<!-- TabsList.vue -->
<template>
  <div class="tabs-list">
    <slot />
  </div>
</template>

<!-- Tab.vue -->
<script setup lang="ts">
import { inject } from 'vue'

const props = defineProps<{ value: string }>()
const activeTab = inject<Ref<string>>('activeTab')!
</script>

<template>
  <button
    :class="{ active: activeTab === value }"
    @click="activeTab = value"
  >
    <slot />
  </button>
</template>

<!-- 使用 -->
<Tabs>
  <TabsList>
    <Tab value="profile">Profile</Tab>
    <Tab value="settings">Settings</Tab>
  </TabsList>
  <TabPanel value="profile">Profile content</TabPanel>
  <TabPanel value="settings">Settings content</TabPanel>
</Tabs>
```

### 5.2 Render Props / Scoped Slots

```tsx
// React - Render Props
interface ListProps<T> {
  items: T[]
  renderItem: (item: T, index: number) => ReactNode
  renderEmpty?: () => ReactNode
}

function List<T>({ items, renderItem, renderEmpty }: ListProps<T>) {
  if (items.length === 0) {
    return renderEmpty ? renderEmpty() : <div>No items</div>
  }

  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item, index)}</li>
      ))}
    </ul>
  )
}

// 使用
<List
  items={users}
  renderItem={(user) => (
    <div>
      <img src={user.avatar} />
      <span>{user.name}</span>
    </div>
  )}
/>
```

```vue
<!-- Vue - Scoped Slots -->
<template>
  <ul v-if="items.length">
    <li v-for="(item, index) in items" :key="index">
      <slot name="item" :item="item" :index="index" />
    </li>
  </ul>
  <div v-else>
    <slot name="empty">No items</slot>
  </div>
</template>

<!-- 使用 -->
<List :items="users">
  <template #item="{ item }">
    <div>
      <img :src="item.avatar" />
      <span>{{ item.name }}</span>
    </div>
  </template>
</List>
```

---

## 6. CSS架构与样式方案

### 6.1 CSS方案对比

```css
/* ❌ 全局CSS - 命名冲突 */
/* styles.css */
.button {
  background: blue;
}

.button-primary {
  background: darkblue;
}


/* ✅ BEM命名规范 */
.button { }
.button--primary { }
.button__icon { }
.button--primary.button--disabled { }
```

```vue
<!-- ✅ CSS Modules - 局部作用域 -->
<template>
  <button :class="[$style.button, $style[variant]]">
    Click me
  </button>
</template>

<style module>
.button {
  padding: 0.5rem 1rem;
  border-radius: 0.25rem;
}

.primary {
  background: blue;
  color: white;
}

.secondary {
  background: gray;
}
</style>
```

```vue
<!-- ✅ Scoped CSS - Vue特色 -->
<template>
  <button class="button">Click me</button>
</template>

<style scoped>
.button {
  /* 只作用于当前组件 */
  padding: 0.5rem 1rem;
}
</style>
```

```tsx
// ✅ CSS-in-JS - styled-components
import styled from 'styled-components'

const Button = styled.button<{ variant: 'primary' | 'secondary' }>`
  padding: 0.5rem 1rem;
  border-radius: 0.25rem;

  ${props => props.variant === 'primary' && css`
    background: blue;
    color: white;
  `}
`

// 使用
<Button variant="primary">Click me</Button>
```

```tsx
// ✅ Tailwind CSS - 实用优先（推荐！）
function Button({ variant }: { variant: 'primary' | 'secondary' }) {
  const variants = {
    primary: 'bg-blue-500 text-white hover:bg-blue-600',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300',
  }

  return (
    <button className={cn('px-4 py-2 rounded-md transition', variants[variant])}>
      Click me
    </button>
  )
}
```

### 6.2 CSS变量与主题切换

```css
/* ✅ CSS变量实现主题 */
:root {
  --color-primary: #3b82f6;
  --color-bg: #ffffff;
  --color-text: #000000;
  --spacing-unit: 8px;
}

[data-theme='dark'] {
  --color-bg: #000000;
  --color-text: #ffffff;
}

.button {
  background: var(--color-primary);
  padding: calc(var(--spacing-unit) * 2);
}
```

```typescript
// 主题切换
function toggleTheme() {
  const html = document.documentElement
  const currentTheme = html.getAttribute('data-theme')
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark'

  html.setAttribute('data-theme', newTheme)
  localStorage.setItem('theme', newTheme)
}
```

### 6.3 响应式设计

```css
/* ✅ 移动优先 */
.container {
  padding: 1rem;
}

@media (min-width: 768px) {
  .container {
    padding: 2rem;
  }
}

@media (min-width: 1024px) {
  .container {
    padding: 3rem;
    max-width: 1200px;
  }
}


/* ✅ Container Queries（现代） */
.card-container {
  container-type: inline-size;
  container-name: card;
}

@container card (min-width: 400px) {
  .card {
    display: flex;
    flex-direction: row;
  }
}
```

---

## 7. 状态管理深度对比

### 7.1 Vue - Pinia

```typescript
// stores/user.ts
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () => ({
    user: null as User | null,
    token: '',
    isLoading: false,
  }),

  getters: {
    isLoggedIn: (state) => !!state.token,
    userName: (state) => state.user?.name ?? 'Guest',
  },

  actions: {
    async login(email: string, password: string) {
      this.isLoading = true

      try {
        const res = await fetch('/api/login', {
          method: 'POST',
          body: JSON.stringify({ email, password }),
        })

        const data = await res.json()
        this.user = data.user
        this.token = data.token
      } finally {
        this.isLoading = false
      }
    },

    logout() {
      this.$reset()  // 重置到初始状态
    },
  },
})


// 组件中使用
<script setup lang="ts">
import { useUserStore } from '@/stores/user'
import { storeToRefs } from 'pinia'

const userStore = useUserStore()
const { user, isLoggedIn } = storeToRefs(userStore)  // 解构保持响应式
const { login, logout } = userStore  // actions可直接解构
</script>
```

### 7.2 React - Zustand

```typescript
// stores/userStore.ts
import { create } from 'zustand'
import { persist, devtools } from 'zustand/middleware'

interface UserState {
  user: User | null
  token: string
  isLoading: boolean
  login: (email: string, password: string) => Promise<void>
  logout: () => void
}

export const useUserStore = create<UserState>()(
  devtools(
    persist(
      (set) => ({
        user: null,
        token: '',
        isLoading: false,

        login: async (email, password) => {
          set({ isLoading: true })

          try {
            const res = await fetch('/api/login', {
              method: 'POST',
              body: JSON.stringify({ email, password }),
            })

            const data = await res.json()
            set({ user: data.user, token: data.token })
          } finally {
            set({ isLoading: false })
          }
        },

        logout: () => {
          set({ user: null, token: '' })
        },
      }),
      { name: 'user-storage' }
    )
  )
)


// 组件中使用
function Profile() {
  const { user, login, logout } = useUserStore()

  // 或选择性订阅（性能优化）
  const user = useUserStore((state) => state.user)
  const login = useUserStore((state) => state.login)

  return <div>{user?.name}</div>
}
```

### 7.3 服务器状态 - TanStack Query

```typescript
// ✅ 统一处理服务器状态（Vue + React通用）

// React
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

function UserList() {
  // 查询
  const { data: users, isLoading } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json()),
    staleTime: 5 * 60 * 1000,  // 5分钟内认为数据新鲜
  })

  const queryClient = useQueryClient()

  // 变更
  const createMutation = useMutation({
    mutationFn: (newUser: User) =>
      fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(newUser)
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] })
    },
  })

  return (
    <div>
      {isLoading && <div>Loading...</div>}
      {users?.map(user => <div key={user.id}>{user.name}</div>)}
      <button onClick={() => createMutation.mutate({ name: 'New User' })}>
        Add User
      </button>
    </div>
  )
}


// Vue
import { useQuery, useMutation, useQueryClient } from '@tanstack/vue-query'

const { data: users, isLoading } = useQuery({
  queryKey: ['users'],
  queryFn: () => fetch('/api/users').then(res => res.json())
})
```

---

## 8. 性能优化全方位

### 8.1 首屏加载优化

```html
<!-- ✅ 预加载关键资源 -->
<head>
  <!-- 预加载字体 -->
  <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>

  <!-- 预连接API域名 -->
  <link rel="preconnect" href="https://api.example.com">

  <!-- DNS预解析 -->
  <link rel="dns-prefetch" href="https://cdn.example.com">
</head>
```

```javascript
// ✅ 代码分割
// Vue Router
const routes = [
  {
    path: '/dashboard',
    component: () => import('@/views/Dashboard.vue')  // 懒加载
  }
]

// React Router
const Dashboard = lazy(() => import('./Dashboard'))

<Suspense fallback={<Loading />}>
  <Routes>
    <Route path="/dashboard" element={<Dashboard />} />
  </Routes>
</Suspense>
```

### 8.2 列表渲染优化

```vue
<!-- ❌ 渲染10000个DOM节点 -->
<template>
  <div v-for="item in items" :key="item.id">
    {{ item.name }}
  </div>
</template>


<!-- ✅ 虚拟滚动（vue-virtual-scroller） -->
<template>
  <RecycleScroller
    :items="items"
    :item-size="50"
    key-field="id"
    v-slot="{ item }"
  >
    <div class="item">{{ item.name }}</div>
  </RecycleScroller>
</template>


<!-- ✅ 分页加载 -->
<script setup lang="ts">
const page = ref(1)
const pageSize = 20

const displayedItems = computed(() => {
  const start = (page.value - 1) * pageSize
  return items.value.slice(start, start + pageSize)
})
</script>
```

### 8.3 图片优化

```html
<!-- ✅ 响应式图片 -->
<img
  src="image-800w.jpg"
  srcset="image-400w.jpg 400w,
          image-800w.jpg 800w,
          image-1200w.jpg 1200w"
  sizes="(max-width: 600px) 400px,
         (max-width: 900px) 800px,
         1200px"
  loading="lazy"
  alt="Description"
/>

<!-- ✅ 现代格式 -->
<picture>
  <source srcset="image.avif" type="image/avif">
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="Fallback">
</picture>
```

### 8.4 防抖与节流

```typescript
// ✅ 防抖（debounce）- 最后一次有效
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number = 300
): (...args: Parameters<T>) => void {
  let timer: ReturnType<typeof setTimeout> | null = null

  return function (this: any, ...args: Parameters<T>) {
    if (timer) clearTimeout(timer)

    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 使用：搜索输入
const handleSearch = debounce((keyword: string) => {
  fetch(`/api/search?q=${keyword}`)
}, 500)


// ✅ 节流（throttle）- 固定频率执行
export function throttle<T extends (...args: any[]) => any>(
  fn: T,
  delay: number = 300
): (...args: Parameters<T>) => void {
  let lastTime = 0

  return function (this: any, ...args: Parameters<T>) {
    const now = Date.now()

    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 使用：滚动事件
const handleScroll = throttle(() => {
  console.log('scroll position:', window.scrollY)
}, 200)
```

---

## 9. TypeScript实战技巧

### 9.1 类型体操

```typescript
// ✅ 实用工具类型
type User = {
  id: number
  name: string
  email: string
  password: string
  createdAt: Date
}

// 部分属性可选
type UserUpdate = Partial<User>

// 只读
type ReadonlyUser = Readonly<User>

// 选取部分属性
type UserPublic = Pick<User, 'id' | 'name' | 'email'>

// 排除属性
type UserCreate = Omit<User, 'id' | 'createdAt'>

// 提取所有值类型
type UserRole = User['role']  // string

// 所有属性值类型
type UserValue = User[keyof User]


// ✅ 条件类型
type IsString<T> = T extends string ? true : false

type A = IsString<'hello'>  // true
type B = IsString<number>   // false


// ✅ 映射类型
type Optional<T> = {
  [K in keyof T]?: T[K]
}

type Nullable<T> = {
  [K in keyof T]: T[K] | null
}


// ✅ 模板字面量类型
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'
type Endpoint = '/users' | '/posts'

type ApiRoute = `${HttpMethod} ${Endpoint}`
// "GET /users" | "GET /posts" | "POST /users" | ...
```

### 9.2 泛型约束

```typescript
// ✅ 约束泛型必须有id属性
function getIds<T extends { id: number }>(items: T[]): number[] {
  return items.map(item => item.id)
}


// ✅ 多个泛型参数
function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>
  keys.forEach(key => {
    result[key] = obj[key]
  })
  return result
}

const user = { id: 1, name: 'John', email: 'john@example.com' }
const picked = pick(user, ['id', 'name'])  // { id: number, name: string }
```

### 9.3 类型守卫

```typescript
// ✅ typeof类型守卫
function format(value: string | number) {
  if (typeof value === 'string') {
    return value.toUpperCase()  // TS知道这里是string
  }
  return value.toFixed(2)  // TS知道这里是number
}


// ✅ in类型守卫
type Dog = { bark: () => void }
type Cat = { meow: () => void }

function makeSound(animal: Dog | Cat) {
  if ('bark' in animal) {
    animal.bark()  // TS知道是Dog
  } else {
    animal.meow()  // TS知道是Cat
  }
}


// ✅ 自定义类型守卫
function isUser(obj: any): obj is User {
  return obj && typeof obj.id === 'number' && typeof obj.name === 'string'
}

function processData(data: unknown) {
  if (isUser(data)) {
    console.log(data.name)  // TS知道data是User
  }
}
```

---

## 10. HTTP请求与数据管理

### 10.1 Axios封装

```typescript
// utils/request.ts
import axios, { type AxiosInstance, type AxiosRequestConfig } from 'axios'

class Request {
  private instance: AxiosInstance

  constructor(baseURL: string) {
    this.instance = axios.create({
      baseURL,
      timeout: 10000,
    })

    // 请求拦截器
    this.instance.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('token')
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        return config
      },
      (error) => Promise.reject(error)
    )

    // 响应拦截器
    this.instance.interceptors.response.use(
      (response) => response.data,
      (error) => {
        if (error.response?.status === 401) {
          // 跳转登录
          window.location.href = '/login'
        }
        return Promise.reject(error)
      }
    )
  }

  request<T = any>(config: AxiosRequestConfig): Promise<T> {
    return this.instance.request(config)
  }

  get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    return this.request({ ...config, method: 'GET', url })
  }

  post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    return this.request({ ...config, method: 'POST', url, data })
  }

  put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    return this.request({ ...config, method: 'PUT', url, data })
  }

  delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    return this.request({ ...config, method: 'DELETE', url })
  }
}

export const request = new Request(import.meta.env.VITE_API_BASE_URL)
```

### 10.2 API层封装

```typescript
// api/user.ts
import { request } from '@/utils/request'
import type { User, LoginParams, RegisterParams } from '@/types'

export const userApi = {
  // 登录
  login: (params: LoginParams) =>
    request.post<{ user: User; token: string }>('/auth/login', params),

  // 注册
  register: (params: RegisterParams) =>
    request.post<{ user: User }>('/auth/register', params),

  // 获取用户信息
  getProfile: () =>
    request.get<User>('/user/profile'),

  // 更新用户信息
  updateProfile: (data: Partial<User>) =>
    request.put<User>('/user/profile', data),

  // 获取用户列表
  getUserList: (params: { page: number; pageSize: number }) =>
    request.get<{ users: User[]; total: number }>('/users', { params }),
}
```

---

## 11. 浏览器API与原生JS

### 11.1 IntersectionObserver - 懒加载

```typescript
// ✅ 图片懒加载
export function lazyLoadImages() {
  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement
        img.src = img.dataset.src!
        img.classList.remove('lazy')
        imageObserver.unobserve(img)
      }
    })
  })

  document.querySelectorAll('img.lazy').forEach((img) => {
    imageObserver.observe(img)
  })
}

// HTML: <img class="lazy" data-src="image.jpg" src="placeholder.jpg">


// ✅ 无限滚动
export function useInfiniteScroll(callback: () => void) {
  const sentinel = ref<HTMLElement | null>(null)

  onMounted(() => {
    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        callback()
      }
    })

    if (sentinel.value) {
      observer.observe(sentinel.value)
    }

    onUnmounted(() => observer.disconnect())
  })

  return { sentinel }
}
```

### 11.2 Web Workers

```typescript
// worker.ts
self.onmessage = (e: MessageEvent) => {
  const { data, type } = e.data

  if (type === 'heavy-computation') {
    // 耗时计算
    const result = performHeavyComputation(data)
    self.postMessage({ type: 'result', data: result })
  }
}


// main.ts
const worker = new Worker(new URL('./worker.ts', import.meta.url), {
  type: 'module'
})

worker.postMessage({ type: 'heavy-computation', data: largeDataset })

worker.onmessage = (e: MessageEvent) => {
  console.log('Result:', e.data)
}
```

### 11.3 IndexedDB封装

```typescript
// utils/db.ts
class IndexedDBWrapper {
  private dbName: string
  private db: IDBDatabase | null = null

  constructor(dbName: string) {
    this.dbName = dbName
  }

  async open(storeName: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1)

      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        this.db = request.result
        resolve()
      }

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: 'id' })
        }
      }
    })
  }

  async get<T>(storeName: string, key: string): Promise<T | undefined> {
    const transaction = this.db!.transaction(storeName, 'readonly')
    const store = transaction.objectStore(storeName)
    const request = store.get(key)

    return new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result)
      request.onerror = () => reject(request.error)
    })
  }

  async set(storeName: string, value: any): Promise<void> {
    const transaction = this.db!.transaction(storeName, 'readwrite')
    const store = transaction.objectStore(storeName)
    store.put(value)

    return new Promise((resolve, reject) => {
      transaction.oncomplete = () => resolve()
      transaction.onerror = () => reject(transaction.error)
    })
  }
}
```

---

## 12. 构建优化与部署

### 12.1 Vite配置优化

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import { visualizer } from 'rollup-plugin-visualizer'

export default defineConfig({
  plugins: [
    vue(),
    visualizer({ open: true })  // 分析打包体积
  ],

  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },

  build: {
    // 代码分割
    rollupOptions: {
      output: {
        manualChunks: {
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          'ui-vendor': ['element-plus'],
          'utils': ['axios', 'dayjs', 'lodash-es'],
        },
      },
    },

    // 压缩
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,  // 生产环境移除console
        drop_debugger: true,
      },
    },

    // chunk大小警告
    chunkSizeWarningLimit: 1000,
  },

  // 开发服务器
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
    },
  },
})
```

### 12.2 环境变量

```bash
# .env
VITE_APP_TITLE=My App
VITE_API_BASE_URL=http://localhost:8080

# .env.production
VITE_API_BASE_URL=https://api.production.com
```

```typescript
// 使用
const apiUrl = import.meta.env.VITE_API_BASE_URL
const isDev = import.meta.env.DEV
const isProd = import.meta.env.PROD
```

### 12.3 Docker部署

```dockerfile
# Dockerfile
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

```nginx
# nginx.conf
server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip压缩
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;

    # SPA路由
    location / {
        try_files $uri $uri/ /index.html;
    }

    # 缓存静态资源
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # API代理
    location /api {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

---

## 总结：前端专业主义

### 核心原则

1. **框架选择** - 根据项目规模和团队选择合适的框架
2. **组件设计** - 小而专注，高内聚低耦合，复用性强
3. **状态管理** - 区分UI/服务器/全局状态，合理选择方案
4. **性能优先** - 首屏加载、列表渲染、图片优化、代码分割
5. **类型安全** - TypeScript全面覆盖，减少运行时错误
6. **工程化** - 自动化lint、test、build、deploy
7. **用户体验** - 加载状态、错误处理、响应式设计

### 技术栈推荐（2024）

**小型项目**
- Vue3 + Vite + Pinia + Tailwind + TypeScript

**中型SPA**
- React + Next.js + Zustand + TanStack Query + Tailwind + TypeScript

**大型应用**
- React/Vue + Micro Frontend + Monorepo(Nx/Turborepo)

**工具链**
- 构建：Vite / Turbopack
- 包管理：pnpm
- 代码质量：ESLint + Prettier + TypeScript
- 测试：Vitest + Testing Library
- CI/CD：GitHub Actions

**记住：技术是为业务服务的，不要为了用新技术而用新技术。选择稳定、成熟、团队熟悉的方案，比追求最新最炫更重要。**
