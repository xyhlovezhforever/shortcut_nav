# 前端项目顶级开发实践指南

> 十年前端经验总结 - 从编码技巧到架构思维的完整实战方案

---

## 目录

1. [项目结构与工程化](#1-项目结构与工程化)
2. [Vue3/React 编码最佳实践](#2-vue3react-编码最佳实践)
3. [TypeScript 实战技巧](#3-typescript-实战技巧)
4. [组件设计模式](#4-组件设计模式)
5. [状态管理实战](#5-状态管理实战)
6. [性能优化手册](#6-性能优化手册)
7. [CSS 架构与样式方案](#7-css-架构与样式方案)
8. [网络请求与错误处理](#8-网络请求与错误处理)
9. [常见陷阱与解决方案](#9-常见陷阱与解决方案)
10. [代码质量保障](#10-代码质量保障)

---

## 1. 项目结构与工程化

### 1.1 目录结构的演进

**小型项目（1-3个月）**
```
src/
├── components/     # 所有组件
├── pages/          # 页面
├── utils/          # 工具
├── api/            # 接口
└── App.tsx
```

**中型项目（3-12个月）**
```
src/
├── components/
│   ├── ui/         # Button, Input 等通用UI
│   └── business/   # Header, UserCard 等业务组件
├── pages/
├── hooks/          # 自定义 hooks
├── services/       # API 服务层
├── stores/         # 状态管理
└── types/          # TypeScript 类型
```

**大型项目（1年+）**
```
src/
├── features/       # 按功能模块组织
│   ├── auth/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── api/
│   │   ├── types/
│   │   └── index.ts
│   ├── dashboard/
│   └── user/
└── shared/         # 共享资源
    ├── components/
    ├── hooks/
    └── utils/
```

**核心原则**：
- 不要一开始就用复杂结构
- 当文件找不到时才重构
- 优先按功能分组，而非技术类型

---

## 2. Vue3/React 编码最佳实践

### 2.1 Vue3 Composition API 核心模式

**基础组合式函数**
```typescript
// composables/useUser.ts
import { ref, computed } from 'vue'

export function useUser(userId: string) {
  const user = ref<User | null>(null)
  const loading = ref(false)
  const error = ref<Error | null>(null)

  const isAdmin = computed(() => user.value?.role === 'admin')

  const fetchUser = async () => {
    loading.value = true
    try {
      const res = await fetch(`/api/users/${userId}`)
      user.value = await res.json()
    } catch (e) {
      error.value = e as Error
    } finally {
      loading.value = false
    }
  }

  return { user, loading, error, isAdmin, fetchUser }
}

// 使用
<script setup lang="ts">
const { user, loading, fetchUser } = useUser('123')
onMounted(() => fetchUser())
</script>
```

**响应式最佳实践**
```typescript
// ❌ 错误：丢失响应式
const state = reactive({ count: 0 })
const { count } = state  // count 不再响应式

// ✅ 正确：保持响应式
const { count } = toRefs(state)

// ❌ 错误：直接修改 ref 对象
const user = ref({ name: 'John' })
user.name = 'Jane'  // 不会触发更新

// ✅ 正确：替换整个对象
user.value = { name: 'Jane' }
```

**组件通信模式**
```vue
<!-- 父子通信：Props + Emits -->
<script setup lang="ts">
// 子组件
interface Props {
  modelValue: string
  disabled?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  disabled: false
})

const emit = defineEmits<{
  'update:modelValue': [value: string]
  'submit': [value: string]
}>()

const handleInput = (e: Event) => {
  emit('update:modelValue', (e.target as HTMLInputElement).value)
}
</script>

<!-- 跨层通信：Provide/Inject -->
<!-- 父组件 -->
<script setup>
provide('theme', ref('dark'))
</script>

<!-- 孙组件 -->
<script setup>
const theme = inject<Ref<string>>('theme')
</script>
```

### 2.2 React Hooks 核心模式

**自定义 Hook 最佳实践**
```typescript
// hooks/useDebounce.ts
import { useEffect, useState } from 'react'

export function useDebounce<T>(value: T, delay = 500): T {
  const [debouncedValue, setDebouncedValue] = useState(value)

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay)
    return () => clearTimeout(timer)  // 清理
  }, [value, delay])

  return debouncedValue
}

// hooks/useFetch.ts
export function useFetch<T>(url: string) {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  useEffect(() => {
    let cancelled = false

    const fetchData = async () => {
      try {
        const res = await fetch(url)
        const json = await res.json()
        if (!cancelled) setData(json)
      } catch (e) {
        if (!cancelled) setError(e as Error)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }

    fetchData()
    return () => { cancelled = true }  // 避免内存泄漏
  }, [url])

  return { data, loading, error }
}
```

**性能优化模式**
```typescript
// ❌ 每次渲染都创建新对象/函数
function Parent() {
  const config = { theme: 'dark' }  // 新对象
  const handleClick = () => {}      // 新函数
  return <Child config={config} onClick={handleClick} />
}

// ✅ 使用 useMemo/useCallback
function Parent() {
  const config = useMemo(() => ({ theme: 'dark' }), [])
  const handleClick = useCallback(() => {}, [])
  return <Child config={config} onClick={handleClick} />
}

// ✅ React.memo 避免重渲染
const Child = memo(function Child({ config, onClick }: Props) {
  return <button onClick={onClick}>Click</button>
})
```

**Context 优化模式**
```typescript
// ❌ 单个 Context 导致不必要的重渲染
const ThemeContext = createContext({
  theme: 'dark',
  setTheme: () => {}
})

// ✅ 拆分 Context
const ThemeValueContext = createContext('dark')
const ThemeUpdateContext = createContext<(theme: string) => void>(() => {})

function ThemeProvider({ children }: Props) {
  const [theme, setTheme] = useState('dark')
  return (
    <ThemeValueContext.Provider value={theme}>
      <ThemeUpdateContext.Provider value={setTheme}>
        {children}
      </ThemeUpdateContext.Provider>
    </ThemeValueContext.Provider>
  )
}

// 只读取不会因 setter 变化而重渲染
function useTheme() {
  return useContext(ThemeValueContext)
}
```

---

## 3. TypeScript 实战技巧

### 3.1 类型设计模式

**精确的类型定义**
```typescript
// ❌ 太模糊
function processData(data: any) { }
function getData(): object { }

// ✅ 精确类型
interface User {
  id: number
  name: string
  email: string
  role: 'admin' | 'user'  // 字面量类型
}

function processData(data: User) { }
function getData(): User { }

// ✅ TypedDict 替代嵌套对象
import { type TypedDict, NotRequired } from 'typescript'

interface OrderData {
  orderId: number
  items: Array<{ sku: string; qty: number }>
  total: number
  discount?: number  // 可选
}
```

**实用工具类型**
```typescript
type User = {
  id: number
  name: string
  email: string
  password: string
  createdAt: Date
}

// Pick - 选取部分属性
type UserPublic = Pick<User, 'id' | 'name' | 'email'>

// Omit - 排除属性
type UserCreate = Omit<User, 'id' | 'createdAt'>

// Partial - 所有属性可选
type UserUpdate = Partial<User>

// Required - 所有属性必填
type UserRequired = Required<User>

// Readonly - 只读
type UserReadonly = Readonly<User>
```

**泛型约束**
```typescript
// ✅ 泛型约束提取ID
function getIds<T extends { id: number }>(items: T[]): number[] {
  return items.map(item => item.id)
}

// ✅ 多个泛型参数
function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>
  keys.forEach(key => { result[key] = obj[key] })
  return result
}

const user = { id: 1, name: 'John', email: 'john@example.com' }
const picked = pick(user, ['id', 'name'])  // { id: number, name: string }
```

**类型守卫**
```typescript
// typeof 守卫
function format(value: string | number) {
  if (typeof value === 'string') {
    return value.toUpperCase()
  }
  return value.toFixed(2)
}

// in 守卫
type Dog = { bark: () => void }
type Cat = { meow: () => void }

function makeSound(animal: Dog | Cat) {
  if ('bark' in animal) {
    animal.bark()
  } else {
    animal.meow()
  }
}

// 自定义守卫
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'name' in obj
  )
}
```

### 3.2 高级类型模式

**条件类型**
```typescript
type IsString<T> = T extends string ? true : false
type A = IsString<'hello'>  // true
type B = IsString<number>   // false

// 实用：提取 Promise 返回类型
type Awaited<T> = T extends Promise<infer U> ? U : T
type Result = Awaited<Promise<string>>  // string
```

**映射类型**
```typescript
// 所有属性可空
type Nullable<T> = {
  [K in keyof T]: T[K] | null
}

// 深度只读
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object
    ? DeepReadonly<T[K]>
    : T[K]
}
```

---

## 4. 组件设计模式

### 4.1 复合组件模式

**React 实现**
```typescript
// Tabs.tsx
import { createContext, useContext, useState } from 'react'

type TabsContextType = {
  activeTab: string
  setActiveTab: (tab: string) => void
}

const TabsContext = createContext<TabsContextType | undefined>(undefined)

export function Tabs({
  children,
  defaultTab
}: {
  children: React.ReactNode
  defaultTab: string
}) {
  const [activeTab, setActiveTab] = useState(defaultTab)
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  )
}

Tabs.List = function TabsList({ children }: { children: React.ReactNode }) {
  return <div className="tabs-list">{children}</div>
}

Tabs.Tab = function Tab({ value, children }: { value: string; children: React.ReactNode }) {
  const ctx = useContext(TabsContext)!
  return (
    <button
      className={ctx.activeTab === value ? 'active' : ''}
      onClick={() => ctx.setActiveTab(value)}
    >
      {children}
    </button>
  )
}

Tabs.Panel = function TabPanel({ value, children }: { value: string; children: React.ReactNode }) {
  const ctx = useContext(TabsContext)!
  if (ctx.activeTab !== value) return null
  return <div className="tab-panel">{children}</div>
}

// 使用
<Tabs defaultTab="profile">
  <Tabs.List>
    <Tabs.Tab value="profile">Profile</Tabs.Tab>
    <Tabs.Tab value="settings">Settings</Tabs.Tab>
  </Tabs.List>
  <Tabs.Panel value="profile">Profile content</Tabs.Panel>
  <Tabs.Panel value="settings">Settings content</Tabs.Panel>
</Tabs>
```

**Vue3 实现**
```vue
<!-- Tabs.vue -->
<script setup lang="ts">
import { provide, ref } from 'vue'

const activeTab = ref('profile')
provide('activeTab', activeTab)
</script>

<template>
  <div class="tabs">
    <slot />
  </div>
</template>

<!-- Tab.vue -->
<script setup lang="ts">
import { inject } from 'vue'

const props = defineProps<{ value: string }>()
const activeTab = inject<Ref<string>>('activeTab')!
</script>

<template>
  <button
    :class="{ active: activeTab === value }"
    @click="activeTab = value"
  >
    <slot />
  </button>
</template>
```

### 4.2 Render Props / Scoped Slots

**React Render Props**
```typescript
interface ListProps<T> {
  items: T[]
  renderItem: (item: T, index: number) => React.ReactNode
  renderEmpty?: () => React.ReactNode
}

function List<T>({ items, renderItem, renderEmpty }: ListProps<T>) {
  if (items.length === 0) {
    return <>{renderEmpty?.() ?? 'No items'}</>
  }

  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item, index)}</li>
      ))}
    </ul>
  )
}

// 使用
<List
  items={users}
  renderItem={(user) => (
    <div>
      <img src={user.avatar} />
      <span>{user.name}</span>
    </div>
  )}
/>
```

**Vue Scoped Slots**
```vue
<!-- List.vue -->
<template>
  <ul v-if="items.length">
    <li v-for="(item, index) in items" :key="index">
      <slot name="item" :item="item" :index="index" />
    </li>
  </ul>
  <div v-else>
    <slot name="empty">No items</slot>
  </div>
</template>

<!-- 使用 -->
<List :items="users">
  <template #item="{ item }">
    <div>
      <img :src="item.avatar" />
      <span>{{ item.name }}</span>
    </div>
  </template>
</List>
```

---

## 5. 状态管理实战

### 5.1 Vue3 + Pinia

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { computed, ref } from 'vue'

export const useUserStore = defineStore('user', () => {
  // State
  const user = ref<User | null>(null)
  const token = ref('')
  const loading = ref(false)

  // Getters
  const isLoggedIn = computed(() => !!token.value)
  const userName = computed(() => user.value?.name ?? 'Guest')

  // Actions
  async function login(email: string, password: string) {
    loading.value = true
    try {
      const res = await fetch('/api/login', {
        method: 'POST',
        body: JSON.stringify({ email, password })
      })
      const data = await res.json()
      user.value = data.user
      token.value = data.token
    } finally {
      loading.value = false
    }
  }

  function logout() {
    user.value = null
    token.value = ''
  }

  return { user, token, loading, isLoggedIn, userName, login, logout }
})

// 组件中使用
import { storeToRefs } from 'pinia'

const userStore = useUserStore()
const { user, isLoggedIn } = storeToRefs(userStore)  // 保持响应式
const { login, logout } = userStore  // actions 直接解构
```

### 5.2 React + Zustand

```typescript
// stores/userStore.ts
import { create } from 'zustand'
import { persist, devtools } from 'zustand/middleware'

interface UserState {
  user: User | null
  token: string
  loading: boolean
  login: (email: string, password: string) => Promise<void>
  logout: () => void
}

export const useUserStore = create<UserState>()(
  devtools(
    persist(
      (set) => ({
        user: null,
        token: '',
        loading: false,

        login: async (email, password) => {
          set({ loading: true })
          try {
            const res = await fetch('/api/login', {
              method: 'POST',
              body: JSON.stringify({ email, password })
            })
            const data = await res.json()
            set({ user: data.user, token: data.token })
          } finally {
            set({ loading: false })
          }
        },

        logout: () => {
          set({ user: null, token: '' })
        }
      }),
      { name: 'user-storage' }
    )
  )
)

// 组件中使用
function Profile() {
  // 选择性订阅，只在 user 变化时重渲染
  const user = useUserStore((state) => state.user)
  const login = useUserStore((state) => state.login)

  return <div>{user?.name}</div>
}
```

### 5.3 TanStack Query（服务器状态）

```typescript
// React
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

function UserList() {
  // 查询
  const { data: users, isLoading } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json()),
    staleTime: 5 * 60 * 1000,  // 5分钟内认为数据新鲜
  })

  const queryClient = useQueryClient()

  // 变更
  const createMutation = useMutation({
    mutationFn: (newUser: User) =>
      fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(newUser)
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] })
    }
  })

  return (
    <div>
      {isLoading && <div>Loading...</div>}
      {users?.map(user => <div key={user.id}>{user.name}</div>)}
      <button onClick={() => createMutation.mutate({ name: 'New User' })}>
        Add User
      </button>
    </div>
  )
}
```

---

## 6. 性能优化手册

### 6.1 列表渲染优化

**虚拟滚动**
```typescript
// react-window 示例
import { FixedSizeList } from 'react-window'

function VirtualList({ items }: { items: Item[] }) {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      {items[index].name}
    </div>
  )

  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  )
}
```

**Vue3 v-memo**
```vue
<template>
  <!-- 只有 item.id 或 item.name 变化才重新渲染 -->
  <div
    v-for="item in list"
    :key="item.id"
    v-memo="[item.id, item.name]"
  >
    {{ item.name }}
  </div>
</template>
```

### 6.2 代码分割

**React Lazy + Suspense**
```typescript
import { lazy, Suspense } from 'react'

const Dashboard = lazy(() => import('./Dashboard'))
const Settings = lazy(() => import('./Settings'))

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/settings" element={<Settings />} />
      </Routes>
    </Suspense>
  )
}
```

**Vue3 defineAsyncComponent**
```typescript
import { defineAsyncComponent } from 'vue'

const Dashboard = defineAsyncComponent(() =>
  import('./Dashboard.vue')
)

// 带选项
const AsyncComp = defineAsyncComponent({
  loader: () => import('./Dashboard.vue'),
  loadingComponent: Loading,
  errorComponent: Error,
  delay: 200,
  timeout: 3000
})
```

### 6.3 图片优化

**响应式图片**
```html
<img
  src="image-800w.jpg"
  srcset="
    image-400w.jpg 400w,
    image-800w.jpg 800w,
    image-1200w.jpg 1200w
  "
  sizes="(max-width: 600px) 400px,
         (max-width: 900px) 800px,
         1200px"
  loading="lazy"
  alt="Description"
/>

<!-- 现代格式 -->
<picture>
  <source srcset="image.avif" type="image/avif">
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="Fallback">
</picture>
```

**懒加载（IntersectionObserver）**
```typescript
export function lazyLoadImages() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement
        img.src = img.dataset.src!
        img.classList.remove('lazy')
        observer.unobserve(img)
      }
    })
  })

  document.querySelectorAll('img.lazy').forEach(img => {
    observer.observe(img)
  })
}
```

### 6.4 防抖与节流

```typescript
// 防抖：最后一次有效
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay = 300
): (...args: Parameters<T>) => void {
  let timer: ReturnType<typeof setTimeout> | null = null

  return function (this: any, ...args: Parameters<T>) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => fn.apply(this, args), delay)
  }
}

// 节流：固定频率执行
export function throttle<T extends (...args: any[]) => any>(
  fn: T,
  delay = 300
): (...args: Parameters<T>) => void {
  let lastTime = 0

  return function (this: any, ...args: Parameters<T>) {
    const now = Date.now()
    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 使用
const handleSearch = debounce((keyword: string) => {
  fetch(`/api/search?q=${keyword}`)
}, 500)

const handleScroll = throttle(() => {
  console.log('scroll position:', window.scrollY)
}, 200)
```

---

## 7. CSS 架构与样式方案

### 7.1 CSS Modules

```typescript
// Button.module.css
.button {
  padding: 0.5rem 1rem;
  border-radius: 0.25rem;
}

.primary {
  background: blue;
  color: white;
}

// Button.tsx
import styles from './Button.module.css'

function Button({ variant }: { variant: 'primary' | 'secondary' }) {
  return (
    <button className={`${styles.button} ${styles[variant]}`}>
      Click me
    </button>
  )
}
```

### 7.2 Tailwind CSS

```typescript
import { cn } from '@/utils/cn'  // clsx + tailwind-merge

function Button({ variant }: { variant: 'primary' | 'secondary' }) {
  const variants = {
    primary: 'bg-blue-500 text-white hover:bg-blue-600',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300'
  }

  return (
    <button className={cn(
      'px-4 py-2 rounded-md transition',
      variants[variant]
    )}>
      Click me
    </button>
  )
}
```

### 7.3 CSS 变量 + 主题切换

```css
/* globals.css */
:root {
  --color-primary: #3b82f6;
  --color-bg: #ffffff;
  --color-text: #000000;
}

[data-theme='dark'] {
  --color-bg: #000000;
  --color-text: #ffffff;
}

.button {
  background: var(--color-primary);
  color: var(--color-text);
}
```

```typescript
// 主题切换
function toggleTheme() {
  const html = document.documentElement
  const currentTheme = html.getAttribute('data-theme')
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark'

  html.setAttribute('data-theme', newTheme)
  localStorage.setItem('theme', newTheme)
}
```

---

## 8. 网络请求与错误处理

### 8.1 Axios 封装

```typescript
// utils/request.ts
import axios, { type AxiosInstance, type AxiosRequestConfig } from 'axios'

class Request {
  private instance: AxiosInstance

  constructor(baseURL: string) {
    this.instance = axios.create({
      baseURL,
      timeout: 10000
    })

    // 请求拦截器
    this.instance.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('token')
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        return config
      },
      (error) => Promise.reject(error)
    )

    // 响应拦截器
    this.instance.interceptors.response.use(
      (response) => response.data,
      (error) => {
        if (error.response?.status === 401) {
          window.location.href = '/login'
        }
        return Promise.reject(error)
      }
    )
  }

  get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    return this.instance.get(url, config)
  }

  post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    return this.instance.post(url, data, config)
  }
}

export const request = new Request(import.meta.env.VITE_API_BASE_URL)
```

### 8.2 错误边界

**React Error Boundary**
```typescript
import { Component, type ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error: Error | null
}

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false, error: null }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught:', error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback ?? <div>Something went wrong</div>
    }
    return this.props.children
  }
}

// 使用
<ErrorBoundary fallback={<ErrorPage />}>
  <App />
</ErrorBoundary>
```

**Vue3 Error Handler**
```typescript
// main.ts
app.config.errorHandler = (err, instance, info) => {
  console.error('Global error:', err, info)
}

// 组件级
<script setup>
import { onErrorCaptured } from 'vue'

onErrorCaptured((err, instance, info) => {
  console.error('Component error:', err)
  return false  // 阻止传播
})
</script>
```

---

## 9. 常见陷阱与解决方案

### 9.1 闭包陷阱

```typescript
// ❌ 问题：循环中的闭包
const functions = []
for (let i = 0; i < 5; i++) {
  functions.push(() => console.log(i))
}
functions.forEach(f => f())  // 都是 5

// ✅ 解决：立即绑定
const functions = []
for (let i = 0; i < 5; i++) {
  functions.push((i => () => console.log(i))(i))
}

// ✅ 或使用 let（块级作用域）
for (let i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 100)  // 0,1,2,3,4
}
```

### 9.2 异步陷阱

```typescript
// ❌ 问题：Promise 串行执行
async function fetchAll() {
  const user = await fetchUser()     // 等待 100ms
  const posts = await fetchPosts()   // 等待 150ms
  const stats = await fetchStats()   // 等待 200ms
  // 总耗时: 450ms
}

// ✅ 解决：并行执行
async function fetchAll() {
  const [user, posts, stats] = await Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchStats()
  ])
  // 总耗时: ~200ms (最慢的那个)
}
```

### 9.3 内存泄漏

```typescript
// ❌ 问题：忘记清理事件监听
useEffect(() => {
  window.addEventListener('resize', handleResize)
  // 没有清理！
}, [])

// ✅ 解决：返回清理函数
useEffect(() => {
  window.addEventListener('resize', handleResize)
  return () => {
    window.removeEventListener('resize', handleResize)
  }
}, [])

// ❌ 问题：组件卸载后仍然设置状态
useEffect(() => {
  fetchData().then(data => {
    setState(data)  // 组件可能已卸载
  })
}, [])

// ✅ 解决：使用 cleanup flag
useEffect(() => {
  let cancelled = false

  fetchData().then(data => {
    if (!cancelled) {
      setState(data)
    }
  })

  return () => { cancelled = true }
}, [])
```

---

## 10. 代码质量保障

### 10.1 ESLint + Prettier 配置

```javascript
// .eslintrc.cjs
module.exports = {
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'prettier'
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': ['error', {
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^_'
    }],
    'react/prop-types': 'off',  // 使用 TypeScript
    'react-hooks/exhaustive-deps': 'warn',
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off'
  }
}
```

```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "printWidth": 100,
  "trailingComma": "es5",
  "arrowParens": "always"
}
```

### 10.2 Git Hooks

```bash
# .husky/pre-commit
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx lint-staged
```

```json
// package.json
{
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,scss,md}": [
      "prettier --write"
    ]
  }
}
```

### 10.3 单元测试

```typescript
// Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { Button } from './Button'

describe('Button', () => {
  it('renders correctly', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByText('Click me')).toBeInTheDocument()
  })

  it('handles click events', () => {
    const handleClick = vi.fn()
    render(<Button onClick={handleClick}>Click me</Button>)

    fireEvent.click(screen.getByText('Click me'))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })

  it('applies variant styles', () => {
    render(<Button variant="primary">Click me</Button>)
    const button = screen.getByText('Click me')
    expect(button).toHaveClass('primary')
  })
})
```

---

## 总结：10年前端的编码智慧

### 核心原则

1. **组件设计**
   - 单一职责，高内聚低耦合
   - Props 设计要直观
   - 优先组合而非继承

2. **性能优化**
   - 先测量再优化
   - 虚拟滚动解决长列表
   - 代码分割减小包体积
   - 图片懒加载

3. **状态管理**
   - 区分UI状态、服务器状态、全局状态
   - TanStack Query 管理服务器数据
   - 状态尽量放在最近的父组件

4. **类型安全**
   - TypeScript 严格模式
   - 泛型提升代码复用
   - 类型守卫增强类型推导

5. **代码质量**
   - ESLint + Prettier 自动化
   - Git Hooks 强制检查
   - 单元测试覆盖核心逻辑

### 记住

> 好的代码不是写出来的，是重构出来的。
>
> 先让代码工作，再让代码优雅，最后让代码高效。
>
> 写代码如同写诗，追求的是清晰表达，不是炫技。
