# 上下文工程事件详解

> **文档版本**: v1.0
> **创建日期**: 2026-01-05
> **适用场景**: 执行过程的结构化记录与自我验证

---

## 1. 功能概述

上下文工程事件（Context Engineering Event）是一个**结构化的执行过程记录系统**，用于：

- **步骤信息收集**：动态收集每个步骤的执行详情
- **成功/失败分类**：分别记录成功步骤和失败步骤的不同信息
- **反思数据整合**：将失败步骤的反思分析纳入记录
- **自我验证支持**：输出可供LLM自我检查的结构化数据

```
┌─────────────────────────────────────────────────────────────────┐
│                 上下文工程事件生命周期                            │
│                                                                  │
│  ┌──────────┐   步骤执行   ┌──────────────┐                     │
│  │  任务开始 │────────────>│ 步骤1执行     │                     │
│  └──────────┘             └──────┬───────┘                     │
│                                  │                              │
│                     ┌────────────┴────────────┐                 │
│                     │                         │                 │
│                     ▼                         ▼                 │
│            ┌──────────────┐          ┌──────────────┐           │
│            │   成功       │          │    失败      │           │
│            │ 记录到成功列表│          │ 触发反思     │           │
│            └──────┬───────┘          └──────┬───────┘           │
│                   │                         │                   │
│                   │                         ▼                   │
│                   │                 ┌──────────────┐            │
│                   │                 │  反思分析    │            │
│                   │                 │ 生成恢复方案 │            │
│                   │                 └──────┬───────┘            │
│                   │                         │                   │
│                   │                         ▼                   │
│                   │                 ┌──────────────┐            │
│                   │                 │ 记录到失败列表│            │
│                   │                 │ (含反思信息) │            │
│                   │                 └──────┬───────┘            │
│                   │                         │                   │
│                   └────────────┬────────────┘                   │
│                                │                                │
│                                ▼                                │
│                     ┌──────────────────┐                        │
│                     │  任务完成/终止   │                        │
│                     │  构建完整事件    │                        │
│                     └────────┬─────────┘                        │
│                              │                                  │
│                              ▼                                  │
│                     ┌──────────────────┐                        │
│                     │  输出到文件/事件 │                        │
│                     │  用于自我验证    │                        │
│                     └──────────────────┘                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 核心数据结构

### 2.1 Proto定义

```protobuf
// context_engineering_event.proto

syntax = "proto3";
package orchestration;

// 上下文工程事件
message ContextEngineeringEvent {
    // 任务描述
    string task_description = 1;

    // 成功步骤列表
    repeated SuccessfulStepInfo successful_steps = 2;

    // 失败步骤列表
    repeated FailedStepInfo failed_steps = 3;

    // 事件创建时间戳
    int64 timestamp = 4;
}

// 成功步骤信息
message SuccessfulStepInfo {
    // 步骤ID
    string step_id = 1;

    // 步骤名称
    string step_name = 2;

    // 使用的工具ID
    string tool_id = 3;

    // 工具参数（JSON格式）
    string tool_parameters = 4;

    // 工具输出（JSON格式）
    string tool_output = 5;

    // 依赖的步骤ID列表
    repeated string dependencies = 6;

    // 提取的字段（步骤输出中被后续使用的字段）
    map<string, string> extracted_fields = 7;
}

// 失败步骤信息
message FailedStepInfo {
    // 步骤ID
    string step_id = 1;

    // 步骤名称
    string step_name = 2;

    // 使用的工具ID
    string tool_id = 3;

    // 工具参数（JSON格式）
    string tool_parameters = 4;

    // 错误信息
    string error_message = 5;

    // 依赖的步骤ID列表
    repeated string dependencies = 6;

    // 反思与行动分析
    // 包含失败原因分析和恢复策略
    string reflection_and_action = 7;
}
```

### 2.2 Rust结构定义

```rust
/// 成功步骤数据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuccessfulStepData {
    /// 步骤ID
    pub step_id: String,

    /// 步骤名称
    pub step_name: String,

    /// 工具ID
    pub tool_id: String,

    /// 工具参数
    pub tool_parameters: serde_json::Value,

    /// 工具输出
    pub tool_output: serde_json::Value,

    /// 依赖步骤
    pub dependencies: Vec<String>,

    /// 提取的字段
    pub extracted_fields: HashMap<String, String>,
}

/// 失败步骤数据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FailedStepData {
    /// 步骤ID
    pub step_id: String,

    /// 步骤名称
    pub step_name: String,

    /// 工具ID
    pub tool_id: String,

    /// 工具参数
    pub tool_parameters: serde_json::Value,

    /// 错误信息
    pub error_message: String,

    /// 依赖步骤
    pub dependencies: Vec<String>,

    /// 反思与行动
    pub reflection_and_action: String,
}

/// 上下文工程事件
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextEngineeringEvent {
    /// 任务描述
    pub task_description: String,

    /// 成功步骤列表
    pub successful_steps: Vec<SuccessfulStepData>,

    /// 失败步骤列表
    pub failed_steps: Vec<FailedStepData>,

    /// 时间戳
    pub timestamp: i64,
}
```

---

## 3. ContextEngineeringEventBuilder

### 3.1 构建器结构

```rust
/// 上下文工程事件构建器
/// 在任务执行过程中动态收集步骤信息
pub struct ContextEngineeringEventBuilder {
    /// 任务描述
    task_description: String,

    /// 成功步骤集合
    successful_steps: Vec<SuccessfulStepData>,

    /// 失败步骤集合
    failed_steps: Vec<FailedStepData>,

    /// 构建开始时间
    start_time: chrono::DateTime<chrono::Utc>,
}

impl ContextEngineeringEventBuilder {
    /// 创建新的构建器
    pub fn new(task_description: &str) -> Self {
        Self {
            task_description: task_description.to_string(),
            successful_steps: Vec::new(),
            failed_steps: Vec::new(),
            start_time: chrono::Utc::now(),
        }
    }
}
```

### 3.2 记录成功步骤

```rust
impl ContextEngineeringEventBuilder {
    /// 记录成功步骤
    pub fn record_successful_step(
        &mut self,
        step_id: &str,
        step_name: &str,
        tool_id: &str,
        tool_parameters: serde_json::Value,
        tool_output: serde_json::Value,
        dependencies: Vec<String>,
        extracted_fields: HashMap<String, String>,
    ) {
        let step_data = SuccessfulStepData {
            step_id: step_id.to_string(),
            step_name: step_name.to_string(),
            tool_id: tool_id.to_string(),
            tool_parameters,
            tool_output,
            dependencies,
            extracted_fields,
        };

        self.successful_steps.push(step_data);

        tracing::debug!(
            step_id = step_id,
            step_name = step_name,
            "Recorded successful step to context engineering event"
        );
    }

    /// 从ExecutionContext记录成功步骤
    pub fn record_from_context_success(
        &mut self,
        context: &ExecutionContext,
        step: &PlanStep,
        output: &serde_json::Value,
    ) {
        // 提取被后续步骤使用的字段
        let extracted_fields = self.extract_used_fields(context, step, output);

        self.record_successful_step(
            &step.step_id,
            &step.step_name,
            &step.tool_id,
            step.parameters.clone(),
            output.clone(),
            step.dependencies.clone(),
            extracted_fields,
        );
    }

    /// 提取被使用的字段
    fn extract_used_fields(
        &self,
        context: &ExecutionContext,
        step: &PlanStep,
        output: &serde_json::Value,
    ) -> HashMap<String, String> {
        let mut extracted = HashMap::new();

        // 检查后续步骤是否引用了当前步骤的输出
        if let Some(plan) = &context.current_plan {
            for future_step in &plan.steps {
                // 遍历参数查找占位符引用
                self.find_references(
                    &future_step.parameters,
                    &step.step_id,
                    output,
                    &mut extracted,
                );
            }
        }

        extracted
    }

    /// 查找参数中对特定步骤的引用
    fn find_references(
        &self,
        params: &serde_json::Value,
        step_id: &str,
        output: &serde_json::Value,
        extracted: &mut HashMap<String, String>,
    ) {
        match params {
            serde_json::Value::String(s) => {
                // 匹配 ${step_id.field} 格式
                let pattern = format!("${{{}.", step_id);
                if s.contains(&pattern) {
                    // 提取字段路径
                    if let Some(field) = self.extract_field_path(s, step_id) {
                        // 从output中获取实际值
                        if let Some(value) = self.get_value_at_path(output, &field) {
                            extracted.insert(field, value.to_string());
                        }
                    }
                }
            }
            serde_json::Value::Object(map) => {
                for (_, v) in map {
                    self.find_references(v, step_id, output, extracted);
                }
            }
            serde_json::Value::Array(arr) => {
                for v in arr {
                    self.find_references(v, step_id, output, extracted);
                }
            }
            _ => {}
        }
    }

    /// 提取字段路径
    fn extract_field_path(&self, placeholder: &str, step_id: &str) -> Option<String> {
        let prefix = format!("${{{}.", step_id);
        let suffix = "}";

        if let Some(start) = placeholder.find(&prefix) {
            let after_prefix = &placeholder[start + prefix.len()..];
            if let Some(end) = after_prefix.find(suffix) {
                return Some(after_prefix[..end].to_string());
            }
        }
        None
    }

    /// 从JSON中按路径获取值
    fn get_value_at_path(
        &self,
        value: &serde_json::Value,
        path: &str,
    ) -> Option<serde_json::Value> {
        let parts: Vec<&str> = path.split('.').collect();
        let mut current = value;

        for part in parts {
            match current {
                serde_json::Value::Object(map) => {
                    current = map.get(part)?;
                }
                serde_json::Value::Array(arr) => {
                    // 处理数组索引，如 [0]
                    if let Some(idx) = part.strip_prefix('[').and_then(|s| s.strip_suffix(']')) {
                        let index: usize = idx.parse().ok()?;
                        current = arr.get(index)?;
                    } else {
                        return None;
                    }
                }
                _ => return None,
            }
        }

        Some(current.clone())
    }
}
```

### 3.3 记录失败步骤

```rust
impl ContextEngineeringEventBuilder {
    /// 记录失败步骤
    pub fn record_failed_step(
        &mut self,
        step_id: &str,
        step_name: &str,
        tool_id: &str,
        tool_parameters: serde_json::Value,
        error_message: &str,
        dependencies: Vec<String>,
        reflection_and_action: &str,
    ) {
        let step_data = FailedStepData {
            step_id: step_id.to_string(),
            step_name: step_name.to_string(),
            tool_id: tool_id.to_string(),
            tool_parameters,
            error_message: error_message.to_string(),
            dependencies,
            reflection_and_action: reflection_and_action.to_string(),
        };

        self.failed_steps.push(step_data);

        tracing::debug!(
            step_id = step_id,
            step_name = step_name,
            error = error_message,
            "Recorded failed step to context engineering event"
        );
    }

    /// 从ExecutionContext记录失败步骤
    pub fn record_from_context_failure(
        &mut self,
        context: &ExecutionContext,
        step: &PlanStep,
        error: &StepError,
        reflection: &ReflectionResult,
    ) {
        // 格式化反思与行动信息
        let reflection_and_action = self.format_reflection(reflection);

        self.record_failed_step(
            &step.step_id,
            &step.step_name,
            &step.tool_id,
            step.parameters.clone(),
            &error.message,
            step.dependencies.clone(),
            &reflection_and_action,
        );
    }

    /// 格式化反思信息
    fn format_reflection(&self, reflection: &ReflectionResult) -> String {
        let mut output = String::new();

        output.push_str("## 失败原因分析\n");
        output.push_str(&reflection.failure_analysis);
        output.push_str("\n\n");

        output.push_str("## 根因定位\n");
        output.push_str(&reflection.root_cause);
        output.push_str("\n\n");

        output.push_str("## 恢复策略\n");
        match &reflection.recovery_strategy {
            RecoveryStrategy::Retry { reason, modifications } => {
                output.push_str(&format!("策略: 重试\n原因: {}\n", reason));
                if !modifications.is_empty() {
                    output.push_str("参数修改:\n");
                    for (k, v) in modifications {
                        output.push_str(&format!("  - {}: {}\n", k, v));
                    }
                }
            }
            RecoveryStrategy::Skip { reason } => {
                output.push_str(&format!("策略: 跳过\n原因: {}\n", reason));
            }
            RecoveryStrategy::Replan { reason, scope } => {
                output.push_str(&format!("策略: 重新规划\n原因: {}\n范围: {:?}\n", reason, scope));
            }
            RecoveryStrategy::Abort { reason } => {
                output.push_str(&format!("策略: 中止\n原因: {}\n", reason));
            }
        }

        output
    }
}
```

### 3.4 构建最终事件

```rust
impl ContextEngineeringEventBuilder {
    /// 构建最终的上下文工程事件
    pub fn build(self) -> ContextEngineeringEvent {
        ContextEngineeringEvent {
            task_description: self.task_description,
            successful_steps: self.successful_steps,
            failed_steps: self.failed_steps,
            timestamp: chrono::Utc::now().timestamp_millis(),
        }
    }

    /// 构建并输出到文件
    pub fn build_and_save(self, file_path: &str) -> Result<ContextEngineeringEvent> {
        let event = self.build();

        // 格式化为可读的文本
        let content = self.format_for_file(&event);

        // 写入文件
        std::fs::write(file_path, content)?;

        tracing::info!(
            file_path = file_path,
            successful_count = event.successful_steps.len(),
            failed_count = event.failed_steps.len(),
            "Context engineering event saved to file"
        );

        Ok(event)
    }

    /// 格式化为文件输出格式
    fn format_for_file(&self, event: &ContextEngineeringEvent) -> String {
        let mut output = String::new();

        output.push_str("# 上下文工程事件报告\n\n");
        output.push_str(&format!("**任务描述**: {}\n", event.task_description));
        output.push_str(&format!("**生成时间**: {}\n\n",
            chrono::DateTime::from_timestamp_millis(event.timestamp)
                .map(|dt| dt.to_rfc3339())
                .unwrap_or_default()
        ));

        output.push_str("---\n\n");

        // 成功步骤
        output.push_str("## 成功步骤\n\n");
        if event.successful_steps.is_empty() {
            output.push_str("*无成功步骤*\n\n");
        } else {
            for (i, step) in event.successful_steps.iter().enumerate() {
                output.push_str(&format!("### {}. {}\n\n", i + 1, step.step_name));
                output.push_str(&format!("- **步骤ID**: {}\n", step.step_id));
                output.push_str(&format!("- **工具**: {}\n", step.tool_id));
                output.push_str(&format!("- **依赖**: {:?}\n", step.dependencies));
                output.push_str(&format!("- **参数**: ```json\n{}\n```\n",
                    serde_json::to_string_pretty(&step.tool_parameters).unwrap_or_default()
                ));
                output.push_str(&format!("- **输出**: ```json\n{}\n```\n",
                    serde_json::to_string_pretty(&step.tool_output).unwrap_or_default()
                ));
                if !step.extracted_fields.is_empty() {
                    output.push_str("- **提取字段**:\n");
                    for (field, value) in &step.extracted_fields {
                        output.push_str(&format!("  - `{}`: {}\n", field, value));
                    }
                }
                output.push_str("\n");
            }
        }

        // 失败步骤
        output.push_str("## 失败步骤\n\n");
        if event.failed_steps.is_empty() {
            output.push_str("*无失败步骤*\n\n");
        } else {
            for (i, step) in event.failed_steps.iter().enumerate() {
                output.push_str(&format!("### {}. {} (失败)\n\n", i + 1, step.step_name));
                output.push_str(&format!("- **步骤ID**: {}\n", step.step_id));
                output.push_str(&format!("- **工具**: {}\n", step.tool_id));
                output.push_str(&format!("- **依赖**: {:?}\n", step.dependencies));
                output.push_str(&format!("- **参数**: ```json\n{}\n```\n",
                    serde_json::to_string_pretty(&step.tool_parameters).unwrap_or_default()
                ));
                output.push_str(&format!("- **错误**: {}\n", step.error_message));
                output.push_str(&format!("\n**反思与行动**:\n{}\n\n", step.reflection_and_action));
            }
        }

        output
    }
}
```

---

## 4. 执行流程集成

### 4.1 Executor集成

```rust
impl Executor {
    /// 执行步骤并记录到上下文工程事件
    pub async fn execute_step_with_recording(
        &self,
        context: &mut ExecutionContext,
        step: &PlanStep,
        event_builder: &mut ContextEngineeringEventBuilder,
    ) -> Result<StepOutput> {
        tracing::info!(step_id = %step.step_id, "Executing step");

        // 执行步骤
        match self.execute_step_inner(context, step).await {
            Ok(output) => {
                // 成功：记录到成功列表
                event_builder.record_from_context_success(context, step, &output.data);

                tracing::info!(
                    step_id = %step.step_id,
                    "Step completed successfully, recorded to context engineering event"
                );

                Ok(output)
            }
            Err(error) => {
                // 失败：先进行反思
                let reflection = self.reflector.reflect(context, step, &error).await?;

                // 记录失败步骤（含反思信息）
                event_builder.record_from_context_failure(context, step, &error, &reflection);

                tracing::warn!(
                    step_id = %step.step_id,
                    error = %error.message,
                    "Step failed, recorded to context engineering event with reflection"
                );

                Err(error)
            }
        }
    }
}
```

### 4.2 Orchestrator集成

```rust
impl Orchestrator {
    /// 执行任务编排（带上下文工程事件记录）
    pub async fn orchestrate_with_context_event(
        &self,
        request: OrchestrationRequest,
    ) -> Result<(OrchestrationResult, ContextEngineeringEvent)> {
        let mut context = ExecutionContext::new(request.clone());

        // 创建上下文工程事件构建器
        let mut event_builder = ContextEngineeringEventBuilder::new(
            &request.task_description
        );

        // 执行Reflective Planning循环
        let result = self.execute_loop_with_recording(&mut context, &mut event_builder).await?;

        // 构建最终事件
        let event = event_builder.build();

        // 如果配置了文件输出，保存到文件
        if let Some(output_path) = self.config.context_event_output_path.as_ref() {
            let file_path = format!("{}/{}_context_event.md", output_path, context.task_id);
            std::fs::write(&file_path, self.format_event_for_file(&event))?;
        }

        Ok((result, event))
    }

    /// 执行循环（带记录）
    async fn execute_loop_with_recording(
        &self,
        context: &mut ExecutionContext,
        event_builder: &mut ContextEngineeringEventBuilder,
    ) -> Result<OrchestrationResult> {
        loop {
            // 规划阶段
            let plan = self.planner.plan(context).await?;
            context.current_plan = Some(plan);

            // 执行阶段
            for step in context.current_plan.as_ref().unwrap().steps.iter() {
                match self.executor.execute_step_with_recording(
                    context,
                    step,
                    event_builder,
                ).await {
                    Ok(output) => {
                        context.step_outputs.insert(step.step_id.clone(), output);
                    }
                    Err(e) => {
                        // 根据反思结果决定后续动作
                        match context.recovery_strategy {
                            RecoveryStrategy::Retry { .. } => continue,
                            RecoveryStrategy::Replan { .. } => break,
                            RecoveryStrategy::Abort { .. } => {
                                return Err(e.into());
                            }
                            _ => {}
                        }
                    }
                }
            }

            // 评估阶段
            let evaluation = self.evaluator.evaluate(context).await?;
            if evaluation.task_completed {
                return Ok(self.build_result(context));
            }

            // 检查轮次限制
            context.current_round += 1;
            if context.current_round > self.config.max_rounds {
                return Err(anyhow!("Max rounds exceeded"));
            }
        }
    }
}
```

---

## 5. 配置选项

### 5.1 配置文件

```toml
# config.toml

[context_engineering]
# 是否启用上下文工程事件
enabled = true

# 事件输出目录
output_path = "./data/context_events"

# 是否输出到文件
output_to_file = true

# 是否推送事件到客户端
push_to_client = true

# 是否包含完整工具输出（可能很大）
include_full_output = true

# 最大输出大小限制（字节）
max_output_size = 10240
```

### 5.2 环境变量

```bash
# 启用上下文工程事件
export CONTEXT_ENGINEERING_ENABLED=true

# 输出目录
export CONTEXT_ENGINEERING_OUTPUT_PATH=./data/context_events

# 输出到文件
export CONTEXT_ENGINEERING_OUTPUT_TO_FILE=true
```

---

## 6. 输出示例

### 6.1 文件输出示例

```markdown
# 上下文工程事件报告

**任务描述**: 查询设备状态并生成监控报告
**生成时间**: 2026-01-05T10:30:00+08:00

---

## 成功步骤

### 1. 获取设备列表

- **步骤ID**: step_1
- **工具**: device_query
- **依赖**: []
- **参数**: ```json
{
  "filter": "active",
  "limit": 100
}
```
- **输出**: ```json
{
  "devices": [
    {"id": "dev_001", "name": "传感器A", "status": "online"},
    {"id": "dev_002", "name": "传感器B", "status": "online"}
  ],
  "total": 2
}
```
- **提取字段**:
  - `devices[0].id`: dev_001
  - `devices[1].id`: dev_002

### 2. 查询设备详情

- **步骤ID**: step_2
- **工具**: device_detail
- **依赖**: ["step_1"]
- **参数**: ```json
{
  "device_id": "dev_001"
}
```
- **输出**: ```json
{
  "device_id": "dev_001",
  "metrics": {
    "temperature": 25.5,
    "humidity": 60
  }
}
```

## 失败步骤

### 1. 发送监控报告 (失败)

- **步骤ID**: step_3
- **工具**: send_report
- **依赖**: ["step_2"]
- **参数**: ```json
{
  "recipient": "admin@example.com",
  "content": "..."
}
```
- **错误**: SMTP连接超时

**反思与行动**:
## 失败原因分析
邮件服务器连接超时，可能是网络问题或服务器暂时不可用。

## 根因定位
外部服务依赖问题，非代码逻辑错误。

## 恢复策略
策略: 重试
原因: 临时性网络问题，重试可能成功
参数修改:
  - timeout: 30000 -> 60000
```

---

## 7. 自我验证用途

### 7.1 LLM自检提示词

上下文工程事件可用于LLM的自我验证：

```rust
const SELF_VERIFICATION_PROMPT: &str = r#"
请基于以下执行历史，验证任务是否正确完成：

## 任务描述
{task_description}

## 执行历史
{context_engineering_event}

请回答以下问题：
1. 所有必要的步骤是否都已执行？
2. 步骤之间的数据传递是否正确？
3. 是否有遗漏的操作？
4. 最终结果是否满足任务要求？

如果发现问题，请指出具体步骤和改进建议。
"#;
```

### 7.2 验证流程

```rust
impl Orchestrator {
    /// 使用上下文工程事件进行自我验证
    pub async fn self_verify(
        &self,
        context: &ExecutionContext,
        event: &ContextEngineeringEvent,
    ) -> Result<VerificationResult> {
        // 构建验证提示词
        let prompt = SELF_VERIFICATION_PROMPT
            .replace("{task_description}", &context.task_description)
            .replace("{context_engineering_event}", &self.format_event_for_llm(event));

        // 调用LLM进行验证
        let response = self.llm_client.generate(&prompt).await?;

        // 解析验证结果
        self.parse_verification_result(&response)
    }

    /// 格式化事件供LLM理解
    fn format_event_for_llm(&self, event: &ContextEngineeringEvent) -> String {
        let mut output = String::new();

        output.push_str("### 成功执行的步骤\n");
        for step in &event.successful_steps {
            output.push_str(&format!(
                "- {} (工具: {}): 输入={}, 输出={}\n",
                step.step_name,
                step.tool_id,
                serde_json::to_string(&step.tool_parameters).unwrap_or_default(),
                serde_json::to_string(&step.tool_output).unwrap_or_default()
            ));
        }

        output.push_str("\n### 失败的步骤\n");
        for step in &event.failed_steps {
            output.push_str(&format!(
                "- {} (工具: {}): 错误={}, 反思={}\n",
                step.step_name,
                step.tool_id,
                step.error_message,
                step.reflection_and_action
            ));
        }

        output
    }
}
```

---

## 8. 迁移实现清单

### 8.1 数据结构

- [ ] 定义Proto消息（context_engineering_event.proto）
- [ ] 实现 `SuccessfulStepData` 结构
- [ ] 实现 `FailedStepData` 结构
- [ ] 实现 `ContextEngineeringEvent` 结构

### 8.2 构建器实现

- [ ] 实现 `ContextEngineeringEventBuilder`
- [ ] 实现 `record_successful_step` 方法
- [ ] 实现 `record_failed_step` 方法
- [ ] 实现字段提取逻辑
- [ ] 实现反思格式化
- [ ] 实现 `build` 和 `build_and_save` 方法

### 8.3 集成实现

- [ ] 在Executor中集成记录逻辑
- [ ] 在Orchestrator中集成构建器
- [ ] 实现文件输出功能
- [ ] 实现事件推送功能

### 8.4 自我验证

- [ ] 实现验证提示词模板
- [ ] 实现 `self_verify` 方法
- [ ] 实现验证结果解析

---

## 9. 相关文档

- [03-核心模块实现详解](./03-核心模块实现详解.md) - Executor实现
- [04-数据流转与参数解析机制](./04-数据流转与参数解析机制.md) - 数据传递机制
- [06-反思与重规划机制](./06-反思与重规划机制.md) - 反思系统实现
- [08-API与服务接口](./08-API与服务接口.md) - 事件推送接口

---

**文档维护者**: Task Orchestration Team
**最后更新**: 2026-01-05
