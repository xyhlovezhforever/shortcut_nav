# AI报告生成器与消息格式化

> **文档版本**: v1.0
> **创建日期**: 2026-01-05
> **适用场景**: 用户友好消息生成与响应模式格式化

---

## 1. 模块概述

本项目实现了完整的消息格式化系统，包含两个核心模块：

| 模块 | 文件 | 职责 |
|------|------|------|
| AIReporter | `src/ai_reporter.rs` | 两层提示词架构，生成用户友好消息 |
| MessageFormatter | `src/message_formatter.rs` | 响应模式格式化，开发者/用户模式切换 |

---

## 2. AIReporter - 两层提示词架构

### 2.1 设计理念

AIReporter采用**两层提示词架构**：

```
┌─────────────────────────────────────────────────────────────┐
│                    第一层：模块特定模板                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ 工具选择模板 │  │ 任务规划模板 │  │ 步骤完成模板 │          │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘          │
│         │                │                │                  │
│         └────────────────┼────────────────┘                  │
│                          ▼                                   │
│              ┌───────────────────────┐                       │
│              │  第二层：统一输出风格  │                       │
│              │  OUTPUT_STYLE_TEMPLATE │                      │
│              └───────────────────────┘                       │
│                          │                                   │
│                          ▼                                   │
│              ┌───────────────────────┐                       │
│              │   用户友好的最终输出   │                       │
│              └───────────────────────┘                       │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心结构

```rust
/// AI报告生成器
/// 负责将技术性内容转换为用户友好的消息
pub struct AIReporter {
    /// LLM客户端，用于调用AI生成消息
    llm_client: UnifiedLlmClient,
}

impl AIReporter {
    /// 创建新的AIReporter实例
    pub fn new(llm_client: UnifiedLlmClient) -> Self {
        Self { llm_client }
    }
}
```

### 2.3 两层生成方法

```rust
impl AIReporter {
    /// 两层生成：先使用模块模板，再应用统一风格
    async fn generate_with_style(
        &self,
        content_prompt: &str,  // 第一层：模块特定提示词
        max_length: usize      // 输出长度限制
    ) -> Result<String> {
        // 第一层：调用模块特定模板生成原始内容
        let raw_content = self.call_llm_direct(content_prompt).await?;

        // 第二层：应用统一输出风格模板
        let style_prompt = OUTPUT_STYLE_TEMPLATE
            .replace("{content}", &raw_content)
            .replace("{max_length}", &max_length.to_string());

        // 返回经过风格化的最终输出
        self.call_llm_direct(&style_prompt).await
    }

    /// 直接调用LLM（无风格层）
    async fn call_llm_direct(&self, prompt: &str) -> Result<String> {
        self.llm_client.generate(prompt).await
    }
}
```

### 2.4 统一输出风格模板

```rust
/// 第二层风格模板：确保所有输出具有一致的用户友好风格
const OUTPUT_STYLE_TEMPLATE: &str = r#"
请将以下内容转换为用户友好的消息格式：

原始内容：
{content}

要求：
1. 使用简洁明了的语言
2. 避免技术术语，必要时提供解释
3. 保持积极友好的语气
4. 长度控制在{max_length}字以内
5. 使用适当的表情符号增加亲和力

输出格式：直接输出转换后的消息，不需要额外说明。
"#;
```

### 2.5 场景特定消息生成

#### 工具选择消息

```rust
impl AIReporter {
    /// 生成工具选择消息
    /// 当系统选择了执行工具时，生成用户友好的说明
    pub async fn generate_tool_selection_message(
        &self,
        tool_id: &str,
        tool_name: &str,
        reason: &str,
    ) -> Result<String> {
        let prompt = format!(
            r#"生成一条工具选择通知消息：

工具ID: {}
工具名称: {}
选择原因: {}

请用简洁友好的方式告知用户系统正在使用什么工具以及为什么。"#,
            tool_id, tool_name, reason
        );

        self.generate_with_style(&prompt, 100).await
    }
}
```

#### 任务规划消息

```rust
impl AIReporter {
    /// 生成任务规划消息
    /// 当系统完成任务规划时，生成执行计划摘要
    pub async fn generate_task_planning_message(
        &self,
        task_description: &str,
        steps_count: usize,
        estimated_complexity: &str,
    ) -> Result<String> {
        let prompt = format!(
            r#"生成一条任务规划完成通知：

任务描述: {}
规划步骤数: {}
预估复杂度: {}

请用友好的方式告知用户规划已完成，并简要说明将要执行的步骤。"#,
            task_description, steps_count, estimated_complexity
        );

        self.generate_with_style(&prompt, 150).await
    }
}
```

#### 步骤完成消息

```rust
impl AIReporter {
    /// 生成步骤完成消息
    /// 当单个步骤执行完成时，生成进度通知
    pub async fn generate_step_completion_message(
        &self,
        step_name: &str,
        result_summary: &str,
        progress: (usize, usize),  // (当前步骤, 总步骤数)
    ) -> Result<String> {
        let prompt = format!(
            r#"生成一条步骤完成通知：

步骤名称: {}
执行结果摘要: {}
进度: {}/{}

请用友好的方式告知用户步骤已完成及当前进度。"#,
            step_name, result_summary, progress.0, progress.1
        );

        self.generate_with_style(&prompt, 120).await
    }
}
```

#### 评估消息

```rust
impl AIReporter {
    /// 生成评估消息
    /// 当系统评估执行结果时，生成评估摘要
    pub async fn generate_evaluation_message(
        &self,
        evaluation_result: &str,
        success: bool,
        suggestions: Option<&str>,
    ) -> Result<String> {
        let prompt = format!(
            r#"生成一条评估结果通知：

评估结果: {}
是否成功: {}
改进建议: {}

请用友好的方式告知用户评估结果。"#,
            evaluation_result,
            if success { "成功" } else { "需要改进" },
            suggestions.unwrap_or("无")
        );

        self.generate_with_style(&prompt, 150).await
    }
}
```

#### 任务完成消息

```rust
impl AIReporter {
    /// 生成任务完成消息
    /// 当整个任务完成时，生成总结性消息
    pub async fn generate_task_completion_message(
        &self,
        task_description: &str,
        total_steps: usize,
        total_time_ms: u64,
        final_result: &str,
    ) -> Result<String> {
        let prompt = format!(
            r#"生成一条任务完成通知：

任务描述: {}
总步骤数: {}
总耗时: {}ms
最终结果: {}

请用热情友好的方式祝贺用户任务已完成，并简要总结成果。"#,
            task_description, total_steps, total_time_ms, final_result
        );

        self.generate_with_style(&prompt, 200).await
    }
}
```

---

## 3. MessageFormatter - 响应模式格式化

### 3.1 设计理念

MessageFormatter实现**双模式格式化**：

```
┌─────────────────────────────────────────────────────────────┐
│                      ResponseMode                            │
│                                                              │
│   ┌─────────────────┐         ┌─────────────────┐           │
│   │  Developer模式   │         │    User模式     │           │
│   │                 │         │                 │           │
│   │ • 技术性输出     │         │ • 友好性输出     │           │
│   │ • 完整日志       │         │ • 精简信息       │           │
│   │ • 调试信息       │         │ • AI润色        │           │
│   │ • 结构化数据     │         │ • 自然语言       │           │
│   └─────────────────┘         └─────────────────┘           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心结构

```rust
/// 响应模式枚举
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ResponseMode {
    /// 开发者模式：技术性输出，包含完整日志和调试信息
    Developer,
    /// 用户模式：友好性输出，使用AI润色
    User,
}

/// 消息格式化器
pub struct MessageFormatter {
    /// 当前响应模式
    mode: ResponseMode,
    /// LLM客户端（User模式下用于AI润色）
    llm_client: Option<Arc<UnifiedLlmClient>>,
}

impl MessageFormatter {
    /// 创建开发者模式格式化器
    pub fn developer() -> Self {
        Self {
            mode: ResponseMode::Developer,
            llm_client: None,
        }
    }

    /// 创建用户模式格式化器
    pub fn user(llm_client: Arc<UnifiedLlmClient>) -> Self {
        Self {
            mode: ResponseMode::User,
            llm_client: Some(llm_client),
        }
    }
}
```

### 3.3 AI润色机制

```rust
impl MessageFormatter {
    /// AI润色消息
    /// 仅在User模式下生效
    async fn polish_message(
        &self,
        raw_message: &str,
        message_type: &str
    ) -> String {
        // Developer模式直接返回原始消息
        if self.mode != ResponseMode::User {
            return raw_message.to_string();
        }

        // 没有LLM客户端时返回原始消息
        let client = match &self.llm_client {
            Some(c) => c,
            None => return raw_message.to_string(),
        };

        // 根据消息类型选择润色模板
        let polish_template = match message_type {
            "task_status" => MESSAGE_POLISH_TASK_STATUS,
            "llm_call" => MESSAGE_POLISH_LLM_CALL,
            "tool_selection" => MESSAGE_POLISH_TOOL_SELECTION,
            "plan_details" => MESSAGE_POLISH_PLAN_DETAILS,
            "step_progress" => MESSAGE_POLISH_STEP_PROGRESS,
            "evaluation" => MESSAGE_POLISH_EVALUATION,
            "reflection" => MESSAGE_POLISH_REFLECTION,
            _ => MESSAGE_POLISH_GENERIC,
        };

        // 构建润色提示词
        let prompt = polish_template.replace("{message}", raw_message);

        // 调用LLM进行润色
        match client.generate(&prompt).await {
            Ok(polished) => polished,
            Err(_) => raw_message.to_string(), // 失败时返回原始消息
        }
    }
}
```

### 3.4 消息类型润色模板

#### 任务状态润色

```rust
const MESSAGE_POLISH_TASK_STATUS: &str = r#"
请将以下任务状态信息转换为用户友好的消息：

原始信息：
{message}

要求：
1. 使用自然流畅的语言
2. 突出关键状态信息
3. 避免技术细节
4. 保持简洁（50字以内）

直接输出润色后的消息：
"#;
```

#### LLM调用润色

```rust
const MESSAGE_POLISH_LLM_CALL: &str = r#"
请将以下LLM调用信息转换为用户友好的消息：

原始信息：
{message}

要求：
1. 用"正在思考"、"正在分析"等友好说法
2. 不暴露技术实现细节
3. 保持简洁（30字以内）

直接输出润色后的消息：
"#;
```

#### 工具选择润色

```rust
const MESSAGE_POLISH_TOOL_SELECTION: &str = r#"
请将以下工具选择信息转换为用户友好的消息：

原始信息：
{message}

要求：
1. 将工具ID转换为功能描述
2. 说明正在执行什么操作
3. 保持简洁（40字以内）

直接输出润色后的消息：
"#;
```

#### 计划详情润色

```rust
const MESSAGE_POLISH_PLAN_DETAILS: &str = r#"
请将以下执行计划信息转换为用户友好的消息：

原始信息：
{message}

要求：
1. 将技术步骤转换为通俗描述
2. 使用列表形式展示
3. 突出主要操作
4. 长度适中（100字以内）

直接输出润色后的消息：
"#;
```

#### 步骤进度润色

```rust
const MESSAGE_POLISH_STEP_PROGRESS: &str = r#"
请将以下步骤执行进度转换为用户友好的消息：

原始信息：
{message}

要求：
1. 清晰展示当前进度
2. 简要说明当前步骤
3. 使用鼓励性语言
4. 保持简洁（40字以内）

直接输出润色后的消息：
"#;
```

#### 评估结果润色

```rust
const MESSAGE_POLISH_EVALUATION: &str = r#"
请将以下评估结果转换为用户友好的消息：

原始信息：
{message}

要求：
1. 使用积极正面的语言
2. 突出成功点或改进方向
3. 避免过于技术化的表述
4. 保持简洁（60字以内）

直接输出润色后的消息：
"#;
```

#### 反思内容润色

```rust
const MESSAGE_POLISH_REFLECTION: &str = r#"
请将以下反思分析转换为用户友好的消息：

原始信息：
{message}

要求：
1. 将技术分析转换为通俗解释
2. 说明问题原因和解决方案
3. 使用安慰性语言
4. 保持简洁（80字以内）

直接输出润色后的消息：
"#;
```

### 3.5 格式化方法

#### 任务状态格式化

```rust
impl MessageFormatter {
    /// 格式化任务状态
    pub async fn format_task_status(
        &self,
        task_id: &str,
        status: &str,
        progress: Option<(usize, usize)>,
    ) -> String {
        let raw = match self.mode {
            ResponseMode::Developer => {
                // 开发者模式：技术性输出
                format!(
                    "[TaskStatus] task_id={}, status={}, progress={:?}",
                    task_id, status, progress
                )
            }
            ResponseMode::User => {
                // 用户模式：简化输出
                match progress {
                    Some((current, total)) => {
                        format!("任务进度: {}/{} - {}", current, total, status)
                    }
                    None => format!("任务状态: {}", status),
                }
            }
        };

        self.polish_message(&raw, "task_status").await
    }
}
```

#### LLM调用格式化

```rust
impl MessageFormatter {
    /// 格式化LLM调用信息
    pub async fn format_llm_call(
        &self,
        purpose: &str,
        model: &str,
        token_count: Option<usize>,
    ) -> String {
        let raw = match self.mode {
            ResponseMode::Developer => {
                format!(
                    "[LLM Call] purpose={}, model={}, tokens={:?}",
                    purpose, model, token_count
                )
            }
            ResponseMode::User => {
                format!("正在{}...", purpose)
            }
        };

        self.polish_message(&raw, "llm_call").await
    }
}
```

#### 工具选择格式化

```rust
impl MessageFormatter {
    /// 格式化工具选择信息
    pub async fn format_tool_selection(
        &self,
        tool_id: &str,
        tool_name: &str,
        parameters: &serde_json::Value,
    ) -> String {
        let raw = match self.mode {
            ResponseMode::Developer => {
                format!(
                    "[Tool Selection] tool_id={}, name={}, params={}",
                    tool_id, tool_name, parameters
                )
            }
            ResponseMode::User => {
                format!("正在使用 {} 处理...", tool_name)
            }
        };

        self.polish_message(&raw, "tool_selection").await
    }
}
```

#### 计划详情格式化

```rust
impl MessageFormatter {
    /// 格式化执行计划详情
    pub async fn format_plan_details(
        &self,
        steps: &[PlanStep],
        total_estimated_time: Option<u64>,
    ) -> String {
        let raw = match self.mode {
            ResponseMode::Developer => {
                let step_list: Vec<String> = steps.iter()
                    .enumerate()
                    .map(|(i, s)| format!("  {}. {} (tool: {})", i + 1, s.name, s.tool_id))
                    .collect();
                format!(
                    "[Plan Details]\n{}\nEstimated time: {:?}ms",
                    step_list.join("\n"),
                    total_estimated_time
                )
            }
            ResponseMode::User => {
                let step_list: Vec<String> = steps.iter()
                    .enumerate()
                    .map(|(i, s)| format!("{}. {}", i + 1, s.name))
                    .collect();
                format!("执行计划：\n{}", step_list.join("\n"))
            }
        };

        self.polish_message(&raw, "plan_details").await
    }
}
```

#### 步骤进度格式化

```rust
impl MessageFormatter {
    /// 格式化步骤执行进度
    pub async fn format_step_progress(
        &self,
        step_name: &str,
        current: usize,
        total: usize,
        status: &str,
    ) -> String {
        let raw = match self.mode {
            ResponseMode::Developer => {
                format!(
                    "[Step Progress] step={}, progress={}/{}, status={}",
                    step_name, current, total, status
                )
            }
            ResponseMode::User => {
                let percentage = (current as f64 / total as f64 * 100.0) as usize;
                format!("进度 {}% - {} {}", percentage, step_name, status)
            }
        };

        self.polish_message(&raw, "step_progress").await
    }
}
```

#### 评估结果格式化

```rust
impl MessageFormatter {
    /// 格式化评估结果
    pub async fn format_evaluation(
        &self,
        success: bool,
        reason: &str,
        next_action: Option<&str>,
    ) -> String {
        let raw = match self.mode {
            ResponseMode::Developer => {
                format!(
                    "[Evaluation] success={}, reason={}, next={:?}",
                    success, reason, next_action
                )
            }
            ResponseMode::User => {
                if success {
                    "执行成功！".to_string()
                } else {
                    format!("需要调整: {}", reason)
                }
            }
        };

        self.polish_message(&raw, "evaluation").await
    }
}
```

#### 反思内容格式化

```rust
impl MessageFormatter {
    /// 格式化反思内容
    pub async fn format_reflection(
        &self,
        failure_reason: &str,
        analysis: &str,
        recovery_plan: &str,
    ) -> String {
        let raw = match self.mode {
            ResponseMode::Developer => {
                format!(
                    "[Reflection]\nFailure: {}\nAnalysis: {}\nRecovery: {}",
                    failure_reason, analysis, recovery_plan
                )
            }
            ResponseMode::User => {
                format!("遇到问题，正在分析解决方案...")
            }
        };

        self.polish_message(&raw, "reflection").await
    }
}
```

---

## 4. 与gRPC服务集成

### 4.1 事件消息格式化流程

```
┌─────────────────────────────────────────────────────────────┐
│                     gRPC Server                              │
│                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐   │
│  │ Orchestrator │───>│MessageFormatter│───>│  StreamEvent │   │
│  │   Events     │    │  (格式化)     │    │  (发送客户端) │   │
│  └──────────────┘    └──────────────┘    └──────────────┘   │
│                              │                               │
│                              ▼                               │
│                    ┌──────────────────┐                      │
│                    │   ResponseMode   │                      │
│                    │ (从请求中获取)   │                      │
│                    └──────────────────┘                      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 服务端配置

```rust
// src/grpc/server.rs

pub struct OrchestrationService {
    orchestrator: Arc<Orchestrator>,
    llm_client: Arc<UnifiedLlmClient>,
}

impl OrchestrationService {
    /// 根据请求的响应模式创建格式化器
    fn create_formatter(&self, mode: i32) -> MessageFormatter {
        match ResponseMode::from_i32(mode) {
            Some(ResponseMode::User) => {
                MessageFormatter::user(self.llm_client.clone())
            }
            _ => MessageFormatter::developer(),
        }
    }
}
```

### 4.3 事件处理示例

```rust
impl OrchestrationService {
    /// 处理任务编排请求
    async fn orchestrate_with_events(
        &self,
        request: OrchestrationRequest,
        event_tx: mpsc::Sender<StreamEvent>,
    ) -> Result<()> {
        // 创建格式化器
        let formatter = self.create_formatter(request.response_mode);

        // 发送任务开始事件
        let start_msg = formatter.format_task_status(
            &request.task_id,
            "started",
            None,
        ).await;
        event_tx.send(StreamEvent::status(start_msg)).await?;

        // 执行编排...
        let result = self.orchestrator.execute(request).await;

        // 根据结果发送完成事件
        match result {
            Ok(output) => {
                let complete_msg = formatter.format_task_status(
                    &request.task_id,
                    "completed",
                    Some((output.steps_completed, output.total_steps)),
                ).await;
                event_tx.send(StreamEvent::status(complete_msg)).await?;
            }
            Err(e) => {
                let error_msg = formatter.format_evaluation(
                    false,
                    &e.to_string(),
                    None,
                ).await;
                event_tx.send(StreamEvent::error(error_msg)).await?;
            }
        }

        Ok(())
    }
}
```

---

## 5. 配置与使用

### 5.1 响应模式配置

```toml
# config.toml

[response]
# 默认响应模式: "developer" 或 "user"
default_mode = "user"

# AI润色启用
enable_polish = true

# 润色最大重试次数
polish_max_retries = 2

# 润色超时时间(ms)
polish_timeout_ms = 3000
```

### 5.2 环境变量覆盖

```bash
# 设置默认响应模式
export RESPONSE_MODE=user

# 禁用AI润色（提高性能）
export ENABLE_POLISH=false
```

### 5.3 请求级别指定

```protobuf
// Proto定义
message OrchestrationRequest {
    string task_id = 1;
    string task_description = 2;
    // ...

    // 响应模式
    ResponseMode response_mode = 10;
}

enum ResponseMode {
    DEVELOPER = 0;
    USER = 1;
}
```

---

## 6. 性能考虑

### 6.1 AI润色开销

| 操作 | Developer模式 | User模式 |
|------|--------------|----------|
| 消息生成 | 直接返回 | LLM调用 |
| 平均延迟 | <1ms | 500-2000ms |
| Token消耗 | 0 | 50-200/消息 |

### 6.2 优化策略

```rust
impl MessageFormatter {
    /// 批量润色优化
    async fn polish_messages_batch(
        &self,
        messages: Vec<(&str, &str)>,  // (message, type)
    ) -> Vec<String> {
        if self.mode != ResponseMode::User {
            return messages.iter()
                .map(|(m, _)| m.to_string())
                .collect();
        }

        // 合并多条消息为单次LLM调用
        let combined_prompt = self.build_batch_prompt(&messages);

        match self.llm_client.as_ref().unwrap().generate(&combined_prompt).await {
            Ok(response) => self.parse_batch_response(&response),
            Err(_) => messages.iter()
                .map(|(m, _)| m.to_string())
                .collect(),
        }
    }
}
```

### 6.3 缓存机制

```rust
/// 消息润色缓存
struct PolishCache {
    cache: DashMap<String, (String, Instant)>,
    ttl: Duration,
}

impl PolishCache {
    /// 获取缓存的润色结果
    fn get(&self, raw_message: &str) -> Option<String> {
        self.cache.get(raw_message).and_then(|entry| {
            if entry.1.elapsed() < self.ttl {
                Some(entry.0.clone())
            } else {
                None
            }
        })
    }

    /// 缓存润色结果
    fn set(&self, raw_message: &str, polished: String) {
        self.cache.insert(raw_message.to_string(), (polished, Instant::now()));
    }
}
```

---

## 7. 迁移实现清单

### 7.1 AIReporter实现

- [ ] 创建 `src/ai_reporter.rs`
- [ ] 实现两层提示词架构
- [ ] 实现 `generate_with_style` 核心方法
- [ ] 实现各场景消息生成方法
- [ ] 添加单元测试

### 7.2 MessageFormatter实现

- [ ] 创建 `src/message_formatter.rs`
- [ ] 实现 `ResponseMode` 枚举
- [ ] 实现 `polish_message` AI润色方法
- [ ] 实现各类型格式化方法
- [ ] 添加润色模板常量
- [ ] 添加单元测试

### 7.3 集成实现

- [ ] 在gRPC服务中集成MessageFormatter
- [ ] 实现响应模式配置读取
- [ ] 实现请求级别模式覆盖
- [ ] 添加性能优化（缓存、批处理）

---

## 8. 相关文档

- [05-LLM交互与提示词系统](./05-LLM交互与提示词系统.md) - 提示词模板设计
- [08-API与服务接口](./08-API与服务接口.md) - gRPC服务接口定义
- [09-配置与部署指南](./09-配置与部署指南.md) - 配置文件说明

---

**文档维护者**: Task Orchestration Team
**最后更新**: 2026-01-05
