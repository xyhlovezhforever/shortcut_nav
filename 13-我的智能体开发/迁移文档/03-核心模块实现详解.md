# 03 - 核心模块实现详解

> **文档版本**: v1.0
> **创建日期**: 2026-01-05
> **迁移优先级**: ⭐⭐⭐⭐⭐ (最高)

---

## 1. 模块概览

本文档详细说明 `src/core/` 目录下各核心模块的实现逻辑。

| 模块 | 代码行数 | 核心职责 |
|------|---------|---------|
| orchestrator.rs | ~2,500行 | 编排核心，协调整个执行流程 |
| planner.rs | ~2,200行 | 任务规划，生成执行计划 |
| executor.rs | ~2,200行 | 步骤执行，调用工具服务 |
| evaluator.rs | ~600行 | 结果评估，判断执行质量 |
| reflector.rs | ~1,200行 | 失败反思，提供改进建议 |
| parameter_resolver.rs | ~1,300行 | 参数解析，处理占位符 |
| execution_context.rs | ~550行 | 执行上下文，存储中间数据 |
| parallel_executor.rs | ~900行 | 并行执行，DAG调度 |

---

## 2. Orchestrator (编排器)

### 2.1 核心职责

- 协调 Planner、Executor、Evaluator、Reflector
- 管理任务生命周期和状态转换
- 实现 Reflective Planning 循环
- 处理事件推送

### 2.2 关键结构

```rust
pub struct Orchestrator {
    planner: Arc<Planner>,
    executor: Arc<Executor>,
    evaluator: Arc<Evaluator>,
    reflector: Arc<Reflector>,
    state_manager: Arc<TaskStateManager>,
    kafka_logger: Arc<KafkaLogger>,
    event_sender: Option<Arc<dyn EventSender>>,

    // 配置
    max_reflection_rounds: u32,      // 最大反思轮次
    success_threshold: f32,          // 成功阈值
    enable_parallel_execution: bool, // 是否并行执行
}
```

### 2.3 核心方法

#### orchestrate_with_id_and_metadata (主入口)

```rust
pub async fn orchestrate_with_id_and_metadata(
    &self,
    task_id: &str,
    task_description: &str,
    metadata: HashMap<String, String>,
) -> Result<TaskResult> {
    // 1. 更新状态为 Planning
    self.state_manager.update_status(task_id, TaskStatus::Planning);

    // 2. 调用 Planner 生成执行计划
    let plan = self.planner.plan(task_description, &metadata).await?;

    // 3. 进入 Reflective Planning 循环
    let mut current_round = 0;
    loop {
        // 4. 执行计划
        self.state_manager.update_status(task_id, TaskStatus::Executing);
        let execution_result = self.execute_plan(&plan, &metadata).await;

        // 5. 评估结果
        self.state_manager.update_status(task_id, TaskStatus::Evaluating);
        let evaluation = self.evaluator.evaluate(&execution_result).await?;

        // 6. 判断是否成功
        if evaluation.score >= self.success_threshold {
            self.state_manager.update_status(task_id, TaskStatus::Completed);
            return Ok(TaskResult::success(execution_result));
        }

        // 7. 检查轮次限制
        current_round += 1;
        if current_round >= self.max_reflection_rounds {
            self.state_manager.update_status(task_id, TaskStatus::Failed);
            return Ok(TaskResult::failed("达到最大反思轮次"));
        }

        // 8. 反思并重规划
        self.state_manager.update_status(task_id, TaskStatus::Reflecting);
        let reflection = self.reflector.reflect(&execution_result, &evaluation).await?;

        // 9. 根据反思结果决定下一步
        match reflection.action {
            ReflectionAction::Replan => {
                plan = self.planner.replan(&reflection, &metadata).await?;
            }
            ReflectionAction::RetryStep(step_id) => {
                // 重试单个步骤
            }
            ReflectionAction::Abort => {
                return Ok(TaskResult::failed(&reflection.reason));
            }
        }
    }
}
```

#### EventSender Trait

```rust
/// 事件发送器 trait，用于流式推送执行事件
pub trait EventSender: Send + Sync {
    /// 发送状态更新
    fn send_status_update(&self, status: &str, message: &str);

    /// 发送工具筛选完成事件
    fn send_tool_selection_completed(
        &self,
        total_tools: usize,
        selected_tools: usize,
        selected_tool_ids: &[String],
        workflow_id: Option<&str>,
        workflow_name: Option<&str>,
    );

    /// 发送计划生成完成事件
    fn send_plan_generated(&self, plan: &ExecutionPlan);

    /// 发送步骤开始事件
    fn send_step_started(&self, step: &PlanStep);

    /// 发送步骤完成事件
    fn send_step_completed(&self, result: &StepExecutionResult);

    /// 发送任务完成事件
    fn send_task_completed(&self, result: &TaskResult);
}
```

---

## 3. Planner (规划器)

### 3.1 核心职责

- 调用LLM生成执行计划
- 实现两阶段规划（工具筛选 + 任务分解）
- 匹配标准任务流程
- 支持重新规划

### 3.2 关键结构

```rust
pub struct Planner {
    llm_client: UnifiedLlmClient,
    tool_client: UnifiedToolServiceClient,
    kafka_logger: Arc<KafkaLogger>,

    // 两阶段规划配置
    enable_two_stage_planning: bool,
    two_stage_tool_threshold: usize,

    // 事件发送器
    event_sender: Option<Arc<dyn EventSender>>,

    // 工作流管理器
    workflow_manager: Option<Arc<TaskWorkflowManager>>,
}
```

### 3.3 核心方法

#### generate_plan (生成计划)

```rust
pub async fn generate_plan(
    &self,
    task_description: &str,
    metadata: &HashMap<String, String>,
) -> Result<ExecutionPlan> {
    // 1. 获取所有可用工具
    let all_tools = self.tool_client.get_tools().await?;

    // 2. 决定是否使用两阶段规划
    let should_use_two_stage = self.enable_two_stage_planning
        && all_tools.len() >= self.two_stage_tool_threshold;

    // 3. 工具筛选 (如果启用两阶段)
    let (available_tools, task_type, workflow_id) = if should_use_two_stage {
        self.select_relevant_tools(task_description, &all_tools, metadata).await?
    } else {
        (all_tools, "通用".to_string(), None)
    };

    // 4. 获取匹配的标准流程 (如果有)
    let workflow_hint = self.get_workflow_hint(&workflow_id);

    // 5. 构建规划提示词
    let (system_prompt, user_prompt) = PlanningPromptBuilder::new()
        .build_enhanced_planning_prompt(
            task_description,
            &available_tools,
            metadata,
            workflow_hint.as_deref(),
            Some(&task_type),
        );

    // 6. 调用LLM生成计划
    let llm_response = self.llm_client.call(&system_prompt, &user_prompt).await?;

    // 7. 解析LLM响应为执行计划
    let plan = self.parse_plan_response(&llm_response)?;

    Ok(plan)
}
```

#### select_relevant_tools (工具筛选)

```rust
pub async fn select_relevant_tools(
    &self,
    task_description: &str,
    all_tools: &[ToolInfo],
    metadata: &HashMap<String, String>,
) -> Result<(Vec<ToolInfo>, String, Option<String>)> {
    // 1. 格式化工具简要信息
    let tools_summary = self.format_tools_summary(all_tools);

    // 2. 格式化工作流摘要 (如果有)
    let workflows_summary = self.workflow_manager
        .as_ref()
        .map(|wm| wm.format_workflows_summary());

    // 3. 构建工具筛选提示词
    let (system_prompt, user_prompt) = SelectionPromptBuilder::new()
        .build_tool_selection_prompt(
            task_description,
            &tools_summary,
            all_tools.len(),
            metadata,
            0.6, // 筛选阈值
            None,
        );

    // 4. 调用LLM筛选
    let llm_response = self.llm_client.call(&system_prompt, &user_prompt).await?;

    // 5. 解析响应，获取工具ID列表、任务类型、工作流ID
    let (tool_ids, task_type, workflow_id) =
        self.parse_tool_selection_response(&llm_response)?;

    // 6. 从原始列表中提取完整工具信息
    let selected_tools: Vec<ToolInfo> = all_tools
        .iter()
        .filter(|t| tool_ids.contains(&t.id))
        .cloned()
        .collect();

    // 7. 推送工具筛选完成事件
    if let Some(sender) = &self.event_sender {
        sender.send_tool_selection_completed(...);
    }

    Ok((selected_tools, task_type, workflow_id))
}
```

#### replan_task (任务重规划)

```rust
pub async fn replan_task(
    &self,
    replanning_prompt: &str,
    metadata: HashMap<String, String>,
) -> Result<ExecutionPlan> {
    // 重规划时也使用两阶段流程
    // 与 generate_plan 类似，但使用 replanning_prompt 作为输入
}
```

#### replan_single_step (单步修复)

```rust
pub async fn replan_single_step(
    &self,
    failed_step: &PlanStep,
    error_message: &str,
    available_tools: &[ToolInfo],
) -> Result<PlanStep> {
    // 单步修复不进行工具筛选
    // 直接使用传入的工具集生成替换步骤
}
```

---

## 4. Executor (执行器)

### 4.1 核心职责

- 执行计划中的每个步骤
- 调用工具服务
- 管理参数解析和数据流转
- 支持并行执行

### 4.2 关键结构

```rust
pub struct Executor {
    tool_client: UnifiedToolServiceClient,
    kafka_logger: Arc<KafkaLogger>,

    // 并行执行配置
    enable_parallel_execution: bool,
    max_concurrent_steps: usize,

    // 事件发送器
    event_sender: Option<Arc<dyn EventSender>>,
}
```

### 4.3 核心方法

#### execute_plan_with_context (执行计划)

```rust
pub async fn execute_plan_with_context(
    &self,
    plan: &ExecutionPlan,
    context: &ExecutionContext,
    available_tools: &[ToolInfo],
) -> Result<Vec<StepExecutionResult>> {
    let mut results = Vec::new();

    // 判断是否使用并行执行
    if self.enable_parallel_execution && plan.steps.len() > 1 {
        // 使用 ParallelExecutor 并行执行
        results = self.parallel_executor
            .execute_parallel(plan, context, available_tools)
            .await?;
    } else {
        // 顺序执行
        for step in &plan.steps {
            let result = self.execute_single_step(step, context, available_tools).await?;

            // 保存结果到上下文
            context.set_step_result(result.clone());

            // 同步输出到 runtime_metadata
            self.sync_step_output_to_metadata(&result, context, available_tools);

            results.push(result);

            // 如果步骤失败，根据配置决定是否继续
            if !result.is_success {
                break;
            }
        }
    }

    Ok(results)
}
```

#### execute_single_step (执行单步)

```rust
pub async fn execute_single_step(
    &self,
    step: &PlanStep,
    context: &ExecutionContext,
    available_tools: &[ToolInfo],
) -> Result<StepExecutionResult> {
    let start_time = std::time::Instant::now();

    // 1. 查找工具定义
    let tool_info = available_tools
        .iter()
        .find(|t| t.id == step.tool)
        .ok_or_else(|| Error::ToolNotFound(step.tool.clone()))?;

    // 2. 解析参数 (处理占位符)
    let parameters = ParameterResolver::resolve_parameters(step, tool_info, context);

    // 3. 推送步骤开始事件
    if let Some(sender) = &self.event_sender {
        sender.send_step_started(step);
    }

    // 4. 调用工具服务
    let tool_result = self.tool_client
        .execute_tool(&step.tool, &parameters)
        .await;

    // 5. 构建执行结果
    let result = match tool_result {
        Ok(output) => StepExecutionResult {
            step_id: step.step_id.clone(),
            step_name: step.step_name.clone(),
            tool_id: step.tool.clone(),
            output,
            is_success: true,
            error_message: None,
            duration_ms: start_time.elapsed().as_millis() as u64,
        },
        Err(e) => StepExecutionResult {
            step_id: step.step_id.clone(),
            step_name: step.step_name.clone(),
            tool_id: step.tool.clone(),
            output: String::new(),
            is_success: false,
            error_message: Some(e.to_string()),
            duration_ms: start_time.elapsed().as_millis() as u64,
        },
    };

    // 6. 推送步骤完成事件
    if let Some(sender) = &self.event_sender {
        sender.send_step_completed(&result);
    }

    Ok(result)
}
```

---

## 5. Evaluator (评估器)

### 5.1 核心职责

- 使用LLM评估执行结果
- 计算成功评分
- 判断是否需要反思

### 5.2 关键结构

```rust
pub struct Evaluator {
    llm_client: UnifiedLlmClient,
    kafka_logger: Arc<KafkaLogger>,
}
```

### 5.3 核心方法

#### evaluate (评估执行结果)

```rust
pub async fn evaluate(
    &self,
    task_description: &str,
    plan: &ExecutionPlan,
    results: &[StepExecutionResult],
    task_type: Option<&str>,
) -> Result<EvaluationResult> {
    // 1. 构建评估提示词
    let (system_prompt, user_prompt) = EvaluationPromptBuilder::new()
        .build_evaluation_prompt(
            task_description,
            &self.format_plan(plan),
            &self.format_results(results),
            task_type,
        );

    // 2. 调用LLM评估
    let llm_response = self.llm_client.call(&system_prompt, &user_prompt).await?;

    // 3. 解析评估结果
    let evaluation = self.parse_evaluation_response(&llm_response)?;

    Ok(evaluation)
}
```

### 5.4 评估结果结构

```rust
pub struct EvaluationResult {
    pub score: f32,                // 综合评分 (0-100)
    pub completeness: f32,         // 完整性评分
    pub correctness: f32,          // 正确性评分
    pub efficiency: f32,           // 效率评分
    pub reliability: f32,          // 可靠性评分
    pub is_success: bool,          // 是否成功
    pub needs_reflection: bool,    // 是否需要反思
    pub summary: String,           // 评估摘要
    pub improvements: Vec<String>, // 改进建议
}
```

---

## 6. Reflector (反思器)

### 6.1 核心职责

- 分析步骤失败原因
- 分类失败类型
- 提供改进建议
- 决定后续动作

### 6.2 关键结构

```rust
pub struct Reflector {
    llm_client: UnifiedLlmClient,
    kafka_logger: Arc<KafkaLogger>,
}
```

### 6.3 核心方法

#### reflect_on_step (单步反思)

```rust
pub async fn reflect_on_step(
    &self,
    step: &PlanStep,
    result: &StepExecutionResult,
    context: &ReflectionContext,
    task_type: Option<&str>,
) -> Result<StepReflection> {
    // 1. 构建反思提示词
    let (system_prompt, user_prompt) = ReflectionPromptBuilder::new()
        .build_reflection_prompt(
            &context.task_description,
            step,
            result,
            task_type,
        );

    // 2. 调用LLM反思
    let llm_response = self.llm_client.call(&system_prompt, &user_prompt).await?;

    // 3. 解析反思结果
    let reflection = self.parse_reflection_response(&llm_response)?;

    Ok(reflection)
}
```

### 6.4 反思结果结构

```rust
pub struct StepReflection {
    pub root_cause_category: RootCauseCategory,  // 根本原因分类
    pub root_cause: String,                       // 具体原因
    pub is_recoverable: bool,                     // 是否可恢复
    pub confidence: f32,                          // 置信度
    pub suggested_action: ReflectionAction,       // 建议动作
    pub adjusted_parameters: Option<HashMap<String, String>>, // 调整后参数
    pub alternative_tool_id: Option<String>,      // 备选工具ID
    pub improvement_suggestions: Vec<String>,     // 改进建议
}

pub enum RootCauseCategory {
    ParameterError,      // 参数错误
    ToolError,           // 工具错误
    DependencyError,     // 依赖错误
    DecompositionError,  // 分解错误
    ExternalError,       // 外部错误
    Unknown,             // 未知错误
}

pub enum ReflectionAction {
    RetryWithAdjustedParams,  // 调整参数重试
    RetryWithAlternativeTool, // 使用备选工具
    RepairSingleStep,         // 修复单个步骤
    ReplanTask,               // 重新规划任务
    Abort,                    // 中止任务
}
```

---

## 7. ParameterResolver (参数解析器)

### 7.1 核心职责

- 解析步骤参数JSON
- 处理各种占位符格式
- 从ExecutionContext提取实际值

### 7.2 支持的占位符格式

| 格式 | 示例 | 说明 |
|------|------|------|
| 三重大括号 | `{{{step_1.outputs.id}}}` | Handlebars风格 |
| 双大括号 | `{{step_1.outputs.id}}` | 标准格式 |
| output别名 | `{{step_1.output.id}}` | 兼容格式 |
| 简化格式 | `{{step_1.id}}` | 直接字段引用 |
| 模板格式 | `${step_1.output.id}` | 模板占位符 |

### 7.3 核心方法

#### resolve_parameters

```rust
pub fn resolve_parameters(
    step: &PlanStep,
    tool_info: &ToolInfo,
    context: &ExecutionContext,
) -> HashMap<String, String> {
    let mut parameters = HashMap::new();

    // 1. 解析步骤参数JSON
    if let Ok(Value::Object(params)) = serde_json::from_str(&step.parameters) {
        for (key, value) in params {
            // 2. 转换值为字符串
            let value_str = Self::json_value_to_string(&value);

            // 3. 处理占位符
            let resolved = Self::process_parameter_value(&value_str, context);

            parameters.insert(key, resolved);
        }
    }

    parameters
}
```

#### process_parameter_value

```rust
fn process_parameter_value(value: &str, context: &ExecutionContext) -> String {
    // 1. 处理三重大括号 {{{...}}}
    if let Some(content) = value.strip_prefix("{{{").and_then(|s| s.strip_suffix("}}}")) {
        return Self::resolve_placeholder(content, context);
    }

    // 2. 处理双大括号 {{...}}
    if let Some(content) = value.strip_prefix("{{").and_then(|s| s.strip_suffix("}}")) {
        return Self::resolve_placeholder(content, context);
    }

    // 3. 处理模板格式 ${...}
    if let Some(content) = value.strip_prefix("${").and_then(|s| s.strip_suffix("}")) {
        return Self::resolve_placeholder(content, context);
    }

    // 4. 普通值直接返回
    value.to_string()
}

fn resolve_placeholder(content: &str, context: &ExecutionContext) -> String {
    // 尝试解析路径: step_id.outputs.field 或 step_id.field

    // 1. 尝试从步骤结果中提取
    if content.contains(".outputs.") || content.contains(".output.") {
        if let Some(value) = Self::extract_from_step_output(content, context) {
            return value;
        }
    }

    // 2. 尝试从 metadata 中查找
    if let Some(value) = context.get_all_metadata().get(content) {
        return value.clone();
    }

    // 3. 尝试从 runtime_metadata 直接查找字段名
    let field_name = content.split('.').last().unwrap_or(content);
    if let Some(value) = context.get_runtime_metadata().get(field_name) {
        return value.clone();
    }

    // 4. 返回原始占位符（未能解析）
    format!("{{{{{}}}}}", content)
}
```

---

## 8. ExecutionContext (执行上下文)

### 8.1 核心职责

- 存储三层数据（initial_metadata、runtime_metadata、step_results）
- 提供数据查询接口
- 实现步骤输出到metadata的同步

### 8.2 关键结构

```rust
pub struct ExecutionContext {
    initial_metadata: Arc<RwLock<HashMap<String, String>>>,
    runtime_metadata: Arc<RwLock<HashMap<String, String>>>,
    step_results: Arc<RwLock<HashMap<String, StepExecutionResult>>>,
    plan_id: Arc<RwLock<String>>,
}
```

### 8.3 核心方法

```rust
impl ExecutionContext {
    /// 创建新的执行上下文
    pub fn new(plan_id: String) -> Self {
        Self {
            initial_metadata: Arc::new(RwLock::new(HashMap::new())),
            runtime_metadata: Arc::new(RwLock::new(HashMap::new())),
            step_results: Arc::new(RwLock::new(HashMap::new())),
            plan_id: Arc::new(RwLock::new(plan_id)),
        }
    }

    /// 初始化全局元数据
    pub fn init_metadata(&self, metadata: HashMap<String, String>) {
        let mut meta = self.initial_metadata.write().unwrap();
        meta.clear();
        meta.extend(metadata);
    }

    /// 获取所有可用元数据 (runtime优先)
    pub fn get_all_metadata(&self) -> HashMap<String, String> {
        let mut combined = HashMap::new();

        // 先加载 initial
        combined.extend(self.initial_metadata.read().unwrap().clone());

        // 再加载 runtime (覆盖同名字段)
        combined.extend(self.runtime_metadata.read().unwrap().clone());

        combined
    }

    /// 保存步骤结果
    pub fn set_step_result(&self, result: StepExecutionResult) {
        let mut results = self.step_results.write().unwrap();
        results.insert(result.step_id.clone(), result);
    }

    /// 获取步骤结果
    pub fn get_step_result(&self, step_id: &str) -> Option<StepExecutionResult> {
        self.step_results.read().unwrap().get(step_id).cloned()
    }

    /// 同步步骤输出到 runtime_metadata
    pub fn sync_step_output_to_runtime_metadata(
        &self,
        step_id: &str,
        output_param_names: &[String],
    ) -> Result<usize, String> {
        // 1. 获取步骤结果
        let result = self.get_step_result(step_id)?;

        // 2. 解析输出为JSON
        let output_json: Value = serde_json::from_str(&result.output)?;

        // 3. 提取指定字段到 runtime_metadata
        let mut count = 0;
        let mut runtime = self.runtime_metadata.write().unwrap();

        if let Value::Object(obj) = output_json {
            for field in output_param_names {
                if let Some(value) = obj.get(field) {
                    let value_str = match value {
                        Value::String(s) => s.clone(),
                        _ => serde_json::to_string(value)?,
                    };

                    // 存储两种格式的键
                    runtime.insert(field.clone(), value_str.clone());
                    runtime.insert(format!("{}_{}", step_id, field), value_str);

                    count += 1;
                }
            }
        }

        Ok(count)
    }

    /// 清理上下文 (重规划时调用)
    /// 注意: 保留 step_results 和 runtime_metadata
    pub fn clear(&self) {
        // 不清除历史数据，供重规划使用
        info!("执行上下文重置：保留已有的步骤结果和运行时元数据");
    }
}
```

---

## 9. ParallelExecutor (并行执行器)

### 9.1 核心职责

- 分析步骤间依赖关系（DAG）
- 拓扑排序确定执行顺序
- 并行执行无依赖步骤

### 9.2 关键结构

```rust
pub struct ParallelExecutor {
    tool_client: UnifiedToolServiceClient,
    max_concurrent: usize,
    event_sender: Option<Arc<dyn EventSender>>,
}
```

### 9.3 核心方法

#### execute_parallel

```rust
pub async fn execute_parallel(
    &self,
    plan: &ExecutionPlan,
    context: &ExecutionContext,
    available_tools: &[ToolInfo],
) -> Result<Vec<StepExecutionResult>> {
    // 1. 构建依赖图
    let dependency_graph = self.build_dependency_graph(&plan.steps);

    // 2. 拓扑排序，获取执行层次
    let execution_layers = self.topological_sort(&dependency_graph)?;

    // 3. 按层次执行
    let mut all_results = Vec::new();

    for layer in execution_layers {
        // 4. 同一层的步骤并行执行
        let handles: Vec<_> = layer
            .iter()
            .map(|step| {
                let step = step.clone();
                let context = context.clone();
                let tools = available_tools.to_vec();

                tokio::spawn(async move {
                    self.execute_single_step(&step, &context, &tools).await
                })
            })
            .collect();

        // 5. 等待所有并行步骤完成
        let layer_results = futures::future::join_all(handles).await;

        // 6. 收集结果并同步到上下文
        for result in layer_results {
            let result = result??;
            context.set_step_result(result.clone());
            all_results.push(result);
        }
    }

    Ok(all_results)
}
```

#### build_dependency_graph

```rust
fn build_dependency_graph(&self, steps: &[PlanStep]) -> HashMap<String, Vec<String>> {
    let mut graph = HashMap::new();

    for step in steps {
        graph.insert(step.step_id.clone(), step.depends_on.clone());
    }

    graph
}
```

#### topological_sort

```rust
fn topological_sort(
    &self,
    graph: &HashMap<String, Vec<String>>,
) -> Result<Vec<Vec<PlanStep>>> {
    let mut layers = Vec::new();
    let mut completed = HashSet::new();
    let mut remaining: HashSet<_> = graph.keys().cloned().collect();

    while !remaining.is_empty() {
        // 找出所有依赖都已完成的步骤
        let ready: Vec<_> = remaining
            .iter()
            .filter(|step_id| {
                graph.get(*step_id)
                    .map(|deps| deps.iter().all(|d| completed.contains(d)))
                    .unwrap_or(true)
            })
            .cloned()
            .collect();

        if ready.is_empty() {
            return Err(Error::CircularDependency);
        }

        // 添加到当前层
        layers.push(ready.clone());

        // 更新状态
        for step_id in ready {
            completed.insert(step_id.clone());
            remaining.remove(&step_id);
        }
    }

    Ok(layers)
}
```

---

## 10. 迁移实现检查项

### 10.1 Orchestrator
- [ ] 实现 Reflective Planning 主循环
- [ ] 状态管理集成
- [ ] EventSender trait 定义
- [ ] 轮次控制和超时处理

### 10.2 Planner
- [ ] 两阶段规划实现
- [ ] 工具筛选逻辑
- [ ] 流程匹配机制
- [ ] 计划解析逻辑

### 10.3 Executor
- [ ] 单步执行实现
- [ ] 参数解析集成
- [ ] 数据同步逻辑
- [ ] 并行执行支持

### 10.4 Evaluator
- [ ] 评估提示词构建
- [ ] 评分解析逻辑
- [ ] 四维度评估

### 10.5 Reflector
- [ ] 反思提示词构建
- [ ] 失败分类逻辑
- [ ] 动作建议生成

### 10.6 ParameterResolver
- [ ] 多格式占位符支持
- [ ] 嵌套JSON路径解析
- [ ] metadata优先级处理

### 10.7 ExecutionContext
- [ ] 三层数据存储
- [ ] 线程安全访问
- [ ] 数据同步方法

### 10.8 ParallelExecutor
- [ ] DAG构建
- [ ] 拓扑排序
- [ ] 并发控制

---

## 下一步

阅读 [04-数据流转与参数解析机制.md](./04-数据流转与参数解析机制.md) 了解数据流转的详细机制。
