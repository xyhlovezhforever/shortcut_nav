# 服务发现与注册

> **文档版本**: v1.0
> **创建日期**: 2026-01-05
> **适用场景**: Consul服务注册、发现与负载均衡

---

## 1. 功能概述

Consul服务发现与注册模块提供微服务架构下的**服务治理能力**：

- **服务注册**：将服务实例注册到Consul，支持健康检查
- **服务发现**：从Consul获取可用服务实例列表
- **负载均衡**：支持多种负载均衡策略（轮询、随机、粘性）
- **优雅注销**：服务停止时自动从Consul注销

```
┌────────────────────────────────────────��────────────────────────┐
│                    服务注册与发现流程                            │
│                                                                  │
│  ┌──────────────┐                    ┌──────────────┐           │
│  │ Task Service │                    │ Tool Service │           │
│  │   (本服务)   │                    │   (远程)     │           │
│  └──────┬───────┘                    └──────┬───────┘           │
│         │                                   │                    │
│         │ 注册                              │ 注册               │
│         ▼                                   ▼                    │
│  ┌─────────────────────────────────────────────────┐            │
│  │                    Consul                        │            │
│  │  ┌─────────────────────────────────────────┐    │            │
│  │  │         服务注册表                       │    │            │
│  │  │  • task-orchestration-service           │    │            │
│  │  │  • tool-service                          │    │            │
│  │  │  • database-service                      │    │            │
│  │  └─────────────────────────────────────────┘    │            │
│  └───────────────────────┬─────────────────────────┘            │
│                          │                                       │
│                          │ 发现                                  │
│                          ▼                                       │
│  ┌─────────────────────────────────────────────────┐            │
│  │              ServiceDiscovery                    │            │
│  │  ┌─────────────────────────────────────────┐    │            │
│  │  │         负载均衡策略                     │    │            │
│  │  │  • RoundRobin (轮询)                    │    │            │
│  │  │  • Random (随机)                        │    │            │
│  │  │  • Sticky (粘性)                        │    │            │
│  │  └─────────────────────────────────────────┘    │            │
│  └─────────────────────────────────────────────────┘            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. ConsulRegistry - 服务注册器

### 2.1 配置结构

```rust
/// Consul 配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsulConfig {
    /// 是否启用 Consul
    pub enabled: bool,

    /// Consul 地址
    pub host: String,

    /// Consul 端口
    pub port: u16,

    /// 服务名称
    pub service_name: String,

    /// 服务 ID（唯一标识）
    pub service_id: String,

    /// 服务地址（本服务的地址）
    pub service_host: String,

    /// 服务端口（本服务的端口）
    pub service_port: u16,

    /// 健康检查间隔（秒）
    pub health_check_interval: u64,

    /// 健康检查超时（秒）
    pub health_check_timeout: u64,

    /// 健康检查 URL
    pub health_check_url: String,
}

impl Default for ConsulConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            host: "192.168.0.141".to_string(),
            port: 8500,
            service_name: "task-orchestration-service".to_string(),
            service_id: format!("task-orchestration-service-{}", uuid::Uuid::new_v4()),
            service_host: "192.168.0.15".to_string(),
            service_port: 8084,
            health_check_interval: 10,
            health_check_timeout: 5,
            health_check_url: "http://192.168.0.15:8084/health".to_string(),
        }
    }
}
```

### 2.2 注册器实现

```rust
/// Consul 服务注册器
pub struct ConsulRegistry {
    /// 配置
    config: ConsulConfig,
    /// HTTP客户端
    client: Client,
    /// 是否已注册
    is_registered: Arc<AtomicBool>,
}

impl ConsulRegistry {
    /// 创建新的 Consul 注册器
    pub fn new(config: ConsulConfig) -> Result<Self> {
        if !config.enabled {
            info!("========================================");
            info!("  Consul 服务注册：已禁用");
            info!("  模式: 跳过（配置中 enabled=false）");
            info!("========================================");
        }

        let client = Client::builder()
            .timeout(std::time::Duration::from_secs(5))
            .build()
            .map_err(|e| ServiceError::NetworkError(e.to_string()))?;

        Ok(Self {
            config,
            client,
            is_registered: Arc::new(AtomicBool::new(false)),
        })
    }
}
```

### 2.3 服务注册

```rust
impl ConsulRegistry {
    /// 注册服务到 Consul
    pub async fn register(&self) -> Result<()> {
        if !self.config.enabled {
            return Ok(());
        }

        info!("========================================");
        info!("  正在注册服务到 Consul");
        info!("  Consul: {}:{}", self.config.host, self.config.port);
        info!("  服务名称: {}", self.config.service_name);
        info!("  服务ID: {}", self.config.service_id);
        info!("========================================");

        let registration = ServiceRegistration {
            id: self.config.service_id.clone(),
            name: self.config.service_name.clone(),
            address: self.config.service_host.clone(),
            port: self.config.service_port,
            tags: vec!["grpc".to_string(), "task-orchestration".to_string()],
            check: HealthCheck {
                // HTTP检查或TCP检查
                http: if !self.config.health_check_url.is_empty() {
                    Some(self.config.health_check_url.clone())
                } else {
                    None
                },
                tcp: if self.config.health_check_url.is_empty() {
                    Some(format!(
                        "{}:{}",
                        self.config.service_host, self.config.service_port
                    ))
                } else {
                    None
                },
                interval: format!("{}s", self.config.health_check_interval),
                timeout: format!("{}s", self.config.health_check_timeout),
                deregister_critical_service_after: "30s".to_string(),
            },
        };

        let url = format!(
            "http://{}:{}/v1/agent/service/register",
            self.config.host, self.config.port
        );

        match self.client.put(&url).json(&registration).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    self.is_registered.store(true, Ordering::SeqCst);
                    info!("✅ Consul 服务注册成功");
                    Ok(())
                } else {
                    warn!("⚠️  Consul 注册失败，状态码: {}", response.status());
                    warn!("   模式: 可选，继续启动服务");
                    Ok(()) // 不阻止启动
                }
            }
            Err(e) => {
                warn!("⚠️  Consul 不可用: {}", e);
                warn!("   模式: 可选，继续启动服务");
                Ok(()) // 不阻止启动
            }
        }
    }
}
```

### 2.4 服务注销

```rust
impl ConsulRegistry {
    /// 从 Consul 注销服务
    pub async fn deregister(&self) -> Result<()> {
        if !self.config.enabled {
            info!("跳过 Consul 注销（未启用）");
            return Ok(());
        }

        if !self.is_registered.load(Ordering::SeqCst) {
            info!("跳过 Consul 注销（服务未成功注册）");
            return Ok(());
        }

        info!("正在从 Consul 注销服务...");

        let url = format!(
            "http://{}:{}/v1/agent/service/deregister/{}",
            self.config.host, self.config.port, self.config.service_id
        );

        match self.client.put(&url).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    self.is_registered.store(false, Ordering::SeqCst);
                    info!("✅ Consul 服务注销成功");
                    Ok(())
                } else {
                    error!("Consul 注销失败，状态码: {}", response.status());
                    Err(ServiceError::ConfigError("注销失败".to_string()))
                }
            }
            Err(e) => {
                error!("Consul 不可用: {}", e);
                Err(ServiceError::NetworkError(e.to_string()))
            }
        }
    }
}
```

### 2.5 服务发现

```rust
impl ConsulRegistry {
    /// 发现服务
    pub async fn discover_service(&self, service_name: &str) -> Result<Vec<ServiceInstance>> {
        if !self.config.enabled {
            return Err(ServiceError::ConfigError("Consul 未启用".to_string()));
        }

        // 只获取健康的服务实例
        let url = format!(
            "http://{}:{}/v1/health/service/{}?passing",
            self.config.host, self.config.port, service_name
        );

        let response = self.client.get(&url).send().await
            .map_err(|e| ServiceError::NetworkError(e.to_string()))?;

        if !response.status().is_success() {
            return Err(ServiceError::NetworkError(format!(
                "服务发现失败: {}",
                response.status()
            )));
        }

        let services: Vec<ConsulService> = response.json().await
            .map_err(|e| ServiceError::NetworkError(e.to_string()))?;

        Ok(services.into_iter().map(|s| ServiceInstance {
            id: s.service.id,
            name: s.service.service,
            address: s.service.address,
            port: s.service.port,
        }).collect())
    }
}
```

---

## 3. ServiceDiscovery - 服务发现客户端

### 3.1 负载均衡策略

```rust
/// 负载均衡策略
#[derive(Debug, Clone, Copy)]
pub enum LoadBalanceStrategy {
    /// 轮询：依次选择每个实例
    RoundRobin,

    /// 随机：随机选择一个实例
    Random,

    /// 粘性：始终返回同一个实例（第一次随机选择，后续一直使用该实例）
    Sticky,
}
```

### 3.2 发现客户端实现

```rust
/// 服务发现客户端
pub struct ServiceDiscovery {
    /// Consul 注册器
    consul: Arc<ConsulRegistry>,

    /// 服务实例缓存
    service_cache: Arc<RwLock<HashMap<String, Vec<ServiceInstance>>>>,

    /// 负载均衡策略
    strategy: LoadBalanceStrategy,

    /// 轮询计数器
    round_robin_counter: Arc<RwLock<HashMap<String, usize>>>,

    /// 粘性实例缓存
    sticky_instance_cache: Arc<RwLock<HashMap<String, ServiceInstance>>>,
}

impl ServiceDiscovery {
    /// 创建新的服务发现客户端
    pub fn new(consul: Arc<ConsulRegistry>, strategy: LoadBalanceStrategy) -> Self {
        Self {
            consul,
            service_cache: Arc::new(RwLock::new(HashMap::new())),
            strategy,
            round_robin_counter: Arc::new(RwLock::new(HashMap::new())),
            sticky_instance_cache: Arc::new(RwLock::new(HashMap::new())),
        }
    }
}
```

### 3.3 获取服务实例

```rust
impl ServiceDiscovery {
    /// 获取服务实例（带负载均衡）
    ///
    /// # 参数
    /// - `service_name`: 服务名称
    /// - `refresh`: 是否强制刷新缓存
    ///
    /// # 返回
    /// 选中的服务实例
    pub async fn get_service_instance(
        &self,
        service_name: &str,
        refresh: bool,
    ) -> Result<ServiceInstance> {
        // 获取所有实例
        let instances = if refresh {
            self.discover_and_cache(service_name).await?
        } else {
            self.get_cached_or_discover(service_name).await?
        };

        if instances.is_empty() {
            return Err(ServiceError::ServiceDiscoveryError(format!(
                "没有找到可用的服务实例: {}",
                service_name
            )));
        }

        // 根据策略选择实例
        let selected = match self.strategy {
            LoadBalanceStrategy::RoundRobin => {
                self.select_round_robin(service_name, &instances).await
            }
            LoadBalanceStrategy::Random => {
                self.select_random(&instances)
            }
            LoadBalanceStrategy::Sticky => {
                self.select_sticky(service_name, &instances).await
            }
        };

        info!(
            service_name = service_name,
            instance_id = selected.id,
            address = format!("{}:{}", selected.address, selected.port),
            "选择服务实例"
        );

        Ok(selected)
    }
}
```

### 3.4 负载均衡实现

```rust
impl ServiceDiscovery {
    /// 轮询选择
    async fn select_round_robin(
        &self,
        service_name: &str,
        instances: &[ServiceInstance],
    ) -> ServiceInstance {
        let mut counter = self.round_robin_counter.write().await;
        let current = counter.entry(service_name.to_string()).or_insert(0);

        let selected = instances[*current % instances.len()].clone();
        *current = (*current + 1) % instances.len();

        selected
    }

    /// 随机选择
    fn select_random(&self, instances: &[ServiceInstance]) -> ServiceInstance {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        let index = rng.gen_range(0..instances.len());
        instances[index].clone()
    }

    /// 粘性选择：始终返回同一个实例
    async fn select_sticky(
        &self,
        service_name: &str,
        instances: &[ServiceInstance],
    ) -> ServiceInstance {
        let mut cache = self.sticky_instance_cache.write().await;

        if let Some(cached_instance) = cache.get(service_name) {
            debug!(
                service_name = service_name,
                instance_id = cached_instance.id,
                "使用粘性缓存的实例"
            );
            cached_instance.clone()
        } else {
            // 第一次调用时随机选择一个实例
            let selected = self.select_random(instances);
            debug!(
                service_name = service_name,
                instance_id = selected.id,
                "粘性模式：首次选择，已缓存该实例"
            );
            cache.insert(service_name.to_string(), selected.clone());
            selected
        }
    }
}
```

### 3.5 缓存管理

```rust
impl ServiceDiscovery {
    /// 获取缓存的实例或发现新实例
    async fn get_cached_or_discover(
        &self,
        service_name: &str
    ) -> Result<Vec<ServiceInstance>> {
        // 先尝试从缓存获取
        {
            let cache = self.service_cache.read().await;
            if let Some(instances) = cache.get(service_name) {
                if !instances.is_empty() {
                    debug!(
                        service_name = service_name,
                        count = instances.len(),
                        "使用缓存的服务实例"
                    );
                    return Ok(instances.clone());
                }
            }
        }

        // 缓存未命中，发现并缓存
        self.discover_and_cache(service_name).await
    }

    /// 发现服务并缓存
    async fn discover_and_cache(
        &self,
        service_name: &str
    ) -> Result<Vec<ServiceInstance>> {
        debug!(service_name = service_name, "从 Consul 发现服务");

        let instances = self.consul.discover_service(service_name).await?;

        if instances.is_empty() {
            warn!(service_name = service_name, "未发现任何服务实例");
        } else {
            info!(
                service_name = service_name,
                count = instances.len(),
                "发现服务实例"
            );

            // 更新缓存
            let mut cache = self.service_cache.write().await;
            cache.insert(service_name.to_string(), instances.clone());
        }

        Ok(instances)
    }

    /// 清除服务缓存
    pub async fn clear_cache(&self, service_name: Option<&str>) {
        let mut cache = self.service_cache.write().await;
        let mut sticky_cache = self.sticky_instance_cache.write().await;

        if let Some(name) = service_name {
            cache.remove(name);
            sticky_cache.remove(name);
            info!(service_name = name, "清除服务缓存");
        } else {
            cache.clear();
            sticky_cache.clear();
            info!("清除所有服务缓存");
        }
    }

    /// 获取服务地址（格式：host:port）
    pub async fn get_service_address(&self, service_name: &str) -> Result<String> {
        let instance = self.get_service_instance(service_name, false).await?;
        Ok(format!("{}:{}", instance.address, instance.port))
    }
}
```

---

## 4. 数据结构

### 4.1 服务实例

```rust
/// 服务实例
#[derive(Debug, Clone)]
pub struct ServiceInstance {
    /// 实例ID
    pub id: String,
    /// 服务名称
    pub name: String,
    /// 服务地址
    pub address: String,
    /// 服务端口
    pub port: u16,
}
```

### 4.2 服务注册信息

```rust
/// 服务注册信息（发送给Consul）
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceRegistration {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Address")]
    address: String,
    #[serde(rename = "Port")]
    port: u16,
    #[serde(rename = "Tags")]
    tags: Vec<String>,
    #[serde(rename = "Check")]
    check: HealthCheck,
}

/// 健康检查配置
#[derive(Debug, Clone, Serialize, Deserialize)]
struct HealthCheck {
    #[serde(rename = "HTTP", skip_serializing_if = "Option::is_none")]
    http: Option<String>,
    #[serde(rename = "TCP", skip_serializing_if = "Option::is_none")]
    tcp: Option<String>,
    #[serde(rename = "Interval")]
    interval: String,
    #[serde(rename = "Timeout")]
    timeout: String,
    #[serde(rename = "DeregisterCriticalServiceAfter")]
    deregister_critical_service_after: String,
}
```

---

## 5. 配置选项

### 5.1 TOML配置

```toml
# config.toml

[consul]
# 是否启用Consul
enabled = true

# Consul服务器地址
host = "192.168.0.141"
port = 8500

# 本服务信息
service_name = "task-orchestration-service"
service_id = "task-orchestration-service-1"
service_host = "192.168.0.15"
service_port = 8084

# 健康检查配置
health_check_interval = 10
health_check_timeout = 5
health_check_url = "http://192.168.0.15:8084/health"

# 负载均衡策略: RoundRobin, Random, Sticky
load_balance_strategy = "Sticky"
```

### 5.2 环境变量

```bash
# 启用Consul
export CONSUL_ENABLED=true

# Consul地址
export CONSUL_HOST=192.168.0.141
export CONSUL_PORT=8500

# 服务信息
export SERVICE_NAME=task-orchestration-service
export SERVICE_HOST=192.168.0.15
export SERVICE_PORT=8084

# 负载均衡策略
export LOAD_BALANCE_STRATEGY=Sticky
```

---

## 6. 使用示例

### 6.1 服务启动时注册

```rust
async fn main() -> Result<()> {
    // 加载配置
    let config = load_config()?;

    // 创建Consul注册器
    let consul = Arc::new(ConsulRegistry::new(config.consul.clone())?);

    // 注册服务
    consul.register().await?;

    // 创建服务发现客户端
    let discovery = ServiceDiscovery::new(
        consul.clone(),
        LoadBalanceStrategy::Sticky,
    );

    // 启动服务...
    run_server(discovery).await?;

    // 服务停止时注销
    consul.deregister().await?;

    Ok(())
}
```

### 6.2 调用远程服务

```rust
async fn call_tool_service(
    discovery: &ServiceDiscovery,
    request: ToolRequest,
) -> Result<ToolResponse> {
    // 发现Tool Service实例
    let address = discovery.get_service_address("tool-service").await?;

    // 创建gRPC客户端
    let channel = tonic::transport::Channel::from_shared(
        format!("http://{}", address)
    )?
    .connect()
    .await?;

    let mut client = ToolServiceClient::new(channel);

    // 调用服务
    let response = client.execute_tool(request).await?;

    Ok(response.into_inner())
}
```

---

## 7. 优雅关闭

### 7.1 Drop实现警告

```rust
impl Drop for ConsulRegistry {
    fn drop(&mut self) {
        if self.is_registered.load(Ordering::SeqCst) {
            warn!("⚠️  ConsulRegistry 正在析构，但服务仍已注册");
            warn!("   建议: 显式调用 deregister() 进行优雅注销");
        }
    }
}
```

### 7.2 信号处理

```rust
async fn run_with_graceful_shutdown(consul: Arc<ConsulRegistry>) {
    // 监听终止信号
    let ctrl_c = tokio::signal::ctrl_c();

    tokio::select! {
        _ = run_server() => {}
        _ = ctrl_c => {
            info!("收到终止信号，开始优雅关闭...");
        }
    }

    // 注销服务
    if let Err(e) = consul.deregister().await {
        error!("服务注销失败: {}", e);
    }

    info!("服务已安全停止");
}
```

---

## 8. 迁移实现清单

### 8.1 ConsulRegistry

- [ ] 实现 `ConsulConfig` 配置结构
- [ ] 实现 `ConsulRegistry` 注册器
- [ ] 实现 `register` 服务注册
- [ ] 实现 `deregister` 服务注销
- [ ] 实现 `discover_service` 服务发现

### 8.2 ServiceDiscovery

- [ ] 实现 `LoadBalanceStrategy` 枚举
- [ ] 实现 `ServiceDiscovery` 客户端
- [ ] 实现轮询负载均衡
- [ ] 实现随机负载均衡
- [ ] 实现粘性负载均衡
- [ ] 实现服务缓存机制

### 8.3 集成

- [ ] 在服务启动时注册
- [ ] 在服务停止时注销
- [ ] 在工具调用时使用服务发现

---

## 9. 相关文档

- [08-API与服务接口](./08-API与服务接口.md) - gRPC服务接口
- [09-配置与部署指南](./09-配置与部署指南.md) - 部署配置

---

**文档维护者**: Task Orchestration Team
**最后更新**: 2026-01-05
