# 07-并行执行机制

## 概述

本文档详细描述任务编排服务的两层并行执行架构，包括步骤间并行和步骤内并行两种机制。

## 两层并行执行架构

```
┌─────────────────────────────────────────────────────────────┐
│                    任务编排服务 (Orchestrator)                │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│              第一层: 步骤间并行 (Step-Level Parallel)         │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐               │
│  │ Step 1   │ →  │ Step 2   │ →  │ Step 4   │               │
│  └──────────┘    │ Step 3   │    └──────────┘               │
│                  └──────────┘                                │
│  说明: Step 2 和 Step 3 无依赖关系,可并行执行                 │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│           第二层: 步骤内并行 (Action-Level Parallel)          │
│  Step 2 内部:                                                │
│  ┌──────────────┐    ┌──────────────┐                       │
│  │ Action_2_1   │    │ Action_2_2   │  ← 并行执行            │
│  └──────────────┘    └──────────────┘                       │
│         ↓                    ↓                               │
│         └────────┬───────────┘                               │
│                  ↓                                           │
│         ┌──────────────┐                                     │
│         │ Action_2_3   │  ← 依赖前两个action                 │
│         └──────────────┘                                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 第一层：步骤间并行执行

### 核心文件
- **实现文件**: `src/core/parallel_executor.rs`

### DAG依赖分析

```rust
// parallel_executor.rs

/// 执行节点
#[derive(Debug, Clone)]
pub struct ExecutionNode {
    pub step_id: String,
    pub dependencies: Vec<String>,
    pub status: NodeStatus,
}

#[derive(Debug, Clone, PartialEq)]
pub enum NodeStatus {
    Pending,
    Ready,
    Running,
    Completed,
    Failed,
}

/// 并行执行器
pub struct ParallelExecutor {
    /// 最大并发数
    max_concurrent: usize,
    /// 最小步骤数阈值
    min_steps: usize,
}

impl ParallelExecutor {
    pub fn new(max_concurrent: usize, min_steps: usize) -> Self {
        Self {
            max_concurrent,
            min_steps,
        }
    }

    /// 构建DAG依赖图
    pub fn build_dag(&self, steps: &[PlanStep]) -> HashMap<String, ExecutionNode> {
        let mut dag = HashMap::new();

        for step in steps {
            let node = ExecutionNode {
                step_id: step.step_id.clone(),
                dependencies: step.dependencies.clone(),
                status: NodeStatus::Pending,
            };
            dag.insert(step.step_id.clone(), node);
        }

        dag
    }

    /// Kahn拓扑排序 - 计算执行批次
    pub fn compute_execution_batches(&self, dag: &HashMap<String, ExecutionNode>)
        -> Result<Vec<Vec<String>>, PlanError>
    {
        let mut batches = Vec::new();
        let mut in_degree: HashMap<String, usize> = HashMap::new();
        let mut remaining = dag.clone();

        // 初始化入度
        for (step_id, node) in &remaining {
            in_degree.insert(step_id.clone(), node.dependencies.len());
        }

        while !remaining.is_empty() {
            // 找出所有入度为0的节点
            let ready: Vec<String> = in_degree
                .iter()
                .filter(|(id, &degree)| degree == 0 && remaining.contains_key(*id))
                .map(|(id, _)| id.clone())
                .collect();

            if ready.is_empty() {
                // 检测到环
                return Err(PlanError::CyclicDependency);
            }

            // 当前批次
            batches.push(ready.clone());

            // 移除已处理节点，更新依赖节点的入度
            for step_id in &ready {
                remaining.remove(step_id);

                // 更新所有依赖此节点的入度
                for (id, node) in &remaining {
                    if node.dependencies.contains(step_id) {
                        *in_degree.get_mut(id).unwrap() -= 1;
                    }
                }
            }
        }

        Ok(batches)
    }
}
```

### 批次执行流程

```rust
impl ParallelExecutor {
    /// 并行执行计划
    pub async fn execute_parallel(
        &self,
        plan: &ExecutionPlan,
        context: &ExecutionContext,
        executor: &Executor,
    ) -> Result<Vec<StepResult>, ExecutionError> {
        let steps = &plan.steps;

        // 检查是否满足并行条件
        if steps.len() < self.min_steps {
            info!("步骤数 {} < 阈值 {}, 使用串行执行", steps.len(), self.min_steps);
            return executor.execute_serial(plan, context).await;
        }

        // 构建DAG并计算批次
        let dag = self.build_dag(steps);
        let batches = self.compute_execution_batches(&dag)?;

        info!("计划分为 {} 个执行批次", batches.len());

        // 创建信号量控制并发
        let semaphore = Arc::new(Semaphore::new(self.max_concurrent));
        let mut all_results = Vec::new();

        // 按批次执行
        for (batch_idx, batch) in batches.iter().enumerate() {
            info!("开始执行批次 {}/{}, 包含 {} 个步骤",
                  batch_idx + 1, batches.len(), batch.len());

            // 创建批次内的并行任务
            let mut tasks = Vec::new();

            for step_id in batch {
                let step = steps.iter()
                    .find(|s| &s.step_id == step_id)
                    .unwrap()
                    .clone();

                let semaphore_clone = semaphore.clone();
                let context_clone = context.clone();
                let executor_clone = executor.clone();

                let task = tokio::spawn(async move {
                    // 获取信号量许可
                    let _permit = semaphore_clone.acquire().await.unwrap();

                    info!(step_id = %step.step_id, "开始执行步骤");

                    // 执行步骤
                    let result = executor_clone
                        .execute_single_step(&step, &context_clone)
                        .await;

                    info!(step_id = %step.step_id, "步骤执行完成");

                    result
                    // _permit 在此自动释放
                });

                tasks.push(task);
            }

            // 等待批次内所有任务完成
            let results = join_all(tasks).await;

            // 处理结果
            let mut has_failure = false;
            for result in results {
                match result {
                    Ok(Ok(step_result)) => {
                        if !step_result.is_success {
                            has_failure = true;
                        }
                        // 同步结果到上下文
                        context.set_step_result(step_result.clone());
                        all_results.push(step_result);
                    }
                    Ok(Err(e)) => {
                        has_failure = true;
                        error!("步骤执行错误: {}", e);
                    }
                    Err(e) => {
                        has_failure = true;
                        error!("任务panic: {}", e);
                    }
                }
            }

            // 早期失败终止
            if has_failure {
                warn!("批次 {} 执行失败，停止后续批次", batch_idx + 1);
                break;
            }
        }

        Ok(all_results)
    }
}
```

### 示例：批次划分

```
输入计划:
  step_1: deps=[]
  step_2: deps=[step_1]
  step_3: deps=[step_1]
  step_4: deps=[step_2, step_3]

执行批次:
  Batch 1: [step_1]           ← 串行
  Batch 2: [step_2, step_3]   ← 并行 (2个任务同时执行)
  Batch 3: [step_4]           ← 串行
```

---

## 第二层：步骤内并行执行

### 核心文件
- **实现文件**: `src/core/executor.rs` (方法: `execute_step_with_actions`)

### Protocol Buffer 定义

```protobuf
// proto/task_orchestrator_service.proto

// 步骤中的单个操作(用于步骤内并行执行)
message PlanAction {
    // 操作ID (唯一标识,用于依赖引用)
    string action_id = 1;

    // 操作名称
    string name = 2;

    // 工具名称
    string tool = 3;

    // 工具参数（JSON格式）
    string parameters = 4;

    // 依赖的操作ID列表 (action_id引用)
    repeated string dependencies = 5;

    // 操作描述/期望输出
    string description = 6;
}

message PlanStep {
    // 步骤ID
    string step_id = 1;

    // 步骤名称
    string name = 2;

    // 【兼容旧版】工具名称 (当actions为空时使用)
    string tool = 3;

    // 【兼容旧版】工具参数（JSON格式）(当actions为空时使用)
    string parameters = 4;

    // 依赖步骤ID列表
    repeated string dependencies = 5;

    // 步骤描述
    string description = 6;

    // 【新增】步骤内的并行操作列表
    repeated PlanAction actions = 7;
}
```

### 步骤内并行执行实现

```rust
// executor.rs

impl Executor {
    /// 执行包含多个actions的步骤
    async fn execute_step_with_actions(
        &self,
        step: &PlanStep,
        context: &ExecutionContext,
        tool_map: &HashMap<String, ToolInfo>,
        step_index: usize,
        total_steps: usize,
    ) -> Result<StepResult> {
        let start_time = Instant::now();

        info!(
            step_id = %step.step_id,
            actions_count = step.actions.len(),
            "开始并行执行步骤内的 {} 个操作",
            step.actions.len()
        );

        // 创建信号量控制并发
        let semaphore = Arc::new(Semaphore::new(self.parallel_max_concurrent));

        // 为每个action创建异步任务
        let mut tasks = Vec::new();

        for action in &step.actions {
            let action_clone = action.clone();
            let context_clone = context.clone();
            let tool_client = self.tool_client.clone();
            let semaphore_clone = semaphore.clone();
            let timeout_duration = self.execution_timeout;

            let task = tokio::spawn(async move {
                // 获取信号量许可
                let _permit = semaphore_clone.acquire().await.unwrap();

                let action_start = Instant::now();

                info!(
                    action_id = %action_clone.action_id,
                    "开始执行操作"
                );

                // 解析参数并处理占位符
                let parameters = Self::parse_action_parameters(
                    &action_clone.parameters,
                    &context_clone
                )?;

                // 调用工具
                let tool_result = match timeout(
                    timeout_duration,
                    tool_client.call_tool(&action_clone.tool, parameters)
                ).await {
                    Ok(Ok(output)) => {
                        info!(action_id = %action_clone.action_id, "操作执行成功");
                        (
                            action_clone.action_id.clone(),
                            true,
                            output,
                            None,
                            action_start.elapsed().as_millis() as u64,
                        )
                    }
                    Ok(Err(e)) => {
                        error!(action_id = %action_clone.action_id, error = %e, "操作执行失败");
                        (
                            action_clone.action_id.clone(),
                            false,
                            String::new(),
                            Some(e.to_string()),
                            action_start.elapsed().as_millis() as u64,
                        )
                    }
                    Err(_) => {
                        error!(action_id = %action_clone.action_id, "操作超时");
                        (
                            action_clone.action_id.clone(),
                            false,
                            String::new(),
                            Some(format!("操作超时({:.1}秒)", timeout_duration.as_secs_f32())),
                            timeout_duration.as_millis() as u64,
                        )
                    }
                };

                Ok::<_, anyhow::Error>(tool_result)
            });

            tasks.push(task);
        }

        // 等待所有任务完成
        let results = join_all(tasks).await;

        // 处理结果
        let mut action_results_map: HashMap<String, (bool, String)> = HashMap::new();
        let mut has_failure = false;
        let mut error_messages = Vec::new();

        for result in results {
            match result {
                Ok(Ok((action_id, is_success, output, error_msg, exec_time))) => {
                    if !is_success {
                        has_failure = true;
                        if let Some(err) = &error_msg {
                            error_messages.push(format!("{}: {}", action_id, err));
                        }
                    }

                    action_results_map.insert(action_id.clone(), (is_success, output.clone()));

                    // 保存每个action的结果到上下文
                    context.set_step_result(StepExecutionResult {
                        step_id: action_id.clone(),  // 使用action_id作为key
                        step_name: String::new(),
                        tool_id: String::new(),
                        output,
                        is_success,
                        error_message: error_msg,
                    });
                }
                Ok(Err(e)) => {
                    has_failure = true;
                    error_messages.push(e.to_string());
                }
                Err(e) => {
                    has_failure = true;
                    error_messages.push(format!("任务panic: {}", e));
                }
            }
        }

        // 聚合输出
        let mut ordered_outputs = Vec::new();
        for action in &step.actions {
            if let Some((is_success, output)) = action_results_map.get(&action.action_id) {
                ordered_outputs.push(format!(
                    "[{}] {} {}",
                    action.action_id,
                    if *is_success { "✅" } else { "❌" },
                    output
                ));
            }
        }
        let aggregated_output = ordered_outputs.join("\n");

        let total_time = start_time.elapsed().as_millis() as u64;

        // 构建聚合的StepResult
        let step_result = StepResult {
            step_id: step.step_id.clone(),
            step_name: step.name.clone(),
            tool_id: format!("parallel_actions({} ops)", step.actions.len()),
            is_success: !has_failure,
            output: aggregated_output,
            error_message: if error_messages.is_empty() {
                None
            } else {
                Some(error_messages.join("; "))
            },
            execution_time_ms: total_time,
            tool_parameters: None,
        };

        Ok(step_result)
    }

    /// 解析action参数
    fn parse_action_parameters(
        parameters: &str,
        context: &ExecutionContext
    ) -> Result<HashMap<String, String>> {
        if parameters.is_empty() {
            return Ok(HashMap::new());
        }

        let params_obj: HashMap<String, serde_json::Value> =
            serde_json::from_str(parameters)?;

        let resolved: HashMap<String, String> = params_obj
            .into_iter()
            .map(|(k, v)| {
                let value_str = match v {
                    serde_json::Value::String(s) => s,
                    serde_json::Value::Number(n) => n.to_string(),
                    serde_json::Value::Bool(b) => b.to_string(),
                    serde_json::Value::Null => "null".to_string(),
                    _ => serde_json::to_string(&v).unwrap_or_default(),
                };

                // 处理占位符
                let resolved_value = ParameterResolver::process_parameter_value(
                    &value_str,
                    context
                );

                (k, resolved_value)
            })
            .collect();

        Ok(resolved)
    }
}
```

### 执行格式检测

```rust
// executor.rs

impl Executor {
    /// 执行单个步骤（支持新旧两种格式）
    pub async fn execute_single_step_with_overrides(
        &self,
        plan: &ExecutionPlan,
        step_index: usize,
        context: &ExecutionContext,
        available_tools: &[ToolInfo],
        parameter_overrides: Option<&HashMap<String, String>>,
    ) -> Result<StepResult> {
        let step = &plan.steps[step_index];

        // 检查是否使用actions格式
        if !step.actions.is_empty() {
            info!(
                step_id = %step.step_id,
                actions_count = step.actions.len(),
                "步骤包含{}个操作,准备并行执行",
                step.actions.len()
            );

            // 构建tool_map
            let tool_map: HashMap<String, ToolInfo> = available_tools
                .iter()
                .map(|t| (t.id.clone(), t.clone()))
                .collect();

            // 使用actions并行执行
            return self.execute_step_with_actions(
                step,
                context,
                &tool_map,
                step_index,
                plan.steps.len(),
            ).await;
        }

        // 否则使用旧格式(tool + parameters)
        self.execute_single_tool(step, context, parameter_overrides).await
    }
}
```

---

## 占位符解析增强

### 多占位符支持

```rust
// parameter_resolver.rs

use lazy_static::lazy_static;
use regex::Regex;

lazy_static! {
    // 匹配所有 {{...}} 或 {{{...}}} 占位符
    static ref PLACEHOLDER_REGEX: Regex =
        Regex::new(r"\{\{\{([^}]+)\}\}\}|\{\{([^}]+)\}\}").unwrap();
}

impl ParameterResolver {
    /// 处理参数值中的所有占位符
    pub fn process_parameter_value(
        value: &str,
        context: &ExecutionContext
    ) -> String {
        let mut result = value.to_string();

        // 迭代替换所有占位符
        for cap in PLACEHOLDER_REGEX.captures_iter(value) {
            let full_match = cap.get(0).unwrap().as_str();

            // 提取占位符内容
            let placeholder_content = cap.get(1)
                .or_else(|| cap.get(2))
                .map(|m| m.as_str())
                .unwrap_or("");

            // 解析占位符
            let resolved = Self::resolve_single_placeholder(placeholder_content, context);

            // 替换
            result = result.replace(full_match, &resolved);
        }

        result
    }

    /// 解析单个占位符
    fn resolve_single_placeholder(
        placeholder: &str,
        context: &ExecutionContext
    ) -> String {
        // 支持的格式:
        // - step_id.output      -> 步骤输出
        // - action_id.output    -> Action输出
        // - step_id.field       -> 步骤特定字段

        let parts: Vec<&str> = placeholder.split('.').collect();
        if parts.len() < 2 {
            return placeholder.to_string();
        }

        let id = parts[0];
        let field = parts[1];

        match field {
            "output" => {
                // 尝试从step_results获取
                if let Some(output) = context.get_step_output(id) {
                    return output;
                }
                // 尝试从runtime_metadata获取
                if let Some(output) = context.get_runtime_metadata(id) {
                    return output;
                }
                // 返回空字符串
                String::new()
            }
            _ => {
                // 其他字段
                context.get_step_field(id, field)
                    .unwrap_or_default()
            }
        }
    }
}
```

### 使用示例

```json
{
  "step_id": "step_2",
  "actions": [
    {
      "action_id": "action_2_1",
      "tool": "python",
      "parameters": {
        "code": "{{action_1_1.output}} + {{action_1_2.output}}"
      }
    }
  ]
}

// 解析后:
// "code": "25 + 64"  (假设action_1_1.output=25, action_1_2.output=64)
```

---

## 步骤ID重编号机制

### 问题场景

LLM重新规划时，生成的step_id可能从中间开始：
```
step_4 (deps=[])
step_5 (deps=[step_4])
step_6 (deps=[step_5])
```

### 解决方案

```rust
// planner.rs

impl Planner {
    /// 重编号步骤ID
    fn renumber_step_ids(&self, steps: &mut Vec<PlanStep>) {
        // 1. 建立映射表: LLM生成的ID → 新的连续ID
        let mut llm_to_new_id_map: HashMap<String, String> = HashMap::new();

        for (idx, step) in steps.iter().enumerate() {
            let new_id = format!("step_{}", idx + 1);  // 强制从1开始
            llm_to_new_id_map.insert(step.step_id.clone(), new_id.clone());
        }

        // 2. 更新所有步骤的ID和依赖
        for step in steps.iter_mut() {
            // 更新step_id
            if let Some(new_id) = llm_to_new_id_map.get(&step.step_id) {
                step.step_id = new_id.clone();
            }

            // 更新dependencies
            step.dependencies = step.dependencies
                .iter()
                .filter_map(|dep| llm_to_new_id_map.get(dep).cloned())
                .collect();

            // 更新actions中的依赖
            for action in &mut step.actions {
                action.dependencies = action.dependencies
                    .iter()
                    .filter_map(|dep| llm_to_new_id_map.get(dep).cloned())
                    .collect();
            }
        }
    }
}
```

### 效果示例

```
LLM输出              重编号后
step_4 (deps=[])  →  step_1 (deps=[])
step_5 (deps=[4]) →  step_2 (deps=[1])
step_6 (deps=[5]) →  step_3 (deps=[2])
```

---

## 配置说明

### 配置文件: `config.dev.toml`

```toml
[orchestrator]
# 是否启用并行执行
# - true: 自动检测无依赖步骤并并行执行（推荐）
# - false: 强制串行执行（向后兼容模式）
enable_parallel_execution = true

# 并行执行的最大并发数
# 控制同时执行的最大步骤数量，避免资源耗尽
# 建议值：
# - IO密集型任务: CPU核心数 * 2~4
# - CPU密集型任务: CPU核心数
# - 混合型任务: CPU核心数 * 2
parallel_max_concurrent = 8

# 并行执行的最小步骤数阈值
# 只有当计划步骤数量 >= 此阈值时，才会启用并行执行
parallel_min_steps = 1

[reflection]
# 是否启用步骤级反思
enable_step_level_reflection = true

# 最大连续失败次数
max_consecutive_failures = 3

# 最大重新规划次数
max_replanning_attempts = 3
```

---

## 与反思机制的集成

### 聚合结果格式

```rust
// 反思器收到的聚合StepResult
StepResult {
    step_id: "step_1",
    step_name: "并行计算平方数",
    tool_id: "parallel_actions(3 ops)",  // 标识这是并行执行
    is_success: false,                    // 整体失败状态
    output: "[action_1_1] ✅ 25\n[action_1_2] ❌ error\n[action_1_3] ✅ 144",
    error_message: Some("action_1_2: division by zero"),
}
```

### 反思器处理流程

```
1. 检测到步骤失败 (is_success=false)
   ↓
2. 分析output,识别出:
   - action_1_1: 成功
   - action_1_2: 失败 (除零错误)
   - action_1_3: 成功
   ↓
3. 可能的反思策略:
   ├─ 策略A: 重新规划,修复action_1_2的参数
   ├─ 策略B: 使用备选工具替换失败的action
   ├─ 策略C: 移除失败的action,继续后续步骤
   └─ 策略D: 调整参数覆盖,重试整个步骤
```

### 设计优势

1. **透明集成**: 反思器无需修改代码，直接处理聚合后的StepResult
2. **信息完整**: 通过聚合输出可以看到所有执行细节
3. **灵活处理**: 反思器可以选择多种修复策略

---

## 向后兼容性

### 协议兼容

```rust
// 执行器自动检测格式
if !step.actions.is_empty() {
    // 新格式: 并行执行actions
    execute_step_with_actions(step).await
} else {
    // 旧格式: 单工具调用
    execute_single_tool(step.tool, step.parameters).await
}
```

### 渐进式升级路径

```
Phase 1: 串行执行 (serial_execution_version)
    ↓
Phase 2: 步骤间并行 (启用parallel_executor)
    ↓
Phase 3: 步骤内并行 (使用actions格式)
    ↓
Phase 4: 两层并行 (同时启用两种并行模式)
```

---

## 性能对比

| 场景 | 串行版本耗时 | 并行版本耗时 | 加速比 |
|------|-------------|-------------|--------|
| 3个独立步骤(每个2秒) | 6秒 | ~2秒 | 3x |
| 步骤内3个独立操作(每个1秒) | 3秒 | ~1秒 | 3x |
| 混合场景(6个步骤,部分并行) | 12秒 | ~4秒 | 3x |

---

## 最佳实践

### 适合使用Actions并行的场景

1. **批量数据处理**: 处理多个独立数据源
2. **多个相同操作**: 添加多个角色、创建多个对象
3. **独立计算**: 多个数值计算、多个API调用
4. **聚合场景**: 多个来源数据汇总

### 不适合使用Actions并行的场景

1. **强依赖关系**: action_2必须等action_1完成
2. **顺序敏感**: 操作顺序影响结果
3. **单个操作**: 只有一个action时无需并行
4. **资源竞争**: 多个action操作同一共享资源

### 示例对比

```json
// 推荐: 使用actions并行
{
  "step_id": "step_1",
  "step_name": "批量添加角色",
  "actions": [
    {"action_id": "action_1_1", "tool": "add_role", "parameters": {"role": "admin"}},
    {"action_id": "action_1_2", "tool": "add_role", "parameters": {"role": "user"}},
    {"action_id": "action_1_3", "tool": "add_role", "parameters": {"role": "guest"}}
  ]
}
// 执行时间: ~1秒 (3个并行)

// 不推荐: 分3个步骤
{
  "steps": [
    {"step_id": "step_1", "tool": "add_role", "parameters": {"role": "admin"}},
    {"step_id": "step_2", "tool": "add_role", "parameters": {"role": "user"}},
    {"step_id": "step_3", "tool": "add_role", "parameters": {"role": "guest"}}
  ]
}
// 执行时间: ~3秒 (3个串行)
```

---

## 关键代码索引

| 功能 | 文件位置 | 说明 |
|------|---------|------|
| DAG构建与批次计算 | `src/core/parallel_executor.rs` | 步骤间并行核心 |
| Actions格式检测 | `src/core/executor.rs:923-947` | 判断执行格式 |
| 并行执行入口 | `src/core/executor.rs:1992-1999` | execute_step_with_actions |
| 信号量创建 | `src/core/executor.rs:2015-2016` | 并发控制 |
| 占位符解析 | `src/core/parameter_resolver.rs` | 多占位符支持 |
| 步骤ID重编号 | `src/core/planner.rs` | 解决LLM重规划问题 |
| 协议定义 | `proto/task_orchestrator_service.proto:287-334` | PlanAction消息 |
