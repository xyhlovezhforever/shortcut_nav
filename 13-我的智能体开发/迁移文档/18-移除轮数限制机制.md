# 18 - 移除轮数限制 - 由大模型决定反思与重规划

> **文档版本**: v1.0
> **创建日期**: 2026-01-14
> **迁移优先级**: ⭐⭐⭐⭐ (高)

---

## 1. 概述

### 1.1 改动背景

本次架构升级移除了反思轮数和重新规划轮数的人为限制，将"是否继续反思"和"是否继续重新规划"的**决策权完全交给大模型**。

### 1.2 原有问题

在原有设计中，系统通过以下配置项来限制反思和重新规划的次数：

| 配置项 | 说明 | 默认值 |
|--------|------|--------|
| `max_reflection_rounds` | 最大反思轮次 | 5 轮 |
| `max_step_retries` | 单个步骤最大重试次数 | 3 次 |
| `max_task_replanning_attempts` | 任务级最大重新规划次数 | 1 次 |
| `max_consecutive_failures` | 最大连续失败次数 | 3 次 |

这种人为设定的轮数限制存在以下问题：

❌ **缺乏灵活性**: 不同任务的复杂度不同，固定的轮数限制可能导致简单任务浪费资源，复杂任务提前终止
❌ **无法适应上下文**: 大模型能够判断当前问题是否可以通过继续尝试解决，但人为限制忽略了这一信息
❌ **决策割裂**: 反思结果中的 `should_replan` 字段本就是大模型对是否继续的判断，再叠加轮数限制造成逻辑冗余

### 1.3 改动目标

✅ 移除所有人为设定的轮数限制
✅ 是否继续反思完全由大模型的 `should_replan` 字段决定
✅ 是否继续重试/重规划完全由大模型的 `suggested_action` 决定
✅ 保留配置项用于向后兼容，但实际不再生效

---

## 2. 决策流程变化

### 2.1 修改前：人为限制 + 大模型建议

```
┌─────────────────────────────────────────────────────────────┐
│                     反思循环（v1.0）                          │
├─────────────────────────────────────────────────────────────┤
│ 1. 检查是否达到最大轮次 → 是 → 强制终止                        │
│ 2. 检查连续失败次数 → 超限 → 强制终止                          │
│ 3. 执行反思 → 获取 should_replan                             │
│ 4. should_replan && !达到轮数限制 → 继续                      │
│                                                             │
│ 👎 问题：人为限制可能在大模型认为可以继续时强制终止             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 修改后：完全由大模型决定

```
┌─────────────────────────────────────────────────────────────┐
│                     反思循环（v1.1）                          │
├─────────────────────────────────────────────────────────────┤
│ 1. 执行反思 → 获取 should_replan                             │
│ 2. should_replan = true → 大模型认为需要继续 → 继续循环        │
│ 3. should_replan = false → 大模型认为已达最佳 → 终止循环       │
│ 4. is_quality_sufficient → 质量足够好 → 终止循环              │
│                                                             │
│ 👍 优势：大模型基于实际情况做出智能决策                         │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 核心改动

### 3.1 Task 结构体改动

**文件位置**: `src/state/task_state.rs`

```rust
// 修改前
pub max_rounds: u32,

// 修改后
/// 最大轮次（已弃用，保留用于向后兼容，实际不再用于限制轮数）
/// 是否继续反思/重新规划完全由大模型决定
#[serde(default = "default_max_rounds")]
pub max_rounds: u32,

fn default_max_rounds() -> u32 {
    u32::MAX // 默认无限制
}
```

`is_max_rounds_reached()` 方法修改为始终返回 `false`：

```rust
#[deprecated(note = "轮数限制已移除，是否继续由大模型决定")]
pub fn is_max_rounds_reached(&self) -> bool {
    // 始终返回 false，不再限制轮数
    // 是否继续反思/重新规划完全由大模型的 should_replan 决定
    false
}
```

### 3.2 ReflectionConfig 配置改动

**文件位置**: `src/config/mod.rs`

所有轮数限制配置项标记为弃用，默认值设为 `usize::MAX`：

```rust
pub struct ReflectionConfig {
    /// 单个步骤最大重试次数（已弃用，保留用于向后兼容）
    #[deprecated(note = "轮数限制已移除，是否继续重试由大模型决定")]
    #[serde(default = "default_max_step_retries")]
    pub max_step_retries: usize,

    /// 任务级别最大重新规划次数（已弃用，保留用于向后兼容）
    #[deprecated(note = "轮数限制已移除，是否继续重新规划由大模型决定")]
    #[serde(default = "default_max_task_replanning_attempts")]
    pub max_task_replanning_attempts: usize,

    /// 最大连续失败次数（已弃用，保留用于向后兼容）
    #[deprecated]
    #[serde(default = "default_max_consecutive_failures")]
    pub max_consecutive_failures: usize,

    /// 是否启用步骤级反思（仍然有效）
    #[serde(default = "default_enable_step_level_reflection")]
    pub enable_step_level_reflection: bool,
}

fn default_max_step_retries() -> usize {
    usize::MAX // 无限制，由大模型决定
}

fn default_max_task_replanning_attempts() -> usize {
    usize::MAX // 无限制，由大模型决定
}

fn default_max_consecutive_failures() -> usize {
    usize::MAX // 无限制，由大模型决定
}

fn default_enable_step_level_reflection() -> bool {
    true
}
```

### 3.3 OrchestratorConfig 配置改动

**文件位置**: `src/config/mod.rs` 和 `src/core/orchestrator.rs`

```rust
/// 最大反思轮次（已弃用，保留用于向后兼容）
#[deprecated(note = "轮数限制已移除，是否继续反思由大模型决定")]
#[serde(default = "default_max_reflection_rounds")]
pub max_reflection_rounds: u32,

fn default_max_reflection_rounds() -> u32 {
    u32::MAX // 无限制，由大模型决定
}
```

### 3.4 核心循环逻辑改动

**文件位置**: `src/core/orchestrator.rs`

#### 主反思循环

移除最大轮次检查和连续失败检查：

```rust
// 修改前
if task.is_max_rounds_reached() {
    return self.generate_final_output(task);
}
if consecutive_failures >= MAX_CONSECUTIVE_FAILURES {
    return Err(...);
}

// 修改后
// 注意：最大轮次检查已移除
// 是否继续反思完全由大模型通过 should_replan 字段决定
```

#### 循环终止条件

移除 `is_max_rounds_reached()` 检查：

```rust
// 修改前
let should_terminate = !reflection.should_replan
    || task.is_max_rounds_reached()
    || is_quality_sufficient;

// 修改后
// 完全由大模型的 should_replan 决定
let should_terminate = !reflection.should_replan || is_quality_sufficient;
```

---

## 4. 提示词软性引导

### 4.1 轮次参考指南

为避免大模型无限反思，在反思提示词中增加了**软性引导**：

```
📊 轮次参考指南（仅供参考，最终由你决定）：
   • 1-3 轮：正常范围，可根据需要继续优化
   • 4-5 轮：建议审视是否有实质性改进空间
   • 6-10 轮：⚠️ 超出常规范围，请认真评估继续反思的价值
   • 10 轮以上：🚨 强烈建议停止，除非有明确的新解决思路

⚠️ 重要提醒：
   - 是否继续反思完全由你决定，没有强制的轮数限制
   - 但请注意：连续多轮未能解决问题时，继续反思往往只是重复无效尝试
   - 当你发现无法提供新见解时，应果断设置 should_replan = false
```

这样做的好处：

✅ **软性引导而非硬性限制**: 大模型可以看到当前轮次，并参考指南做出判断
✅ **保留灵活性**: 对于确实需要更多轮次的复杂任务，大模型可以继续
✅ **避免无效循环**: 当轮次过多时，提示词会引导大模型考虑是否应该停止

### 4.2 单步反思的重试次数参考指南

在单步反思提示词中也增加了类似的重试次数参考指南：

```
📊 重试次数参考指南（仅供参考，最终由你决定）：
   • 1-2 次：正常范围，可根据错误类型调整参数重试
   • 3 次：建议仔细分析是否是参数问题，还是需要换工具/重规划
   • 4-5 次：⚠️ 超出常规范围，很可能当前方案存在根本性问题
   • 5 次以上：🚨 强烈建议 replan 或 stop，除非有明确的新解决思路

⚠️ 重要提醒：
   - 是否继续重试完全由你决定，没有强制的次数限制
   - 但请注意：连续多次重试相同类型的错误，往往说明问题不在参数层面
   - 当无法提供新见解时，应果断建议 replan 或 stop
```

---

## 5. 执行统计摘要

### 5.1 统计信息的作用

在执行历史（`ContextEngineeringEventBuilder.format_to_file()`）中增加了统计摘要，帮助大模型快速了解当前执行状态：

```markdown
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 执行统计摘要
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  • 当前反思轮次: 第 X 轮
  • 累计步骤重试次数: X 次
  • 累计任务重规划次数: X 次
  • 成功步骤数: X
  • 失败步骤数: X
```

### 5.2 大模型如何使用统计信息

大模型在进行反思时可以：

1. **快速了解当前执行进度**
2. **根据累计重试/重规划次数判断问题严重程度**
3. **结合统计信息做出更合理的继续/停止决策**

决策示例：

| 统计情况 | 大模型判断 | 建议动作 |
|---------|-----------|---------|
| 轮次 = 2，重试 = 1 | 正常范围 | 可以继续尝试 |
| 轮次 = 5，重试 = 8 | 重试过多 | 考虑更换方案 |
| 轮次 = 8，重规划 = 3 | 重规划过多 | 可能存在根本性问题 |
| 轮次 = 10+，无进展 | 无效循环 | 应该停止 |

---

## 6. 配置文件变更

### 6.1 config.dev.toml

```toml
[orchestrator]
# 最大反思轮次（已弃用，由大模型决定是否继续反思）
# 保留此配置项仅用于向后兼容，实际不再生效
# max_reflection_rounds = 5

[reflection]
# 是否启用步骤级反思
enable_step_level_reflection = true

# ==================== 以下配置项已弃用 ====================
# 是否继续反思/重试/重新规划完全由大模型决定
# 保留这些配置项仅用于向后兼容，实际不再生效

# 最大连续失败次数（已弃用，由大模型决定是否继续）
# max_consecutive_failures = 3

# 最大重新规划次数（已弃用，由大模型决定是否继续）
# max_replanning_attempts = 3
```

### 6.2 config.prod.toml

同样的改动应用于生产环境配置。

---

## 7. 向后兼容性

### 7.1 配置文件兼容

✅ 所有弃用的配置项仍可在配置文件中设置，但不会生效
✅ 不会破坏现有配置文件的加载

### 7.2 API 兼容

✅ `max_rounds` 等字段仍然存在于 API 响应中，但值为 `u32::MAX`
✅ 不会破坏现有的 API 客户端

### 7.3 日志兼容

✅ 轮次信息仍会记录在日志和 Kafka 中，用于监控
✅ 便于追踪和分析任务执行情况

---

## 8. 注意事项

### 8.1 任务超时保护

虽然移除了轮数限制，但仍有 `task_timeout_secs` 配置来防止任务无限执行：

```rust
// config.toml
[orchestrator]
task_timeout_secs = 3600  // 1小时超时
```

### 8.2 任务取消机制

用户仍可以随时取消正在执行的任务：

- REST API: `POST /api/tasks/{task_id}/cancel`
- gRPC: `CancelTask` RPC

### 8.3 大模型质量依赖

此改动依赖于大模型正确判断何时应该停止：

- ✅ 提示词中的**轮次参考指南**会引导大模型做出合理决策
- ✅ **执行统计摘要**提供决策依据
- ✅ 软性引导 + 硬性超时，双重保护

---

## 9. 迁移检查项

### 9.1 配置改动
- [ ] ✅ 标记 `max_reflection_rounds` 为 deprecated
- [ ] ✅ 标记 `max_step_retries` 为 deprecated
- [ ] ✅ 标记 `max_task_replanning_attempts` 为 deprecated
- [ ] ✅ 标记 `max_consecutive_failures` 为 deprecated
- [ ] ✅ 更新所有默认值为 `usize::MAX` 或 `u32::MAX`

### 9.2 循环逻辑改动
- [ ] ✅ 移除主反思循环中的轮数检查
- [ ] ✅ 移除连续失败次数检查
- [ ] ✅ 修改 `is_max_rounds_reached()` 始终返回 false

### 9.3 提示词改动
- [ ] ✅ 在反思提示词中添加轮次参考指南
- [ ] ✅ 在单步反思提示词中添加重试次数参考指南
- [ ] ✅ 在执行历史中添加统计摘要

### 9.4 统计信息
- [ ] ✅ 在 `ContextEngineeringEventBuilder` 中添加统计字段
- [ ] ✅ 实现统计信息更新方法
- [ ] ✅ 在执行历史格式化中包含统计摘要

---

## 下一步

阅读 [19-动态参数推断功能.md](./19-动态参数推断功能.md) 了解动态参数推断的详细实现。
