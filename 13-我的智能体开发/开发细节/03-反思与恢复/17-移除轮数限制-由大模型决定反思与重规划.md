# 移除轮数限制 - 由大模型决定反思与重规划

## 概述

本次改动移除了反思轮数和重新规划轮数的人为限制，将"是否继续反思"和"是否继续重新规划"的决策权完全交给大模型。

## 改动背景

### 原有问题

在原有设计中，系统通过以下配置项来限制反思和重新规划的次数：

- `max_reflection_rounds`: 最大反思轮次（默认 5 轮）
- `max_step_retries`: 单个步骤最大重试次数（默认 3 次）
- `max_task_replanning_attempts`: 任务级最大重新规划次数（默认 1 次）
- `max_consecutive_failures`: 最大连续失败次数（默认 3 次）

这种人为设定的轮数限制存在以下问题：

1. **缺乏灵活性**：不同任务的复杂度不同，固定的轮数限制可能导致简单任务浪费资源，复杂任务提前终止
2. **无法适应上下文**：大模型在反思过程中能够判断当前问题是否可以通过继续尝试解决，但人为限制忽略了这一信息
3. **决策割裂**：反思结果中的 `should_replan` 字段本就是大模型对是否继续的判断，再叠加轮数限制造成逻辑冗余

### 改动目标

- 移除所有人为设定的轮数限制
- 是否继续反思完全由大模型的 `should_replan` 字段决定
- 是否继续重试/重规划完全由大模型的 `suggested_action` 决定
- 保留配置项用于向后兼容，但实际不再生效

---

## 核心改动

### 1. Task 结构体（task_state.rs）

**文件位置**: `src/state/task_state.rs`

```rust
// 修改前
pub max_rounds: u32,

// 修改后
/// 最大轮次（已弃用，保留用于向后兼容，实际不再用于限制轮数）
/// 是否继续反思/重新规划完全由大模型决定
#[serde(default = "default_max_rounds")]
pub max_rounds: u32,

fn default_max_rounds() -> u32 {
    u32::MAX // 默认无限制
}
```

`is_max_rounds_reached()` 方法修改为始终返回 `false`：

```rust
#[deprecated(note = "轮数限制已移除，是否继续由大模型决定")]
pub fn is_max_rounds_reached(&self) -> bool {
    // 始终返回 false，不再限制轮数
    // 是否继续反思/重新规划完全由大模型的 should_replan 决定
    false
}
```

### 2. ReflectionConfig 配置（config/mod.rs）

**文件位置**: `src/config/mod.rs`

所有轮数限制配置项标记为弃用，默认值设为 `usize::MAX`：

```rust
pub struct ReflectionConfig {
    /// 单个步骤最大重试次数（已弃用，保留用于向后兼容）
    #[deprecated(note = "轮数限制已移除，是否继续重试由大模型决定")]
    pub max_step_retries: usize,

    /// 任务级别最大重新规划次数（已弃用，保留用于向后兼容）
    #[deprecated(note = "轮数限制已移除，是否继续重新规划由大模型决定")]
    pub max_task_replanning_attempts: usize,

    // ... 其他弃用字段
}

fn default_max_step_retries() -> usize {
    usize::MAX // 无限制，由大模型决定
}

fn default_max_task_replanning_attempts() -> usize {
    usize::MAX // 无限制，由大模型决定
}
```

### 3. OrchestratorConfig 配置

**文件位置**: `src/config/mod.rs` 和 `src/core/orchestrator.rs`

```rust
/// 最大反思轮次（已弃用，保留用于向后兼容）
#[deprecated(note = "轮数限制已移除，是否继续反思由大模型决定")]
pub max_reflection_rounds: u32,

fn default_max_reflection_rounds() -> u32 {
    u32::MAX // 无限制，由大模型决定
}
```

### 4. 核心循环逻辑（orchestrator.rs）

**文件位置**: `src/core/orchestrator.rs`

#### 4.1 主反思循环

移除最大轮次检查和连续失败检查：

```rust
// 修改前
if task.is_max_rounds_reached() {
    return self.generate_final_output(task);
}
if consecutive_failures >= MAX_CONSECUTIVE_FAILURES {
    return Err(...);
}

// 修改后
// 注意：最大轮次检查已移除
// 是否继续反思完全由大模型通过 should_replan 字段决定
```

#### 4.2 循环终止条件

移除 `is_max_rounds_reached()` 检查：

```rust
// 修改前
let should_terminate = !reflection.should_replan
    || task.is_max_rounds_reached()
    || is_quality_sufficient;

// 修改后
// 完全由大模型的 should_replan 决定
let should_terminate = !reflection.should_replan || is_quality_sufficient;
```

#### 4.3 步骤级反思逻辑

移除步骤重试次数限制：

```rust
// 修改前
if step_retry_count >= max_step_retries {
    // 强制触发任务重新规划
}

// 修改后
// 注意：步骤重试次数限制已移除
// 是否继续重试完全由大模型在单步反思时决定（通过 suggested_action）
```

#### 4.4 任务重新规划逻辑

移除重新规划次数限制：

```rust
// 修改前
if task_replan_count >= max_task_replans {
    return Err("任务重新规划次数达到上限");
}

// 修改后
// 注意：任务重新规划次数限制已移除
// 是否继续重新规划完全由大模型决定
```

---

## 配置文件改动

### config.dev.toml

```toml
[orchestrator]
# 最大反思轮次（已弃用，由大模型决定是否继续反思）
# 保留此配置项仅用于向后兼容，实际不再生效
# max_reflection_rounds = 5

[reflection]
# 是否启用步骤级反思
enable_step_level_reflection = true

# ==================== 以下配置项已弃用 ====================
# 是否继续反思/重试/重新规划完全由大模型决定
# 保留这些配置项仅用于向后兼容，实际不再生效

# 最大连续失败次数（已弃用，由大模型决定是否继续）
# max_consecutive_failures = 3

# 最大重新规划次数（已弃用，由大模型决定是否继续）
# max_replanning_attempts = 3
```

### config.prod.toml

同样的改动应用于生产环境配置。

---

## 决策流程变化

### 修改前：人为限制 + 大模型建议

```
┌─────────────────────────────────────────────────────────────┐
│                     反思循环                                  │
├─────────────────────────────────────────────────────────────┤
│ 1. 检查是否达到最大轮次 → 是 → 强制终止                        │
│ 2. 检查连续失败次数 → 超限 → 强制终止                          │
│ 3. 执行反思 → 获取 should_replan                             │
│ 4. should_replan && !达到轮数限制 → 继续                      │
└─────────────────────────────────────────────────────────────┘
```

### 修改后：完全由大模型决定

```
┌─────────────────────────────────────────────────────────────┐
│                     反思循环                                  │
├─────────────────────────────────────────────────────────────┤
│ 1. 执行反思 → 获取 should_replan                             │
│ 2. should_replan = true → 大模型认为需要继续 → 继续循环        │
│ 3. should_replan = false → 大模型认为已达最佳 → 终止循环       │
│ 4. is_quality_sufficient → 质量足够好 → 终止循环              │
└─────────────────────────────────────────────────────────────┘
```

---

## 单步反思决策流程

### 修改前

```
步骤失败 →
  检查 step_retry_count < max_step_retries ?
    是 → 根据 suggested_action 决策
    否 → 强制触发任务重新规划
```

### 修改后

```
步骤失败 →
  根据 suggested_action 决策:
    - RetryWithAdjustedParams → 参数调整重试
    - RetryWithAlternativeTool → 备选工具重试
    - ReplanEntireTask → 任务重新规划
    - StopExecution → 停止执行（需要人工介入）
```

---

## 相关代码位置

| 模块 | 文件 | 行号（约） | 改动说明 |
|------|------|-----------|---------|
| Task 结构体 | `src/state/task_state.rs` | 82-116 | 弃用 max_rounds 字段 |
| is_max_rounds_reached | `src/state/task_state.rs` | 208-217 | 始终返回 false |
| ReflectionConfig | `src/config/mod.rs` | 463-515 | 弃用轮数限制配置 |
| OrchestratorConfig | `src/config/mod.rs` | 234-243 | 弃用 max_reflection_rounds |
| OrchestratorConfig | `src/core/orchestrator.rs` | 368-386 | 弃用 max_reflection_rounds |
| 主反思循环 | `src/core/orchestrator.rs` | 917-951 | 移除轮数检查 |
| 循环终止条件 | `src/core/orchestrator.rs` | 1364-1376 | 移除 is_max_rounds_reached 检查 |
| 步骤级反思 | `src/core/orchestrator.rs` | 1658-1671 | 弃用轮数限制变量 |
| 重试决策 | `src/core/orchestrator.rs` | 2155-2167 | 移除重试次数限制 |
| 重新规划决策 | `src/core/orchestrator.rs` | 2410-2431 | 移除重新规划次数限制 |
| 单步反思提示词 | `src/llm/reflection_prompts.rs` | 486-514 | 添加重试次数参考指南 |
| 执行历史统计 | `src/core/orchestrator.rs` | 48-66 | 添加统计字段到构建器 |
| 统计信息更新 | `src/core/orchestrator.rs` | 107-127 | 添加统计信息更新方法 |
| 统计摘要格式化 | `src/core/orchestrator.rs` | 244-252 | 在执行历史中添加统计摘要 |

---

## 向后兼容性

1. **配置文件兼容**：所有弃用的配置项仍可在配置文件中设置，但不会生效
2. **API 兼容**：`max_rounds` 等字段仍然存在于 API 响应中，但值为 `u32::MAX`
3. **日志兼容**：轮数信息仍会记录在日志和 Kafka 中，用于监控

---

## 提示词中的轮次参考指南

为了帮助大模型更好地判断是否应该继续反思，在反思提示词中增加了轮次参考指南：

```
📊 轮次参考指南（仅供参考，最终由你决定）：
   • 1-3 轮：正常范围，可根据需要继续优化
   • 4-5 轮：建议审视是否有实质性改进空间
   • 6-10 轮：⚠️ 超出常规范围，请认真评估继续反思的价值
   • 10 轮以上：🚨 强烈建议停止，除非有明确的新解决思路

⚠️ 重要提醒：
   - 是否继续反思完全由你决定，没有强制的轮数限制
   - 但请注意：连续多轮未能解决问题时，继续反思往往只是重复无效尝试
   - 当你发现无法提供新见解时，应果断设置 should_replan = false
```

这样做的好处：
1. **软性引导而非硬性限制**：大模型可以看到当前轮次，并参考指南做出判断
2. **保留灵活性**：对于确实需要更多轮次的复杂任务，大模型可以继续
3. **避免无效循环**：当轮次过多时，提示词会引导大模型考虑是否应该停止

---

## 单步反思的重试次数参考指南

在单步反思提示词中也增加了类似的重试次数参考指南：

```
📊 重试次数参考指南（仅供参考，最终由你决定）：
   • 1-2 次：正常范围，可根据错误类型调整参数重试
   • 3 次：建议仔细分析是否是参数问题，还是需要换工具/重规划
   • 4-5 次：⚠️ 超出常规范围，很可能当前方案存在根本性问题
   • 5 次以上：🚨 强烈建议 replan 或 stop，除非有明确的新解决思路

⚠️ 重要提醒：
   - 是否继续重试完全由你决定，没有强制的次数限制
   - 但请注意：连续多次重试相同类型的错误，往往说明问题不在参数层面
   - 当无法提供新见解时，应果断建议 replan 或 stop
```

---

## 执行历史统计摘要

在执行历史（`ContextEngineeringEventBuilder.format_to_file()`）中增加了统计摘要，帮助大模型快速了解当前执行状态：

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 执行统计摘要
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  • 当前反思轮次: 第 X 轮
  • 累计步骤重试次数: X 次
  • 累计任务重规划次数: X 次
  • 成功步骤数: X
  • 失败步骤数: X
```

这样大模型在进行反思时可以：
1. 快速了解当前执行进度
2. 根据累计重试/重规划次数判断问题严重程度
3. 结合统计信息做出更合理的继续/停止决策

---

## 注意事项

1. **任务超时**：虽然移除了轮数限制，但仍有 `task_timeout_secs` 配置来防止任务无限执行
2. **任务取消**：用户仍可以随时取消正在执行的任务
3. **大模型质量**：此改动依赖于大模型正确判断何时应该停止，提示词中的轮次参考指南会引导大模型做出合理决策

---

## 改动日期

2026-01-12
