# 反思机制设计与实现文档

> **最后更新时间**: 2025-01-12
> **版本**: v2.0（重构版）
> **相关代码**: `src/llm/reflection_prompts.rs`, `src/core/reflector.rs`, `src/core/orchestrator.rs`

---

## 目录

1. [概述](#概述)
2. [反思机制架构](#反思机制架构)
3. [计划级反思](#计划级反思)
4. [单步反思](#单步反思)
5. [决策流程与策略](#决策流程与策略)
6. [代码实现映射](#代码实现映射)
7. [重构改进点](#重构改进点)
8. [使用示例](#使用示例)

---

## 概述

反思机制是任务编排系统的核心智能模块，负责在任务执行过程中和执行后进行问题诊断、决策和优化。系统采用**两级反思架构**：

- **单步反思（Step-level Reflection）**: 步骤失败时的实时诊断，快速响应单个步骤问题
- **计划级反思（Plan-level Reflection）**: 整轮执行后的全局复盘，优化整体执行方案

两者配合使用，构成完整的反思闭环，实现从局部到全局的智能优化。

---

## 反思机制架构

### 整体架构图

```
┌─────────────────────────────────────────────────────────┐
│                    任务编排流程                          │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
        ┌──────────────────────────────────┐
        │  Phase 1: 规划 (Planning)        │
        │  生成执行计划                    │
        └──────────────┬───────────────────┘
                       │
                       ▼
        ┌──────────────────────────────────┐
        │  Phase 2: 执行 (Execution)       │
        │  执行所有步骤                    │
        └──────────────┬───────────────────┘
                       │
                       ├─────────────────────────────┐
                       │                             │
                步骤成功 ✅                     步骤失败 ❌
                       │                             │
                       │                             ▼
                       │              ┌─────────────────────────┐
                       │              │  【单步反思】            │
                       │              │  实时诊断失败原因       │
                       │              └──────────┬──────────────┘
                       │                         │
                       │              ┌──────────┴──────────┐
                       │              │                     │
                       │         retry_with_params    retry_with_tool
                       │              │                     │
                       │              └─────────┬───────────┘
                       │                        │
                       │              ┌─────────┴──────────┐
                       │              │                    │
                       │           replan               stop
                       │              │                    │
                       │              ▼                    ▼
                       │      触发计划级重规划      停止任务
                       │
                       ▼
        ┌──────────────────────────────────┐
        │  Phase 3: 评估 (Evaluation)      │
        │  评估整体完成情况                │
        └──────────────┬───────────────────┘
                       │
                       ▼
              是否需要反思？
              (失败 or 分数<95%)
                       │
              ┌────────┴────────┐
              │                 │
             是                否
              │                 │
              ▼                 ▼
   ┌────────────────────┐   结束任务
   │  Phase 4: 反思     │
   │  【计划级反思】    │
   │  全局复盘优化      │
   └─────────┬──────────┘
             │
   ┌─────────┴──────────┐
   │                    │
   should_replan=true  should_replan=false
   │                    │
   ▼                    ▼
重新规划            结束任务
```

### 两级反思对比

| 维度 | 单步反思 | 计划级反思 |
|------|---------|-----------|
| **触发时机** | 单个步骤失败时 | 整轮执行完成后 |
| **分析范围** | 单个步骤 | 所有步骤 |
| **决策粒度** | 微观（步骤级） | 宏观（任务级） |
| **决策类型** | retry/replan/stop | should_replan (bool) |
| **响应速度** | 实时 | 事后 |
| **调整范围** | 当前步骤 | 整个计划 |
| **成本** | 低 | 高 |

---

## 计划级反思

### 1. 触发条件

**在 [orchestrator.rs:1318-1351](../../../src/core/orchestrator.rs:1318)** 中定义：

```rust
// 检查是否需要跳过反思阶段
let all_steps_succeeded = execution_result.failure_count == 0;
let correctness_excellent = evaluation.dimensions.correctness >= 95.0;

if all_steps_succeeded || correctness_excellent {
    // 跳过反思，直接完成
    return self.generate_final_output(task);
}

// 需要反思的情况：
// 1. 存在失败步骤 (failure_count > 0)
// 2. 正确性评分低于 95%
```

### 2. 反思决策流程

```
步骤1: 检查执行历史，识别重复模式
  └─> 是否存在重复失败（相同错误≥2次）？
      ├─ 是 → should_replan = false (停止反思)
      └─ 否 → 继续到步骤2

步骤2: 分析任务完成度
  └─> 任务是否已成功完成（完成度≥80%）？
      ├─ 是 → should_replan = false (任务完成)
      └─ 否 → 继续到步骤3

步骤3: 评估问题性质，选择应对策略
  └─> 问题是什么类型？
      ├─ 参数问题 → 策略1: 修复参数 (should_replan = true)
      ├─ 工具问题 → 策略2: 换工具/重规划 (should_replan = true)
      └─ 服务端/外部问题 → 策略3: 停止反思 (should_replan = false)
```

### 3. 三大应对策略

#### 策略1: 参数修复

**适用场景**: 错误明确指向参数问题

**识别特征**:
- HTTP 400 系列错误
- 错误信息包含"参数格式错误"、"参数值无效"、"缺少必需参数"
- 即使是 HTTP 500，但错误信息明确指向参数问题

**示例**:
```
❌ 错误信息："Bad Request: field 'client_id' is required"
→ 根因分析："缺少必需参数 client_id"
→ 改进建议："在请求中添加 client_id 参数，值为 'client_123'"
→ 反思结论："建议重新规划，修正参数后重试"
→ should_replan = true
```

**判断标准**: "修改传入的参数能否解决这个问题？" → 能 → 策略1

#### 策略2: 工具替换/重新规划

**适用场景**: 工具选择不当或任务分解有问题

**识别特征**:
- 工具本身无法满足任务需求
- 工具功能与任务目标不匹配
- 任务分解逻辑有问题，步骤之间依赖关系错误

**示例**:
```
❌ 场景："使用查询工具尝试创建资源，但查询工具不支持创建操作"
→ 根因分析："工具选择错误，查询工具无法执行创建操作"
→ 改进建议："使用创建工具（如 CreateClientTool）代替查询工具"
→ 反思结论："建议重新规划，更换为合适的工具"
→ should_replan = true

❌ 场景："步骤B依赖步骤A的输出，但步骤A在步骤B之后执行"
→ 根因分析："任务分解顺序错误，依赖关系倒置"
→ 改进建议："调整执行顺序，先执行步骤A，再执行步骤B"
→ 反思结论："建议重新规划，修正步骤依赖关系"
→ should_replan = true
```

**判断标准**: "当前工具/方案能否完成任务目标？" → 不能 → 策略2

#### 策略3: 停止反思并报告

**适用场景**: 外部/服务端问题，无法通过反思解决

**识别特征**:
- HTTP 500 系列错误，且错误信息指向服务端问题
- 服务不可用、连接超时、网络错误
- 进程启动失败、工具代码bug、依赖缺失
- 权限问题、资源配额不足
- 问题超出当前能力范围

**示例**:
```
❌ 错误信息："Service Unavailable: database connection timeout"
→ 根因分析："数据库服务不可用，属于外部依赖问题"
→ 反思结论："服务端错误，建议停止反思并通知管理员"
→ should_replan = false

❌ 场景："尝试5轮反思，均未能解决问题，且无新见解"
→ 根因分析："问题可能超出当前能力范围或需要外部介入"
→ 反思结论："建议停止反思，问题可能需要人工介入"
→ should_replan = false
```

**判断标准**: "问题是否由外部因素或服务端问题导致？" → 是 → 策略3

### 4. 输入信息

**在 [orchestrator.rs:3074-3091](../../../src/core/orchestrator.rs:3074)** 中构建反思上下文：

```rust
// 构建反思上下文信息
let mut reflection_context = ReflectionContext::new(None);

// 1. 用户提交的任务上下文
if let Some(ctx) = task_context {
    let user_context_text = self.format_task_context(ctx);
    reflection_context.set_user_context(user_context_text);
}

// 2. 执行历史（从上下文工程事件构建器获取）
if let Some(builder_lock) = self.context_engineering_builders.get(task_id) {
    let builder = builder_lock.read().await;
    let execution_history = builder.format_to_file();
    reflection_context.set_execution_history(execution_history);
}

// 3. 调用反思
self.reflector.reflect_with_context(
    task_description,      // 任务描述
    &plan_text,           // 原始计划文本
    evaluation,           // 评估结果
    current_round,        // 当前轮次
    max_rounds,           // 最大轮次（已弃用）
    &reflection_context,  // 反思上下文
    event_sender,
).await
```

### 5. 输出结果

```rust
pub struct ReflectionResult {
    pub reflection_id: String,
    pub should_replan: bool,           // 核心决策
    pub reflection_text: String,       // 反思内容
    pub root_causes: Vec<String>,      // 根本原因
    pub improvement_suggestions: Vec<String>,  // 改进建议
    pub lessons_learned: Vec<String>,  // 经验教训
}
```

---

## 单步反思

### 1. 触发条件

**在步骤执行失败时触发**，通常在 `parallel_executor.rs` 中调用：

```rust
// 步骤执行失败
match step_result {
    Err(e) => {
        // 触发单步反思
        let reflection = self.reflector.reflect_on_step_failure(
            step_id,
            tool_id,
            step_description,
            &error_message,
            &metadata,
            available_tools,
            task_type,
            execution_history,
            retry_count,
        ).await?;

        // 根据反思结果决定下一步行动
        match reflection.suggested_action.type {
            "retry_with_params" => { /* 修正参数后重试 */ },
            "retry_with_tool" => { /* 更换工具后重试 */ },
            "replan" => { /* 触发计划级重规划 */ },
            "stop" => { /* 停止整个任务 */ },
        }
    }
}
```

### 2. 诊断决策流程

```
步骤1: 检查执行历史，识别重复错误
  └─> 相同 tool_id 的错误是否出现 ≥2 次？
      ├─ 是 → suggested_action.type = "stop"
      └─ 否 → 继续到步骤2

步骤2: 分析错误类型
  └─> 错误信息指向什么？
      ├─ 参数问题 → 策略A: retry_with_params
      ├─ 工具选择问题 → 策略B: retry_with_tool 或 replan
      └─ 服务端/外部问题 → 策略C: stop
```

### 3. 三大应对策略

#### 策略A: 参数修复 (retry_with_params)

**适用场景**: 错误明确指向参数问题

**示例**:
```json
// 场景1：缺少必需参数
❌ 错误信息："Bad Request: Missing required field 'client_id'"
→ root_cause_category: "parameter_error"
→ root_cause: "缺少必需参数 client_id"
→ is_recoverable: true
→ suggested_action: {
    "type": "retry_with_params",
    "data": {
      "client_id": "client_123"  // 必须提供具体值
    }
  }
→ analysis: "错误信息明确指出缺少 client_id 参数，需要在请求中添加该参数。
             历史中未尝试过此方案，本次建议添加 client_id 参数重试。"

// 场景2：参数值超出范围
❌ 错误信息："Invalid parameter: timeout=500 exceeds maximum allowed value (300)"
→ root_cause_category: "parameter_error"
→ root_cause: "参数 timeout 值超出有效范围"
→ is_recoverable: true
→ suggested_action: {
    "type": "retry_with_params",
    "data": {
      "timeout": 300  // 修正为有效值
    }
  }
→ analysis: "timeout 参数值为 500，超过最大允许值 300。
             调整为 300 后应能解决问题。"
```

**⚠️ 关键要求**:
- data 字段**必须**包含具体的参数名和修正后的参数值
- **绝对禁止**返回空对象 `{}` 或占位符值
- 如果无法确定具体参数值，**必须**使用 "replan" 或 "stop"

#### 策略B: 工具替换/重新规划 (retry_with_tool/replan)

**适用场景**: 工具选择不当或需要调整整体方案

**示例**:
```json
// 场景1: retry_with_tool - 单步工具替换
❌ 场景："使用查询工具尝试创建资源，返回错误'不支持创建操作'"
→ root_cause_category: "tool_error"
→ root_cause: "工具选择错误，查询工具无法执行创建操作"
→ is_recoverable: true
→ suggested_action: {
    "type": "retry_with_tool",
    "data": {
      "tool_id": "create_client_tool"
    }
  }
→ analysis: "当前使用的是查询工具，但任务需要创建操作。
             【可用工具】列表中有 create_client_tool，建议使用该工具。"
→ alternative_solutions: ["使用 create_client_tool 创建客户端"]

// 场景2: replan - 需要调整整体执行步骤
❌ 场景："步骤执行顺序错误，依赖关系未满足"
→ root_cause_category: "decomposition_error"
→ root_cause: "任务分解逻辑错误，步骤依赖关系倒置"
→ is_recoverable: true
→ suggested_action: {
    "type": "replan",
    "data": "需要调整步骤执行顺序：先执行步骤A获取必需数据，再执行步骤B进行处理"
  }
→ analysis: "当前步骤B依赖步骤A的输出，但步骤A尚未执行。
             这是任务分解的问题，需要重新规划整体执行顺序。
             建议调整为：步骤A → 步骤B → 步骤C。"

// 场景3: replan - 需要拆分复杂步骤
❌ 场景："单个步骤包含多个操作，部分操作失败导致整个步骤失败"
→ root_cause_category: "decomposition_error"
→ root_cause: "任务分解粒度过粗，单个步骤职责过多"
→ is_recoverable: true
→ suggested_action: {
    "type": "replan",
    "data": "将当前步骤拆分为3个独立步骤：1)验证参数 2)创建资源 3)配置资源"
  }
→ analysis: "当前步骤尝试一次性完成验证、创建和配置，但验证阶段就失败了。
             建议将其拆分为多个独立步骤，每个步骤职责单一，便于定位和重试。"
```

**⚠️ 工具约束**:
- 备选工具**必须**从【可用工具】列表中选择
- **严禁**推荐列表之外的工具
- 如果没有合适的备选工具，必须选择 "stop" 或 "replan"

#### 策略C: 停止重试 (stop)

**适用场景**: 外部/服务端问题，无法通过重试解决

**示例**:
```json
// 场景1：服务端错误
❌ 错误信息："Service Unavailable: database connection failed"
→ root_cause_category: "server_error"
→ root_cause: "数据库连接失败，属于服务端问题"
→ is_recoverable: false
→ suggested_action: {
    "type": "stop",
    "data": "服务端错误，建议停止执行并通知管理员"
  }
→ analysis: "错误信息显示数据库连接失败，这是服务端基础设施问题，
             无法通过修改参数或更换工具解决。建议停止执行。"

// 场景2：权限问题
❌ 错误信息："Failed to start process: permission denied"
→ root_cause_category: "external_error"
→ root_cause: "权限不足，无法启动进程"
→ is_recoverable: false
→ suggested_action: {
    "type": "stop",
    "data": "权限问题，建议检查服务端配置"
  }
→ analysis: "进程启动失败，原因是权限不足。
             这需要管理员调整服务端权限配置，建议停止执行。"
```

### 4. 输出结果

```rust
pub struct StepReflectionResult {
    pub root_cause_category: String,  // 根因分类
    pub root_cause: String,            // 根本原因
    pub is_recoverable: bool,          // 是否可恢复
    pub confidence: u32,               // 置信度 (0-100)
    pub analysis: String,              // 详细分析
    pub suggested_action: SuggestedAction,  // 建议动作
    pub alternative_solutions: Vec<String>,  // 备选方案
}

pub struct SuggestedAction {
    pub action_type: String,  // retry_with_params / retry_with_tool / replan / stop
    pub data: serde_json::Value,  // 具体的修复数据
}
```

---

## 决策流程与策略

### 重复检测机制

两级反思都强化了重复检测，防止无限循环：

#### 计划级重复检测

```rust
// 在 reflection_prompts.rs 中定义
■ 重复失败的判定标准（满足任一即为重复）：
  1. 相同的错误类型在历史中出现过 2 次或以上
  2. 之前的反思已经提出过相同或类似的改进建议
  3. 相同的参数调整方案已经尝试过但未能解决问题
  4. 相同的工具以相同的方式失败过

■ 判定为重复失败时的强制行为：
  → 设置 should_replan = false（停止反思）
  → 在反思内容中明确说明：
     "⚠️ 重复失败检测：此问题已在执行历史中出现 N 次
      历史尝试：[简述之前的方案]
      结论：历史方案均未解决问题，建议停止反思"
```

#### 单步重复检测

```rust
// 强制检查清单（必须逐项检查）
☐ 1. 历史中是否已有对相同 tool_id 的失败记录？
☐ 2. 历史中的反思建议是否已被执行？
☐ 3. 当前错误与历史错误的本质区别是什么？
☐ 4. 你能提供什么历史中没有的新见解？

// 判定为重复错误时的强制行为（违反将导致无限循环）
🚨 suggested_action.type **必须且只能**是 "stop"
```

### 一致性检查

**计划级反思**:
- 根因类型 ↔ 应对策略 ↔ should_replan 值必须一致

**单步反思**:
1. `root_cause_category` ↔ `suggested_action.type` 一致性
   - parameter_error → retry_with_params
   - tool_error/decomposition_error → retry_with_tool 或 replan
   - server_error/external_error → stop

2. `is_recoverable` ↔ `root_cause_category` 一致性
   - parameter_error/tool_error/decomposition_error → true
   - server_error/external_error → false

3. `suggested_action.data` 完整性
   - retry_with_params → data 必须包含具体参数值（非空对象）
   - retry_with_tool → data 必须包含 tool_id（必须在可用工具列表中）
   - stop → data 必须包含停止原因说明
   - replan → data 可以为空或包含建议

4. 重复错误检测
   - 如果检测到重复错误 → suggested_action.type 必须是 "stop"

---

## 代码实现映射

### 核心文件

| 文件 | 功能 | 关键方法 |
|------|------|---------|
| `src/llm/reflection_prompts.rs` | 反思提示词管理 | `build_reflection_prompt()`<br>`build_step_reflection_prompt()` |
| `src/core/reflector.rs` | 反思执行器 | `reflect_with_context()`<br>`reflect_on_step_failure()` |
| `src/core/orchestrator.rs` | 任务编排器 | `execute_reflection_phase()`<br>`execute_task_iteration()` |
| `src/core/parallel_executor.rs` | 步骤执行器 | `execute_step()` (调用单步反思) |

### 调用链路

#### 计划级反思调用链

```
Orchestrator::execute_task_iteration()
  [src/core/orchestrator.rs:1200-1500]
  ↓
Orchestrator::execute_reflection_phase()
  [src/core/orchestrator.rs:3047]
  ↓
Reflector::reflect_with_context()
  [src/core/reflector.rs:429]
  ↓
ReflectionPromptBuilder::build_reflection_prompt()
  [src/llm/reflection_prompts.rs:926]
  ↓
LLM 调用
  ↓
解析 ReflectionResult
  └─ should_replan = true → 重新规划
  └─ should_replan = false → 结束任务
```

#### 单步反思调用链

```
ParallelExecutor::execute_step()
  [src/core/parallel_executor.rs]
  ↓
步骤执行失败
  ↓
Reflector::reflect_on_step_failure()
  [src/core/reflector.rs]
  ↓
ReflectionPromptBuilder::build_step_reflection_prompt()
  [src/llm/reflection_prompts.rs:981]
  ↓
LLM 调用
  ↓
解析 StepReflectionResult
  └─ retry_with_params → 修正参数重试
  └─ retry_with_tool → 更换工具重试
  └─ replan → 触发计划级重规划
  └─ stop → 停止任务
```

### 关键数据结构

```rust
// 反思上下文
pub struct ReflectionContext {
    pub task_type: Option<String>,
    pub user_context: Option<String>,
    pub execution_history: Vec<String>,
}

// 计划级反思结果
pub struct ReflectionResult {
    pub reflection_id: String,
    pub should_replan: bool,
    pub reflection_text: String,
    pub root_causes: Vec<String>,
    pub improvement_suggestions: Vec<String>,
    pub lessons_learned: Vec<String>,
}

// 单步反思结果
pub struct StepReflectionResult {
    pub root_cause_category: String,
    pub root_cause: String,
    pub is_recoverable: bool,
    pub confidence: u32,
    pub analysis: String,
    pub suggested_action: SuggestedAction,
    pub alternative_solutions: Vec<String>,
}

// 建议动作
pub struct SuggestedAction {
    pub action_type: String,  // retry_with_params/retry_with_tool/replan/stop
    pub data: serde_json::Value,
}
```

---

## 重构改进点

### v2.0 重构内容（2025-01-12）

#### 1. 清晰的决策流程

**改进前**：文字描述，缺乏结构，大模型难以理解

**改进后**：引入清晰的决策树和步骤式流程

```
计划级反思：3步决策流程
  步骤1: 重复检测 → 步骤2: 完成度评估 → 步骤3: 问题性质分类

单步反思：2步诊断流程
  步骤1: 重复检测 → 步骤2: 错误类型分析
```

#### 2. 策略边界明确

**改进前**：策略之间边界模糊，容易混淆

**改进后**：三大策略，每个策略有明确的：
- 识别特征
- 示例场景（包含完整的输入输出）
- 判断标准（核心问题）

#### 3. 丰富的示例

**改进前**：少量抽象示例，不够具体

**改进后**：每种策略都有多个具体场景示例，包括：
- 错误信息
- 根因分析
- 改进建议
- 完整的 JSON 输出格式

**示例数量**：
- 计划级反思：9个场景示例
- 单步反思：7个场景示例

#### 4. 强化的重复检测

**改进前**：描述不够强制，容易被忽略

**改进后**：
- 强制检查清单
- 违反规则的严重性警告
- 重复判定的具体标准
- 允许继续的严格条件

#### 5. 一致性检查

**改进前**：部分检查

**改进后**：四大一致性检查规则
1. root_cause_category ↔ suggested_action.type
2. is_recoverable ↔ root_cause_category
3. suggested_action.data 完整性
4. 重复错误检测结果一致性

#### 6. 参数修正强制要求

**改进前**：可能返回空对象或占位符

**改进后**：
- data 字段**必须**包含具体参数值
- **绝对禁止**返回空对象 `{}`
- 无法确定参数值时，必须使用 "replan" 或 "stop"

#### 7. 工具约束严格限制

**改进前**：可能推荐不存在的工具

**改进后**：
- 备选工具**必须**从可用工具列表中选择
- **严禁**推荐列表之外的工具
- 无合适工具时，必须 "stop" 或 "replan"

### 改进对比表

| 维度 | 重构前 | 重构后 |
|------|--------|--------|
| **决策流程** | 文字描述，缺乏结构 | 清晰的决策树，步骤明确 |
| **策略边界** | 模糊，容易混淆 | 三大策略，边界清晰 |
| **示例** | 少量抽象示例 | 16个具体场景示例 |
| **重复检测** | 描述不够强制 | 强制检查清单，违反将报错 |
| **参数修正** | 可能返回空值 | 强制要求提供具体参数值 |
| **工具约束** | 可能推荐不存在的工具 | 严格限制在可用工具列表内 |
| **一致性** | 部分检查 | 四大一致性检查 |

---

## 使用示例

### 示例1: 计划级反思 - 参数错误

**场景**：5个步骤执行完，3个成功，2个失败（参数错误）

```yaml
输入：
  任务描述: "创建客户端并配置基本参数"
  执行结果:
    - 步骤1: 验证权限 ✅
    - 步骤2: 检查资源 ✅
    - 步骤3: 创建客户端 ❌ (缺少 client_id 参数)
    - 步骤4: 配置参数 ❌ (timeout 超出范围)
    - 步骤5: 确认创建 ⏸️ (未执行)
  评估结果:
    整体完成度: 40%
    正确性评分: 60%

计划级反思输出：
  重复检测: 无重复
  任务完成度: 40% < 80%，未完成
  问题类型: 参数错误

  根因分析:
    - 步骤3缺少必需参数 client_id
    - 步骤4的 timeout 参数值超出有效范围

  改进建议:
    - 修正步骤3，添加 client_id 参数
    - 修正步骤4，将 timeout 调整为有效值

  should_replan: true  // 重新规划
```

### 示例2: 单步反思 - 工具选择错误

**场景**：步骤执行时选择了错误的工具

```yaml
输入：
  步骤ID: step_3
  工具ID: query_client_tool
  错误信息: "Operation not supported: this tool is read-only"

单步反思输出：
  {
    "root_cause_category": "tool_error",
    "root_cause": "工具选择错误，查询工具不支持创建操作",
    "is_recoverable": true,
    "confidence": 95,
    "analysis": "错误信息显示当前工具是只读的，不支持创建操作。
                 需要使用支持创建操作的工具。
                 【可用工具】列表中有 create_client_tool，建议使用该工具。",
    "suggested_action": {
      "type": "retry_with_tool",
      "data": {
        "tool_id": "create_client_tool"
      }
    },
    "alternative_solutions": [
      "使用 create_client_tool 创建客户端"
    ]
  }
```

### 示例3: 单步反思 - 重复错误检测

**场景**：相同错误在历史中出现2次

```yaml
输入：
  步骤ID: step_4
  工具ID: database_query_tool
  错误信息: "Connection timeout: failed to connect to database"
  执行历史:
    - 第1次失败: 同样的 tool_id，同样的错误
    - 反思建议: 调整连接超时参数
    - 第2次失败: 调整参数后仍然失败（当前）

单步反思输出：
  {
    "root_cause_category": "server_error",
    "root_cause": "数据库连接超时，属于服务端问题",
    "is_recoverable": false,
    "confidence": 90,
    "analysis": "⚠️ 重复错误检测：工具 [database_query_tool] 在执行历史中已失败 2 次，且错误信息实质相同。

                 历史已尝试方案：
                 - 第1次：调整连接超时参数，结果：仍然失败

                 结论：历史方案均未解决问题，这是服务端数据库连接问题，
                 无法通过修改参数解决。建议停止重试并通知管理员。",
    "suggested_action": {
      "type": "stop",
      "data": "检测到重复错误，相同错误已出现2次且历史方案均失败。
               这是服务端数据库连接问题，建议停止执行并通知管理员。"
    },
    "alternative_solutions": []
  }
```

---

## 附录

### 相关文档

- [反思提示词重构文档](../../docs/reflection_prompts_refactor.md)
- [上下文工程与执行历史](./上下文工程与执行历史设计文档.md)
- [任务编排流程](./任务编排流程详解.md)

### 代码位置

- 反思提示词：`src/llm/reflection_prompts.rs`
- 反思执行器：`src/core/reflector.rs`
- 任务编排器：`src/core/orchestrator.rs`
- 步骤执行器：`src/core/parallel_executor.rs`

### 更新历史

| 日期 | 版本 | 更新内容 |
|------|------|---------|
| 2025-01-12 | v2.0 | 重构反思提示词，添加清晰决策流程和丰富示例 |
| 2024-12-XX | v1.0 | 初始版本 |

---

**文档维护**: 如有问题或建议，请联系开发团队。
