# 反思与工具筛选协同机制总览

> **创建时间**: 2026-01-15
> **文档版本**: v1.0
> **文档类型**: 架构总览
> **适用读者**: 架构师、高级开发者

---

## 📋 目录
- [系统概述](#系统概述)
- [两级反思架构](#两级反思架构)
- [双模式工具筛选](#双模式工具筛选)
- [协同工作流程](#协同工作流程)
- [关键数据流转](#关键数据流转)
- [代码映射](#代码映射)

---

## 系统概述

### 核心理念

任务编排系统通过**反思机制**和**工具筛选机制**的深度协同，实现了智能的失败处理和自动恢复能力：

```
┌────────────────────────────────────────────────────────────────┐
│                    反思与工具筛选协同架构                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ┌──────────────┐        ┌──────────────┐                     │
│  │ 单步反思      │───────→│ 整体反思      │                     │
│  │ (Step-Level) │        │ (Overall)    │                     │
│  └──────────────┘        └──────┬───────┘                     │
│       │                         │                             │
│       │ 简单问题                │ 复杂问题                      │
│       ↓                         ↓                             │
│  ┌──────────────┐        ┌──────────────┐                     │
│  │ 参数调整/    │        │ 重新规划      │                     │
│  │ 工具替换     │        │              │                     │
│  └──────────────┘        └──────┬───────┘                     │
│                                 │                             │
│                                 ↓                             │
│                         ┌────────────────┐                    │
│                         │ 双模式工具筛选  │                    │
│                         │ • 首次规划筛选  │                    │
│                         │ • 重新规划筛选  │                    │
│                         └────────────────┘                    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 设计亮点

1. **分层决策**：单步反思处理局部问题，整体反思处理全局问题
2. **上下文传递**：执行历史、反思结果、工具效果完整传递
3. **智能筛选**：根据执行反馈动态调整工具选择
4. **避免重复**：从失败中学习，不重复相同的错误
5. **细粒度策略**：支持5种重规划策略，精准恢复

---

## 两级反思架构

### 第一级：单步反思 (Step-Level Reflection)

**职责**：快速分析单个步骤的失败原因，提供即时恢复方案

**核心文件**：
- `src/core/reflector.rs:1072-1288` - `reflect_on_single_step()` 方法
- `src/llm/reflection_prompts.rs:790-1459` - 单步反思提示词

**决策输出** (`StepAction` 枚举):
```rust
pub enum StepAction {
    // 简单问题 - 直接恢复
    RetryWithAdjustedParams(HashMap<String, String>),  // 参数调整后重试
    RetryWithAlternativeTool(String),                  // 使用备选工具

    // 中等问题 - 局部重规划
    ReplanEntireTask,                                  // 触发任务重规划

    // 复杂问题 - 交给整体反思决策
    TriggerOverallReflection(String),                  // 🆕 v1.2：触发整体反思
}
```

**关键特性**：
- ✅ 3章节结构化输出（执行历史审查、错误分析、建议方案）
- ✅ 避免重复反思机制（检查执行历史，避免重复分析相同问题）
- ✅ 单步反思**不直接停止任务**，而是将决策权交给整体反思

### 第二级：整体反思 (Overall Reflection)

**职责**：全局分析任务执行情况，决定是否值得重新规划

**核心文件**：
- `src/core/reflector.rs:376-511` - `perform_overall_reflection()` 方法
- `src/llm/reflection_prompts.rs:323-788` - 整体反思提示词

**决策流程**:
```
1. 检查重复失败 → 如果问题重复出现 → 停止
2. 评估任务完成度 → 如果 ≥80% → 停止
3. 分类问题类型：
   ├─ 参数错误 → 重新规划（调整参数）
   ├─ 工具选择错误 → 重新规划（更换工具）
   ├─ 分解错误 → 重新规划（优化步骤）
   └─ 外部错误/不可恢复 → 停止
```

**决策输出** (`ReflectionResult` 结构):
```rust
pub struct ReflectionResult {
    // 问题分析
    pub root_causes: Vec<String>,
    pub incorrect_assumptions: Vec<String>,

    // 改进方案
    pub alternative_approaches: Vec<String>,
    pub optimization_suggestions: Vec<String>,

    // 经验总结
    pub lessons_learned: Vec<String>,

    // 重规划决策 - 关键字段
    pub should_replan: bool,  // LLM决定是否重新规划

    // 🆕 v1.2：细粒度重规划策略
    pub replanning_strategy: Option<ReplanningStrategy>,
}
```

**关键特性**：
- ✅ 5章节结构化输出（执行概览、问题诊断、改进方案、决策结论、经验总结）
- ✅ **LLM自主决定**是否重新规划（无硬编码轮数限制）
- ✅ 提供细粒度重规划策略建议

### 细粒度重规划策略 (v1.2 新增)

整体反思可以建议具体的重规划策略，而不是简单的"重新规划"：

```rust
pub enum ReplanningStrategy {
    // 完整重新规划
    FullReplan,

    // 从指定步骤开始重新规划
    ReplanFromStep {
        step_id: String,
        reason: String
    },

    // 跳过不必要的步骤
    SkipSteps {
        step_ids: Vec<String>,
        reason: String
    },

    // 添加补救步骤
    AddRemediationSteps {
        suggestions: Vec<String>
    },

    // 调整步骤间依赖关系
    AdjustDependencies {
        adjustments: Vec<String>
    },
}
```

**策略适用场景**：

| 策略 | 适用场景 | 示例 |
|------|---------|------|
| `FullReplan` | 整体方案有根本性问题 | 工具选择方向完全错误，需要重新设计 |
| `ReplanFromStep` | 前面步骤成功，从失败点重新规划 | 前5步成功，第6步失败，从第6步重新规划 |
| `SkipSteps` | 某些步骤被证明不必要 | 发现预处理步骤可以跳过 |
| `AddRemediationSteps` | 需要添加额外步骤修复问题 | 需要添加格式转换步骤 |
| `AdjustDependencies` | 步骤依赖关系需要调整 | 步骤B应该依赖步骤C而不是步骤A |

---

## 双模式工具筛选

### 核心理念

工具筛选是两阶段规划的第一步，决定了任务可用的工具集。系统根据场景区分两种筛选模式：

```
┌────────────────────────────────────────────────────────────┐
│                   双模式工具筛选                            │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  ┌──────────────────┐          ┌──────────────────┐       │
│  │ 首次规划工具筛选  │          │ 重新规划工具筛选  │       │
│  │ (Predictive)    │          │ (Corrective)    │       │
│  └─────────┬────────┘          └─────────┬────────┘       │
│            │                             │                │
│            │ 基于需求预测                 │ 基于执行反馈    │
│            ↓                             ↓                │
│  ┌──────────────────┐          ┌──────────────────┐       │
│  │ • 语义匹配        │          │ • 保留成功工具    │       │
│  │ • 意图识别        │          │ • 替换失败工具    │       │
│  │ • 完整覆盖        │          │ • 补充缺失能力    │       │
│  │ • 宁可多选        │          │ • 避免重复失败    │       │
│  └──────────────────┘          └──────────────────┘       │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

### 模式1：首次规划工具筛选 (Initial Planning Tool Selection)

**场景**：首次规划任务，没有执行历史可参考

**核心文件**：
- `src/llm/selection_prompts.rs:117-265` - 首次规划工具筛选提示词
- `src/core/planner.rs:481-611` - `select_relevant_tools()` 方法

**输入上下文**：
- 任务描述
- TaskContext（对话历史、相关文档、用户偏好）
- 元数据

**筛选策略** - 双阶段匹配：

**阶段1：意图识别**
```
如果任务描述包含 "意图: XXX" →
  优先选择「分类 = XXX」的工具（主工具集）
```

**阶段2：语义补充**
```
如果分类工具不足 →
  从其他分类选择语义相似度 ≥ 75% 的工具（补充工具集）
```

**输出格式**：
```json
{
  "selected_tool_ids": ["tool1", "tool2", ...],
  "task_type": "工具管理|自动建模|...",
  "selection_confidence": 85,
  "brief_reasoning": "基于意图选择3个工具管理工具 + 语义补充2个BIM工具"
}
```

### 模式2：重新规划工具筛选 (Replanning Tool Selection)

**场景**：任务执行失败后重新规划，有丰富的执行反馈

**核心文件**：
- `src/llm/selection_prompts.rs:267-461` - 重新规划工具筛选提示词
- `src/core/planner.rs:1845-2071` - `select_tools_for_replanning()` 方法

**输入上下文**（比首次规划多）：
- 任务描述
- 元数据
- **之前选择的工具及执行效果** (`PreviousToolInfo`)
- **执行历史** (格式化的步骤执行记录)
- **反思分析结果** (失败原因分析)
- **整体反思指导** (改进建议)

**筛选策略** - 修正性思维：

```
第1步：分析之前的工具选择问题
  ├─ 哪些工具失败了？为什么失败？
  ├─ 哪些工具成功了？应该保留？
  └─ 是否存在能力缺口？

第2步：采纳整体反思的改进建议
  └─ 优先选择反思建议的工具

第3步：重新筛选工具集
  ├─ ✅ 保留：之前成功的工具
  ├─ 🔄 替换：失败工具 → 功能相似但更可靠的工具
  ├─ ➕ 补充：之前遗漏的工具
  └─ ❌ 移除：无效或不必要的工具

第4步：验证新工具集
  ├─ 是否解决了能力缺口？
  ├─ 是否避开了失败点？
  └─ 是否采纳了反思建议？
```

**输出格式**（比首次规划多）：
```json
{
  "selected_tool_ids": ["tool1", "tool2", ...],
  "task_type": "工具管理|自动建模|...",
  "selection_confidence": 90,
  "brief_reasoning": "保留2个成功工具，替换1个失败工具，新增1个格式验证工具",
  "changes_from_previous": {  // 🆕 变更追踪
    "kept_tools": ["tool_a", "tool_b"],
    "replaced_tools": [
      {"old": "tool_x", "new": "tool_y", "reason": "不支持新格式"}
    ],
    "added_tools": [
      {"tool_id": "tool_z", "reason": "反思建议添加格式验证"}
    ],
    "removed_tools": []
  }
}
```

---

## 协同工作流程

### 完整流程图

```
┌──────────────────────────────────────────────────────────────┐
│               反思与工具筛选协同工作流程                        │
└──────────────────────────────────────────────────────────────┘

【首次执行】
  1. 首次规划工具筛选（预测性）
     ├─ 输入：任务描述 + 上下文 + 元数据
     └─ 输出：工具集 A

  2. 任务分解（两阶段规划的第二步）
     └─ 基于工具集 A 生成执行计划

  3. 执行步骤
     └─ 使用工具集 A 中的工具

  4. 步骤失败 → 触发单步反思
     ├─ 简单问题 → RetryWithAdjustedParams → 继续执行
     ├─ 工具问题 → RetryWithAlternativeTool → 继续执行
     └─ 复杂问题 → TriggerOverallReflection → 进入【整体反思阶段】

【整体反思阶段】
  5. 整体反思分析
     ├─ 输入：完整执行历史 + 工具效果
     ├─ 分析：问题根源、改进方案、是否值得重新规划
     └─ 输出：
         ├─ should_replan = false → 停止任务
         └─ should_replan = true → 进入【重新规划阶段】

【重新规划阶段】
  6. 重新规划工具筛选（修正性）
     ├─ 输入：任务描述 + 执行历史 + 反思结果 + 之前工具效果
     ├─ 分析：
     │   ├─ 保留成功工具
     │   ├─ 替换失败工具
     │   └─ 补充缺失能力
     └─ 输出：工具集 B（优化后）

  7. 任务重新分解
     └─ 基于工具集 B 生成新执行计划

  8. 重新执行
     └─ 使用工具集 B 中的工具

【循环判断】
  9. 如果再次失败 → 返回步骤 4（单步反思）
     └─ LLM 基于统计信息（轮次、重试次数）决定是否继续
```

### 关键决策点

| 决策点 | 决策者 | 依据 | 可能结果 |
|--------|--------|------|---------|
| **单步反思** | LLM (单步反思) | 失败原因类型 | 参数调整/工具替换/触发整体反思 |
| **是否重新规划** | LLM (整体反思) | 完成度、问题类型、可恢复性 | should_replan: true/false |
| **重规划策略** | LLM (整体反思) | 问题根源、能力缺口 | FullReplan/ReplanFromStep/... |
| **工具筛选调整** | LLM (工具筛选) | 执行反馈、反思建议 | 保留/替换/补充/移除工具 |

---

## 关键数据流转

### 数据结构传递链

```
┌────────────────────────────────────────────────────────────────┐
│                       数据流转全景                              │
└────────────────────────────────────────────────────────────────┘

【执行阶段】
  ExecutionContext
    └─ step_results: Vec<StepExecutionResult>
        ├─ tool_id: 使用的工具ID
        ├─ is_success: 是否成功
        ├─ output: 执行输出
        └─ error_message: 失败原因

【单步反思】
  ReflectionContext (输入)
    ├─ task_description: 任务描述
    ├─ successful_steps: 成功步骤列表
    └─ failed_step: 失败步骤详情

  StepReflection (输出)
    ├─ suggested_action: StepAction
    ├─ adjusted_parameters: 调整后的参数
    └─ alternative_tool_id: 备选工具

【整体反思】
  OverallReflectionContext (输入)
    ├─ execution_history: 格式化的执行历史
    ├─ task_replan_count: 重规划次数
    └─ current_round: 当前轮次

  ReflectionResult (输出)
    ├─ should_replan: 是否重新规划
    ├─ replanning_strategy: 重规划策略
    └─ alternative_approaches: 改进建议

【重新规划工具筛选】
  ReplanningToolSelectionContext (输入)
    ├─ previous_tools: Vec<PreviousToolInfo>  // 🔑 关键
    │   ├─ tool_id: 工具ID
    │   ├─ execution_status: Success/Failed
    │   ├─ failure_reason: 失败原因
    │   └─ execution_summary: 执行摘要
    ├─ execution_history: 完整执行历史
    ├─ reflection_analysis: 反思分析结果
    └─ overall_reflection_guidance: 整体反思指导

  ToolSelectionResult (输出)
    ├─ selected_tool_ids: 新工具集
    └─ changes_from_previous: 变更追踪
        ├─ kept_tools: 保留的工具
        ├─ replaced_tools: 替换的工具
        ├─ added_tools: 新增的工具
        └─ removed_tools: 移除的工具
```

### 关键数据结构

#### 1. PreviousToolInfo (工具执行效果)

**位置**：`src/llm/selection_prompts.rs:20-77`

```rust
pub struct PreviousToolInfo {
    pub tool_id: String,
    pub tool_name: String,
    pub execution_status: String,  // "Success" | "Failed" | "NotUsed"
    pub failure_reason: Option<String>,
    pub execution_summary: Option<String>,
}
```

**收集位置**：`src/core/orchestrator.rs:2916-2924` (重新规划准备阶段)

#### 2. ReplanningToolSelectionContext (重新规划上下文)

**位置**：`src/llm/selection_prompts.rs:79-118`

```rust
pub struct ReplanningToolSelectionContext {
    pub previous_tools: Vec<PreviousToolInfo>,
    pub execution_history: String,
    pub reflection_analysis: String,
    pub overall_reflection_guidance: Option<String>,
}
```

#### 3. ReplanningStrategy (重规划策略)

**位置**：`src/llm/replanning_prompts.rs:23-43`

```rust
pub enum ReplanningStrategy {
    FullReplan,
    ReplanFromStep { step_id: String, reason: String },
    SkipSteps { step_ids: Vec<String>, reason: String },
    AddRemediationSteps { suggestions: Vec<String> },
    AdjustDependencies { adjustments: Vec<String> },
}
```

#### 4. OverallReflectionGuidance (整体反思指导)

**位置**：`src/llm/replanning_prompts.rs:45-57`

```rust
pub struct OverallReflectionGuidance {
    pub root_causes: Vec<String>,
    pub incorrect_assumptions: Vec<String>,
    pub alternative_approaches: Vec<String>,
    pub lessons_learned: Vec<String>,
    pub replanning_strategy: Option<ReplanningStrategy>,
}
```

**传递路径**：
```
ReflectionResult (整体反思输出)
  → OverallReflectionGuidance
  → format_overall_reflection_guidance() (格式化为文本)
  → ReplanningToolSelectionContext.overall_reflection_guidance
  → 重新规划工具筛选提示词
```

---

## 代码映射

### 反思模块

| 功能 | 文件 | 行号 | 说明 |
|------|------|------|------|
| 单步反思方法 | `src/core/reflector.rs` | 1072-1288 | `reflect_on_single_step()` |
| 整体反思方法 | `src/core/reflector.rs` | 376-511 | `perform_overall_reflection()` |
| StepAction 枚举 | `src/core/reflector.rs` | 52-63 | 单步反思动作 |
| ReflectionResult 结构 | `src/core/reflector.rs` | 138-209 | 整体反思结果 |
| 单步反思提示词 | `src/llm/reflection_prompts.rs` | 790-1459 | 3章节结构 |
| 整体反思提示词 | `src/llm/reflection_prompts.rs` | 323-788 | 5章节结构 |
| 策略解析逻辑 | `src/core/reflector.rs` | 648-836 | `parse_replanning_strategy()` |

### 工具筛选模块

| 功能 | 文件 | 行号 | 说明 |
|------|------|------|------|
| 首次筛选提示词 | `src/llm/selection_prompts.rs` | 117-265 | 预测性筛选 |
| 重新筛选提示词 | `src/llm/selection_prompts.rs` | 267-461 | 修正性筛选 |
| 首次筛选方法 | `src/core/planner.rs` | 481-611 | `select_relevant_tools()` |
| 重新筛选方法 | `src/core/planner.rs` | 1845-2071 | `select_tools_for_replanning()` |
| PreviousToolInfo | `src/llm/selection_prompts.rs` | 20-77 | 工具执行效果 |
| ReplanningContext | `src/llm/selection_prompts.rs` | 79-118 | 重新规划上下文 |

### 编排器集成

| 功能 | 文件 | 行号 | 说明 |
|------|------|------|------|
| 单步反思触发 | `src/core/orchestrator.rs` | 2458-2557 | 步骤失败时触发 |
| 整体反思触发 | `src/core/orchestrator.rs` | 2580-2673 | TriggerOverallReflection 处理 |
| 工具效果收集 | `src/core/orchestrator.rs` | 2916-2924 | 收集 PreviousToolInfo |
| 重新规划调用 | `src/core/orchestrator.rs` | 2947-2958 | 传递 previous_tools |

### 重规划策略

| 功能 | 文件 | 行号 | 说明 |
|------|------|------|------|
| ReplanningStrategy | `src/llm/replanning_prompts.rs` | 23-43 | 策略枚举定义 |
| OverallReflectionGuidance | `src/llm/replanning_prompts.rs` | 45-57 | 指导信息结构 |
| 格式化指导信息 | `src/llm/replanning_prompts.rs` | 184-264 | `format_overall_reflection_guidance()` |

---

## 相关文档

### 深入阅读

- [19-反思机制设计与实现文档.md](./19-反思机制设计与实现文档.md) - 反思机制详细设计
- [21-单步反思触发整体反思与细粒度重规划策略.md](./21-单步反思触发整体反思与细粒度重规划策略.md) - v1.2 更新说明
- [22-反思输出结构化优化.md](./22-反思输出结构化优化.md) - 反思输出格式
- [23-双模式工具筛选提示词设计.md](../02-规划系统/23-双模式工具筛选提示词设计.md) - 工具筛选提示词
- [24-双模式工具筛选集成实现说明.md](../02-规划系统/24-双模式工具筛选集成实现说明.md) - 实现细节

### 架构相关

- [04-两阶段规划架构与实现.md](../02-规划系统/4-两阶段规划架构与实现.md) - 两阶段规划总览
- [17-移除轮数限制-由大模型决定反思与重规划.md](./17-移除轮数限制-由大模型决定反思与重规划.md) - 智能轮数管理
- [20-plan-with-files模式-执行历史作为单一真理来源.md](../02-规划系统/20-plan-with-files模式-执行历史作为单一真理来源.md) - 执行历史管理

---

## 总结

### 系统优势

1. **智能决策**：LLM 基于全局视角自主决定恢复策略
2. **精准恢复**：细粒度重规划策略，避免"一刀切"
3. **避免重复**：工具效果追踪，不重复失败的选择
4. **上下文丰富**：完整的执行反馈传递给LLM
5. **分层处理**：简单问题快速恢复，复杂问题深度分析

### 设计原则

- ✅ **单一真理来源**：执行历史是所有决策的基础
- ✅ **职责分离**：单步反思处理局部，整体反思处理全局
- ✅ **LLM驱动**：决策由LLM基于上下文做出，非硬编码规则
- ✅ **渐进式恢复**：从简单到复杂的恢复策略层次
- ✅ **学习改进**：从失败中学习，不断优化工具选择

---

**最后更新**: 2026-01-15
**文档版本**: v1.0
**维护者**: Task Orchestration Team
