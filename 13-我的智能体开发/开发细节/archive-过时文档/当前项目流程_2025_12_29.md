# ä»»åŠ¡ç¼–æ’æœåŠ¡ - å½“å‰é¡¹ç›®æ‰§è¡Œæµç¨‹è¯¦è§£

> æ–‡æ¡£ç‰ˆæœ¬: 2025-12-29
> åˆ†æ”¯ç‰ˆæœ¬: parallel_execution_version
> é¡¹ç›®åç§°: Task Orchestration Service
> æ ¸å¿ƒç‰¹æ€§: Reflective Planning + æ™ºèƒ½å¹¶è¡Œæ‰§è¡Œ

---

## ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
2. [æ ¸å¿ƒæ¶æ„](#2-æ ¸å¿ƒæ¶æ„)
3. [å®Œæ•´æ‰§è¡Œæµç¨‹](#3-å®Œæ•´æ‰§è¡Œæµç¨‹)
4. [æ ¸å¿ƒç»„ä»¶è¯¦è§£](#4-æ ¸å¿ƒç»„ä»¶è¯¦è§£)
5. [å¹¶è¡Œæ‰§è¡Œæœºåˆ¶](#5-å¹¶è¡Œæ‰§è¡Œæœºåˆ¶)
6. [åæ€ä¸é‡è§„åˆ’æœºåˆ¶](#6-åæ€ä¸é‡è§„åˆ’æœºåˆ¶)
7. [é…ç½®ç³»ç»Ÿ](#7-é…ç½®ç³»ç»Ÿ)
8. [æœåŠ¡å‘ç°ä¸é›†æˆ](#8-æœåŠ¡å‘ç°ä¸é›†æˆ)

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®å®šä½

ä»»åŠ¡ç¼–æ’æœåŠ¡ï¼ˆTask Orchestration Serviceï¼‰æ˜¯ä¸€ä¸ªåŸºäº **Reflective Planning** ç†å¿µçš„ç”Ÿäº§çº§ä»»åŠ¡ç¼–æ’ç³»ç»Ÿï¼Œä¸“ä¸ºå¤æ‚çš„å¤šæ­¥éª¤ä»»åŠ¡è‡ªåŠ¨åŒ–è®¾è®¡ã€‚

### 1.2 æ ¸å¿ƒèƒ½åŠ›

- **æ™ºèƒ½ä»»åŠ¡è§„åˆ’**: åŸºäºLLMçš„ä¸¤é˜¶æ®µè§„åˆ’ï¼Œå…ˆç­›é€‰å·¥å…·å†ç”Ÿæˆæ‰§è¡Œè®¡åˆ’
- **å¹¶è¡Œæ‰§è¡Œä¼˜åŒ–**: è‡ªåŠ¨è¯†åˆ«æ— ä¾èµ–æ­¥éª¤ï¼Œæ™ºèƒ½å¹¶è¡Œæ‰§è¡Œæå‡æ€§èƒ½
- **è‡ªé€‚åº”åæ€**: æ”¯æŒä»»åŠ¡çº§å’Œæ­¥éª¤çº§åæ€ï¼Œè‡ªåŠ¨è°ƒæ•´æ‰§è¡Œç­–ç•¥
- **æœåŠ¡å‘ç°é›†æˆ**: æ”¯æŒConsulæœåŠ¡å‘ç°å’Œé™æ€ç«¯ç‚¹ä¸¤ç§æ¨¡å¼
- **æµå¼å“åº”**: æ”¯æŒLLMæµå¼è¾“å‡ºï¼Œæä¾›å®æ—¶è¿›åº¦åé¦ˆ
- **å…¨é“¾è·¯è¿½è¸ª**: Kafkaæ—¥å¿—å®¡è®¡ï¼Œè°ƒè¯•æ—¥å¿—ï¼Œå¤šå±‚çº§ç›‘æ§

### 1.3 æŠ€æœ¯æ ˆ

- **è¯­è¨€**: Rust 2021 Edition
- **Webæ¡†æ¶**: Axum + Tower
- **RPC**: gRPC (Tonic + Prost)
- **LLMé›†æˆ**: ç»Ÿä¸€å®¢æˆ·ç«¯ï¼ˆHTTP/gRPCåŒæ¨¡å¼ï¼‰
- **æœåŠ¡å‘ç°**: Consulï¼ˆå¯é€‰ï¼‰
- **æ¶ˆæ¯é˜Ÿåˆ—**: Kafkaï¼ˆå¯é€‰ï¼‰
- **å¹¶å‘**: Tokioå¼‚æ­¥è¿è¡Œæ—¶ + DashMap + Semaphore

---

## 2. æ ¸å¿ƒæ¶æ„

### 2.1 åˆ†å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   HTTP/gRPC API                     â”‚
â”‚            (Axum Router + Tonic Server)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Orchestrator                        â”‚
â”‚          (æ ¸å¿ƒç¼–æ’å™¨ - åè°ƒæ‰€æœ‰ç»„ä»¶)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚              â”‚              â”‚              â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
    â”‚ Plannerâ”‚    â”‚Executor â”‚    â”‚Evaluatorâ”‚    â”‚Reflectorâ”‚
    â”‚(è§„åˆ’å™¨) â”‚    â”‚(æ‰§è¡Œå™¨)  â”‚    â”‚(è¯„ä¼°å™¨)  â”‚    â”‚(åæ€å™¨)  â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚              â”‚              â”‚              â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
    â”‚                  å¤–éƒ¨æœåŠ¡é›†æˆå±‚                       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  LLM Client  â”‚ Tool Client  â”‚ Kafka Logger         â”‚
    â”‚(å¤§æ¨¡å‹å®¢æˆ·ç«¯) â”‚ (å·¥å…·æœåŠ¡)    â”‚ (æ—¥å¿—å®¡è®¡)            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         æœåŠ¡å‘ç°å±‚ (å¯é€‰)                   â”‚
    â”‚   Consul Registry + Service Discovery     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒæ•°æ®æµ

```
ç”¨æˆ·è¯·æ±‚ â†’ APIå±‚ â†’ Orchestrator â†’ [è§„åˆ’â†’æ‰§è¡Œâ†’è¯„ä¼°â†’åæ€] â†’ ç»“æœè¿”å›
                                      â†‘______________|
                                    (å¾ªç¯ï¼šè‡ªåŠ¨ä¼˜åŒ–)
```

---

## 3. å®Œæ•´æ‰§è¡Œæµç¨‹

### 3.1 æµç¨‹æ€»è§ˆ

```mermaid
graph TD
    A[ç”¨æˆ·æäº¤ä»»åŠ¡] --> B[åˆ›å»ºä»»åŠ¡çŠ¶æ€]
    B --> C{æ˜¯å¦å¯ç”¨ä¸¤é˜¶æ®µè§„åˆ’?}

    C -->|æ˜¯| D[é˜¶æ®µ1: LLMå·¥å…·ç­›é€‰]
    C -->|å¦| E[ç›´æ¥è§„åˆ’]

    D --> F[é˜¶æ®µ2: åŸºäºç­›é€‰å·¥å…·ç”Ÿæˆè®¡åˆ’]
    E --> F

    F --> G{æ˜¯å¦å¯ç”¨å¹¶è¡Œæ‰§è¡Œ?}

    G -->|æ˜¯| H[å¹¶è¡Œæ‰§è¡Œè®¡åˆ’]
    G -->|å¦| I[ä¸²è¡Œæ‰§è¡Œè®¡åˆ’]

    H --> J[æ‰§è¡Œç»“æœè¯„ä¼°]
    I --> J

    J --> K{è¯„ä¼°æ˜¯å¦æˆåŠŸ?}

    K -->|æˆåŠŸ| L[è¿”å›æœ€ç»ˆç»“æœ]
    K -->|å¤±è´¥| M{æ˜¯å¦å¯ç”¨åæ€?}

    M -->|æ˜¯| N[åæ€åˆ†æ]
    M -->|å¦| L

    N --> O{åæ€å»ºè®®?}

    O -->|é‡æ–°è§„åˆ’| P{è¾¾åˆ°æœ€å¤§è½®æ¬¡?}
    O -->|åœæ­¢æ‰§è¡Œ| L

    P -->|å¦| D
    P -->|æ˜¯| L
```

### 3.2 è¯¦ç»†æ‰§è¡Œé˜¶æ®µ

#### é˜¶æ®µ0: ä»»åŠ¡åˆå§‹åŒ–

**å…¥å£**: `Orchestrator::orchestrate_with_id_and_metadata()`
**ä½ç½®**: [src/core/orchestrator.rs:291](src/core/orchestrator.rs#L291)

```rust
// 1. ç”Ÿæˆå”¯ä¸€ä»»åŠ¡ID
let task_id = task_id.unwrap_or_else(|| format!("task_{}", uuid::Uuid::new_v4()));

// 2. åˆ›å»ºä»»åŠ¡çŠ¶æ€
let task = Task {
    task_id: task_id.clone(),
    task_description: task_description.clone(),
    status: TaskStatus::Planning,
    metadata,
    context,
    // ...
};

// 3. æ³¨å†Œåˆ°çŠ¶æ€ç®¡ç†å™¨
state_manager.register_task(task);
```

**å…³é”®ç‚¹**:
- ä»»åŠ¡çŠ¶æ€é€šè¿‡ `TaskStateManager` ç®¡ç†ï¼ˆä½¿ç”¨ `DashMap` ä¿è¯å¹¶å‘å®‰å…¨ï¼‰
- åˆå§‹çŠ¶æ€ä¸º `Planning`
- å…ƒæ•°æ®ï¼ˆmetadataï¼‰å’Œä¸Šä¸‹æ–‡ï¼ˆcontextï¼‰è´¯ç©¿æ•´ä¸ªæ‰§è¡Œå‘¨æœŸ

---

#### é˜¶æ®µ1: æ™ºèƒ½è§„åˆ’ (Planning)

**æ ¸å¿ƒç»„ä»¶**: `Planner`
**ä½ç½®**: [src/core/planner.rs:1](src/core/planner.rs#L1)

##### 1.1 ä¸¤é˜¶æ®µè§„åˆ’æµç¨‹

**é…ç½®é¡¹**: `orchestrator.enable_two_stage_planning = true`
**è§¦å‘æ¡ä»¶**: å·¥å…·æ•°é‡ > `two_stage_tool_threshold` (é»˜è®¤10ä¸ª)

```rust
// é˜¶æ®µ1: å·¥å…·ç­›é€‰
pub async fn select_tools_for_task(
    &self,
    task_description: &str,
    available_tools: &[ToolInfo],
) -> Result<Vec<ToolInfo>> {
    // 1. æ„å»ºå·¥å…·ç­›é€‰æç¤ºè¯
    let prompt = self.build_tool_selection_prompt(task_description, available_tools);

    // 2. è°ƒç”¨LLMè¿›è¡Œå·¥å…·ç­›é€‰
    let llm_response = self.call_llm(&system_prompt, &user_prompt, "å·¥å…·ç­›é€‰", None).await?;

    // 3. è§£æç­›é€‰ç»“æœï¼ˆJSONæ ¼å¼ï¼‰
    let selected_tool_ids = self.parse_tool_selection_result(&llm_response)?;

    // 4. è¿”å›ç­›é€‰åçš„å·¥å…·åˆ—è¡¨
    Ok(selected_tools)
}
```

**ç­›é€‰ç­–ç•¥**:
- LLMåŸºäºä»»åŠ¡æè¿°åˆ†ææ‰€éœ€å·¥å…·
- æ”¯æŒç›¸ä¼¼åº¦é˜ˆå€¼æ§åˆ¶ï¼ˆ`tool_selection_threshold`ï¼Œé»˜è®¤70.0ï¼‰
- å¯é€‰æ‹©åŒ¹é…å†…ç½®å·¥ä½œæµæ¨¡æ¿ï¼ˆ`enable_builtin_workflows = true`ï¼‰

##### 1.2 ç”Ÿæˆæ‰§è¡Œè®¡åˆ’

```rust
// é˜¶æ®µ2: ç”Ÿæˆæ‰§è¡Œè®¡åˆ’
pub async fn plan(
    &self,
    task_description: &str,
    available_tools: &[ToolInfo],
    metadata: &HashMap<String, String>,
) -> Result<ExecutionPlan> {
    // 1. æ„å»ºè§„åˆ’æç¤ºè¯
    let prompt_builder = PlanningPromptBuilder::new();
    let prompt = prompt_builder
        .with_task_description(task_description)
        .with_tools(available_tools)
        .with_metadata(metadata)
        .build();

    // 2. è°ƒç”¨LLMç”Ÿæˆè®¡åˆ’
    let plan_json = self.call_llm(&system_prompt, &user_prompt, "ä»»åŠ¡è§„åˆ’", None).await?;

    // 3. è§£ææ‰§è¡Œè®¡åˆ’
    let execution_plan = self.parse_execution_plan(&plan_json)?;

    Ok(execution_plan)
}
```

**æ‰§è¡Œè®¡åˆ’ç»“æ„**:

```rust
pub struct ExecutionPlan {
    pub plan_id: String,                    // è®¡åˆ’å”¯ä¸€ID
    pub task_description: String,           // ä»»åŠ¡æè¿°
    pub steps: Vec<PlanStep>,               // æ­¥éª¤åˆ—è¡¨
    pub estimated_duration: u64,            // é¢„ä¼°è€—æ—¶ï¼ˆç§’ï¼‰
    pub reasoning: String,                  // è§„åˆ’æ¨ç†è¿‡ç¨‹
}

pub struct PlanStep {
    pub step_id: String,                    // æ­¥éª¤ID (å¦‚ "step_1")
    pub name: String,                       // æ­¥éª¤åç§°
    pub tool: String,                       // ä½¿ç”¨çš„å·¥å…·ID
    pub parameters: String,                 // å·¥å…·å‚æ•° (JSONæ ¼å¼)
    pub dependencies: Vec<String>,          // ä¾èµ–çš„æ­¥éª¤IDåˆ—è¡¨
    pub expected_output: String,            // é¢„æœŸè¾“å‡ºæè¿°
    pub actions: Vec<PlanAction>,           // ğŸ†• æ­¥éª¤å†…å¹¶è¡Œæ“ä½œåˆ—è¡¨
}
```

**ä¾èµ–å…³ç³»å¤„ç†**:
- æ­¥éª¤æ”¯æŒå£°æ˜ä¾èµ–ï¼ˆ`dependencies`ï¼‰
- ä¾èµ–å…³ç³»ç”¨äºå¹¶è¡Œæ‰§è¡Œè°ƒåº¦å’Œé”™è¯¯å¤„ç†

---

#### é˜¶æ®µ2: æ™ºèƒ½æ‰§è¡Œ (Execution)

**æ ¸å¿ƒç»„ä»¶**: `Executor`
**ä½ç½®**: [src/core/executor.rs:1](src/core/executor.rs#L1)

##### 2.1 æ‰§è¡Œæ¨¡å¼é€‰æ‹©

```rust
// æ‰§è¡Œå…¥å£
pub async fn execute_plan_with_context(
    &self,
    plan: &ExecutionPlan,
    metadata: &HashMap<String, String>,
    available_tools: &[ToolInfo],
) -> Result<(PlanExecutionResult, ExecutionContext)> {
    // åˆ¤æ–­æ˜¯å¦ä½¿ç”¨å¹¶è¡Œæ‰§è¡Œ
    let should_parallel = self.should_use_parallel_execution(plan);

    if should_parallel {
        // å¹¶è¡Œæ‰§è¡Œè·¯å¾„
        self.execute_plan_parallel_with_context(plan, metadata, available_tools).await
    } else {
        // ä¸²è¡Œæ‰§è¡Œè·¯å¾„
        self.execute_plan_serial_with_context(plan, metadata, available_tools).await
    }
}
```

**å¹¶è¡Œæ‰§è¡Œè§¦å‘æ¡ä»¶** ([src/core/executor.rs:1797](src/core/executor.rs#L1797)):

1. `enable_parallel_execution = true`ï¼ˆé…ç½®å¼€å…³ï¼‰
2. æ­¥éª¤æ•°é‡ â‰¥ `parallel_min_steps`ï¼ˆé»˜è®¤2ä¸ªï¼‰
3. å­˜åœ¨å¯å¹¶è¡Œæ­¥éª¤ï¼ˆè‡³å°‘æœ‰2ä¸ªæ­¥éª¤å¯åŒæ—¶æ‰§è¡Œï¼‰

##### 2.2 ä¸²è¡Œæ‰§è¡Œæµç¨‹

```rust
// æŒ‰é¡ºåºæ‰§è¡Œæ¯ä¸ªæ­¥éª¤
for (index, step) in plan.steps.iter().enumerate() {
    // 1. æ£€æŸ¥ä¾èµ–æ˜¯å¦æ»¡è¶³
    if !self.check_dependencies(step, &step_results) {
        // ä¾èµ–æœªæ»¡è¶³ï¼Œè·³è¿‡è¯¥æ­¥éª¤
        continue;
    }

    // 2. è§£æå‚æ•°ï¼ˆæ”¯æŒå ä½ç¬¦æ›¿æ¢ï¼‰
    let parameters = ParameterResolver::resolve_parameters(
        step,
        &tool_info,
        &context,
    );

    // 3. æ‰§è¡Œå·¥å…·è°ƒç”¨
    let result = self.execute_step(plan_id, step, &parameters, Some(&context)).await?;

    // 4. ä¿å­˜ç»“æœåˆ°æ‰§è¡Œä¸Šä¸‹æ–‡
    context.set_step_result(result);

    // 5. æµè½¬è¾“å‡ºå‚æ•°åˆ°runtime metadata
    if result.is_success {
        context.sync_step_output_to_runtime_metadata(&step.step_id, &output_params)?;
    }
}
```

**å‚æ•°è§£ææœºåˆ¶** ([src/core/parameter_resolver.rs](src/core/parameter_resolver.rs)):

```rust
pub fn resolve_parameters(
    step: &PlanStep,
    tool_info: &ToolInfo,
    context: &ExecutionContext,
) -> HashMap<String, String> {
    // 1. è§£ææ­¥éª¤å®šä¹‰çš„å‚æ•°ï¼ˆæ”¯æŒå ä½ç¬¦ ${step_id.output}ï¼‰
    let mut params = parse_step_parameters(&step.parameters);

    // 2. ä»æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­æ›¿æ¢å ä½ç¬¦
    for (key, value) in params.iter_mut() {
        *value = self.process_parameter_value(value, context);
    }

    // 3. ä»metadataä¸­è¡¥å……ç¼ºå¤±å‚æ•°
    inject_metadata_parameters(step, &mut params, context.get_all_metadata());

    params
}
```

**å ä½ç¬¦æ”¯æŒ**:
- `${step_1}`: å¼•ç”¨æ­¥éª¤1çš„è¾“å‡º
- `${step_1.output}`: æ˜ç¡®å¼•ç”¨è¾“å‡ºå­—æ®µ
- `{{action_1_1.output}}`: å¼•ç”¨actionçš„è¾“å‡ºï¼ˆæ­¥éª¤å†…å¹¶è¡Œï¼‰

##### 2.3 å¹¶è¡Œæ‰§è¡Œæµç¨‹

**ä½ç½®**: [src/core/parallel_executor.rs](src/core/parallel_executor.rs)

```rust
pub async fn execute_plan_parallel(
    &self,
    plan: &ExecutionPlan,
    context: &ExecutionContext,
    tool_map: &HashMap<String, ToolInfo>,
) -> Result<Vec<StepResult>> {
    // 1. æ„å»ºä¾èµ–å›¾ï¼ˆæ‹“æ‰‘æ’åºï¼‰
    let dependency_graph = self.build_dependency_graph(plan);

    // 2. åˆ†æ‰¹æ¬¡å¹¶è¡Œæ‰§è¡Œ
    let mut batch_index = 0;
    while let Some(batch) = dependency_graph.get_next_batch() {
        // 3. åŒä¸€æ‰¹æ¬¡å†…çš„æ­¥éª¤å¹¶è¡Œæ‰§è¡Œ
        let batch_tasks = batch.iter().map(|step| {
            let semaphore = self.semaphore.clone();
            async move {
                // è·å–å¹¶å‘è®¸å¯
                let _permit = semaphore.acquire().await?;

                // æ‰§è¡Œæ­¥éª¤
                self.execute_single_step(step, context, tool_map).await
            }
        });

        // 4. ç­‰å¾…æ‰¹æ¬¡å®Œæˆ
        let batch_results = join_all(batch_tasks).await;

        // 5. ä¿å­˜ç»“æœåˆ°ä¸Šä¸‹æ–‡
        for result in batch_results {
            context.set_step_result(result);
        }

        batch_index += 1;
    }

    Ok(all_results)
}
```

**å¹¶å‘æ§åˆ¶**:
- ä½¿ç”¨ `Semaphore` é™åˆ¶æœ€å¤§å¹¶å‘æ•°ï¼ˆ`parallel_max_concurrent`ï¼Œé»˜è®¤8ï¼‰
- æ‰¹æ¬¡é—´ä¸²è¡Œï¼Œæ‰¹æ¬¡å†…å¹¶è¡Œ
- è‡ªåŠ¨å¤„ç†ä¾èµ–å…³ç³»

##### 2.4 æ‰§è¡Œä¸Šä¸‹æ–‡ç®¡ç†

**ä½ç½®**: [src/core/execution_context.rs](src/core/execution_context.rs)

```rust
pub struct ExecutionContext {
    plan_id: String,
    metadata: Arc<DashMap<String, String>>,          // å…¨å±€å…ƒæ•°æ®
    step_results: Arc<DashMap<String, StepResult>>,  // æ­¥éª¤æ‰§è¡Œç»“æœ
}

// å…³é”®æ–¹æ³•
impl ExecutionContext {
    // ä¿å­˜æ­¥éª¤ç»“æœ
    pub fn set_step_result(&self, result: StepExecutionResult) {
        self.step_results.insert(result.step_id.clone(), result);
    }

    // æµè½¬è¾“å‡ºåˆ°metadata
    pub fn sync_step_output_to_runtime_metadata(
        &self,
        step_id: &str,
        output_param_names: &[String],
    ) -> Result<usize> {
        // ä»æ­¥éª¤è¾“å‡ºä¸­æå–æŒ‡å®šå‚æ•°ï¼Œå†™å…¥metadata
        // ç”¨äºåç»­æ­¥éª¤å¼•ç”¨
    }

    // è·å–æ­¥éª¤è¾“å‡º
    pub fn get_step_output(&self, step_id: &str) -> Option<String> {
        self.step_results.get(step_id).map(|r| r.output.clone())
    }
}
```

**æ•°æ®æµè½¬æœºåˆ¶**:
1. æ­¥éª¤æ‰§è¡Œå®Œæˆåï¼Œè¾“å‡ºä¿å­˜åˆ° `ExecutionContext`
2. æ ¹æ®å·¥å…·çš„ `output_params` å®šä¹‰ï¼Œè‡ªåŠ¨æµè½¬åˆ° `metadata`
3. åç»­æ­¥éª¤é€šè¿‡å‚æ•°è§£æå™¨è‡ªåŠ¨è·å–å‰ç½®æ­¥éª¤çš„è¾“å‡º

---

#### é˜¶æ®µ3: ç»“æœè¯„ä¼° (Evaluation)

**æ ¸å¿ƒç»„ä»¶**: `Evaluator`
**ä½ç½®**: [src/core/evaluator.rs:1](src/core/evaluator.rs#L1)

```rust
pub async fn evaluate(
    &self,
    task_description: &str,
    plan: &ExecutionPlan,
    execution_result: &PlanExecutionResult,
) -> Result<EvaluationResult> {
    // 1. æ„å»ºè¯„ä¼°æç¤ºè¯
    let prompt = self.build_evaluation_prompt(
        task_description,
        plan,
        execution_result,
    );

    // 2. è°ƒç”¨LLMè¿›è¡Œè¯„ä¼°
    let evaluation_json = self.llm_client.call(&system_prompt, &user_prompt, None).await?;

    // 3. è§£æè¯„ä¼°ç»“æœ
    let evaluation = self.parse_evaluation_result(&evaluation_json)?;

    Ok(evaluation)
}
```

**è¯„ä¼°ç»´åº¦**:

```rust
pub struct EvaluationDimensions {
    pub completeness: f32,      // å®Œæ•´æ€§ (0-100)
    pub correctness: f32,       // æ­£ç¡®æ€§ (0-100)
    pub efficiency: f32,        // æ•ˆç‡ (0-100)
    pub reliability: f32,       // å¯é æ€§ (0-100)
}

pub struct EvaluationResult {
    pub overall_score: f32,                         // æ€»ä½“è¯„åˆ†
    pub is_successful: bool,                        // æ˜¯å¦æˆåŠŸ
    pub dimensions: EvaluationDimensions,           // å„ç»´åº¦è¯„åˆ†
    pub successes: Vec<String>,                     // æˆåŠŸçš„æ–¹é¢
    pub failures: Vec<String>,                      // å¤±è´¥çš„æ–¹é¢
    pub improvement_suggestions: Vec<String>,       // æ”¹è¿›å»ºè®®
}
```

**æˆåŠŸåˆ¤æ–­æ ‡å‡†**:
- `overall_score >= success_threshold`ï¼ˆé»˜è®¤80.0ï¼‰
- æ‰€æœ‰æ­¥éª¤æ‰§è¡ŒæˆåŠŸ
- æ— è‡´å‘½é”™è¯¯

---

#### é˜¶æ®µ4: åæ€ä¸ä¼˜åŒ– (Reflection)

**æ ¸å¿ƒç»„ä»¶**: `Reflector`
**ä½ç½®**: [src/core/reflector.rs:1](src/core/reflector.rs#L1)

##### 4.1 ä»»åŠ¡çº§åæ€

```rust
pub async fn reflect(
    &self,
    task_description: &str,
    plan: &ExecutionPlan,
    execution_result: &PlanExecutionResult,
    evaluation: &EvaluationResult,
    current_round: u32,
) -> Result<ReflectionResult> {
    // 1. æ„å»ºåæ€æç¤ºè¯
    let context = ReflectionContext {
        task_description,
        current_plan: plan,
        execution_result,
        evaluation,
        round: current_round,
    };

    let prompt = ReflectionPromptBuilder::new()
        .with_context(&context)
        .build();

    // 2. è°ƒç”¨LLMè¿›è¡Œåæ€
    let reflection_json = self.llm_client.call(&system_prompt, &user_prompt, None).await?;

    // 3. è§£æåæ€ç»“æœ
    let reflection = self.parse_reflection_result(&reflection_json)?;

    Ok(reflection)
}
```

**åæ€è¾“å‡º**:

```rust
pub struct ReflectionResult {
    pub root_causes: Vec<String>,                   // æ ¹æœ¬åŸå› 
    pub incorrect_assumptions: Vec<String>,         // é”™è¯¯å‡è®¾
    pub alternative_approaches: Vec<String>,        // æ›¿ä»£æ–¹æ³•
    pub optimization_suggestions: Vec<OptimizationSuggestion>,  // ä¼˜åŒ–å»ºè®®
    pub should_replan: bool,                        // æ˜¯å¦éœ€è¦é‡æ–°è§„åˆ’
}
```

##### 4.2 æ­¥éª¤çº§åæ€

**è§¦å‘æ¡ä»¶**: å•ä¸ªæ­¥éª¤æ‰§è¡Œå¤±è´¥
**é…ç½®é¡¹**: `reflection.enable_step_level_reflection = true`

```rust
pub async fn reflect_on_step_failure(
    &self,
    task_description: &str,
    plan: &ExecutionPlan,
    failed_step: &PlanStep,
    step_result: &StepResult,
    execution_context: &ExecutionContext,
    available_tools: &[ToolInfo],
) -> Result<StepReflection> {
    // 1. åˆ†æå¤±è´¥åŸå› 
    let analysis = self.analyze_failure_reason(failed_step, step_result, execution_context);

    // 2. ç”Ÿæˆä¿®å¤å»ºè®®
    let suggested_action = self.suggest_fix_action(
        failed_step,
        step_result,
        available_tools,
    );

    // 3. è¿”å›å•æ­¥åæ€ç»“æœ
    Ok(StepReflection {
        root_cause: analysis.root_cause,
        root_cause_category: analysis.category,
        suggested_action,
        confidence: analysis.confidence,
        is_recoverable: analysis.is_recoverable,
        // ...
    })
}
```

**ä¿®å¤ç­–ç•¥** (`StepAction`):

1. **RetryWithAdjustedParams**: è°ƒæ•´å‚æ•°åé‡è¯•
   ```rust
   StepAction::RetryWithAdjustedParams(HashMap::from([
       ("param_name".to_string(), "new_value".to_string()),
   ]))
   ```

2. **RetryWithAlternativeTool**: ä½¿ç”¨å¤‡é€‰å·¥å…·
   ```rust
   StepAction::RetryWithAlternativeTool("alternative_tool_id".to_string())
   ```

3. **ReplanEntireTask**: é‡æ–°è§„åˆ’æ•´ä¸ªä»»åŠ¡

4. **StopExecution**: åœæ­¢æ‰§è¡Œ

**é‡è¯•é€»è¾‘**:
- æœ€å¤§æ­¥éª¤é‡è¯•æ¬¡æ•°: `max_step_retries`ï¼ˆé»˜è®¤3æ¬¡ï¼‰
- é‡è¯•å¤±è´¥åè§¦å‘ä»»åŠ¡é‡æ–°è§„åˆ’
- æœ€å¤§é‡æ–°è§„åˆ’æ¬¡æ•°: `max_task_replanning_attempts`ï¼ˆé»˜è®¤1æ¬¡ï¼‰

---

#### é˜¶æ®µ5: å¾ªç¯ä¼˜åŒ–

```rust
// ä¸»å¾ªç¯ï¼ˆä½äº Orchestrator::orchestrate_with_id_and_metadataï¼‰
for round in 1..=max_reflection_rounds {
    // 1. è§„åˆ’
    let plan = planner.plan(task_description, tools, metadata).await?;

    // 2. æ‰§è¡Œ
    let (execution_result, context) = executor.execute_plan_with_context(
        &plan,
        metadata,
        tools,
    ).await?;

    // 3. è¯„ä¼°
    let evaluation = evaluator.evaluate(task_description, &plan, &execution_result).await?;

    // 4. åˆ¤æ–­æ˜¯å¦æˆåŠŸ
    if evaluation.is_successful {
        return Ok(OrchestrationResult {
            is_success: true,
            final_score: Some(evaluation.overall_score),
            total_rounds: round,
            // ...
        });
    }

    // 5. åæ€
    if enable_auto_reflection && round < max_reflection_rounds {
        let reflection = reflector.reflect(
            task_description,
            &plan,
            &execution_result,
            &evaluation,
            round,
        ).await?;

        // 6. å†³å®šæ˜¯å¦é‡æ–°è§„åˆ’
        if reflection.should_replan {
            continue; // è¿›å…¥ä¸‹ä¸€è½®
        } else {
            break; // åœæ­¢å¾ªç¯
        }
    }
}
```

**å¾ªç¯æ§åˆ¶å‚æ•°**:
- `max_reflection_rounds`: æœ€å¤§åæ€è½®æ¬¡ï¼ˆé»˜è®¤5æ¬¡ï¼‰
- `enable_auto_reflection`: æ˜¯å¦å¯ç”¨è‡ªåŠ¨åæ€ï¼ˆé»˜è®¤trueï¼‰
- `success_threshold`: æˆåŠŸè¯„åˆ†é˜ˆå€¼ï¼ˆé»˜è®¤80.0ï¼‰

---

## 4. æ ¸å¿ƒç»„ä»¶è¯¦è§£

### 4.1 Orchestratorï¼ˆç¼–æ’å™¨ï¼‰

**èŒè´£**: åè°ƒ Plannerã€Executorã€Evaluatorã€Reflectorï¼Œå®ç°å®Œæ•´çš„ Reflective Planning å¾ªç¯

**å…³é”®æ–¹æ³•**:

| æ–¹æ³• | è¯´æ˜ |
|------|------|
| `orchestrate()` | ç®€åŒ–ç‰ˆç¼–æ’å…¥å£ |
| `orchestrate_with_id()` | æŒ‡å®šä»»åŠ¡IDçš„ç¼–æ’ |
| `orchestrate_with_id_and_metadata()` | å®Œæ•´ç‰ˆç¼–æ’ï¼ˆåŒ…å«å…ƒæ•°æ®å’Œä¸Šä¸‹æ–‡ï¼‰ |
| `set_task_event_sender()` | è®¾ç½®ä»»åŠ¡çº§äº‹ä»¶å‘é€å™¨ï¼ˆç”¨äºå®æ—¶è¿›åº¦æ¨é€ï¼‰ |

**äº‹ä»¶å‘é€æœºåˆ¶**:

```rust
pub trait EventSender: Send + Sync {
    fn send_plan_generated(&self, plan: &ExecutionPlan);
    fn send_step_started(&self, step_id: &str, step_name: &str, step_index: usize, total_steps: usize);
    fn send_step_completed(&self, step_result: &StepResult);
    fn send_evaluation_completed(&self, evaluation: &EvaluationResult);
    fn send_reflection_completed(&self, reflection: &ReflectionResult);
    fn send_task_wait(&self, phase: &str, message: &str);
    fn send_progress_update(&self, message: &str);
    // ...
}
```

**æ”¯æŒçš„äº‹ä»¶ç±»å‹**:
- è½®æ¬¡å¼€å§‹/å®Œæˆ
- LLMè°ƒç”¨å¼€å§‹/å®Œæˆ/æµå¼è¾“å‡º
- å·¥å…·ç­›é€‰å®Œæˆ
- è§„åˆ’ç”Ÿæˆ
- æ­¥éª¤å¼€å§‹/å®Œæˆ/å¤±è´¥
- è¯„ä¼°å®Œæˆ
- åæ€å®Œæˆ
- ä»»åŠ¡ç»éªŒæ¨é€

---

### 4.2 Plannerï¼ˆè§„åˆ’å™¨ï¼‰

**èŒè´£**: åŸºäºLLMå’Œå¯ç”¨å·¥å…·ç”Ÿæˆæ‰§è¡Œè®¡åˆ’

**æ ¸å¿ƒæµç¨‹**:

1. **å·¥å…·ç­›é€‰**ï¼ˆä¸¤é˜¶æ®µè§„åˆ’å¯ç”¨æ—¶ï¼‰
   - è¾“å…¥: ä»»åŠ¡æè¿° + æ‰€æœ‰å¯ç”¨å·¥å…·
   - è¾“å‡º: ç­›é€‰åçš„å·¥å…·åˆ—è¡¨
   - æç¤ºè¯æ„å»º: `build_tool_selection_prompt()`

2. **è®¡åˆ’ç”Ÿæˆ**
   - è¾“å…¥: ä»»åŠ¡æè¿° + ç­›é€‰åçš„å·¥å…· + å…ƒæ•°æ®
   - è¾“å‡º: ç»“æ„åŒ–æ‰§è¡Œè®¡åˆ’
   - æç¤ºè¯æ„å»º: `PlanningPromptBuilder`

3. **è®¡åˆ’éªŒè¯**
   - æ£€æŸ¥æ­¥éª¤ä¾èµ–åˆæ³•æ€§
   - æ£€æŸ¥å·¥å…·æ˜¯å¦å­˜åœ¨
   - æ£€æŸ¥å‚æ•°æ ¼å¼

**æç¤ºè¯ç®¡ç†**:
- ç³»ç»Ÿæç¤ºè¯: å®šä¹‰LLMè§’è‰²å’Œèƒ½åŠ›
- ç”¨æˆ·æç¤ºè¯: åŒ…å«ä»»åŠ¡æè¿°ã€å·¥å…·åˆ—è¡¨ã€å…ƒæ•°æ®
- æ”¯æŒåœºæ™¯å¼•å¯¼ï¼ˆScene Guidanceï¼‰
- æ”¯æŒå·¥ä½œæµæ¨¡æ¿åŒ¹é…

**ä½ç½®**: [src/llm/planning_prompts.rs](src/llm/planning_prompts.rs)

---

### 4.3 Executorï¼ˆæ‰§è¡Œå™¨ï¼‰

**èŒè´£**: æ‰§è¡Œè®¡åˆ’ä¸­çš„å…·ä½“æ­¥éª¤ï¼Œç®¡ç†æ‰§è¡ŒçŠ¶æ€

**æ‰§è¡Œæ¨¡å¼**:

1. **ä¸²è¡Œæ‰§è¡Œ** (é»˜è®¤å…œåº•æ¨¡å¼)
   - æŒ‰æ­¥éª¤é¡ºåºä¾æ¬¡æ‰§è¡Œ
   - ç®€å•å¯é ï¼Œä¾¿äºè°ƒè¯•
   - é€‚ç”¨äºæ­¥éª¤å°‘æˆ–ä¾èµ–å¤æ‚çš„åœºæ™¯

2. **å¹¶è¡Œæ‰§è¡Œ** (æ€§èƒ½ä¼˜åŒ–æ¨¡å¼)
   - è‡ªåŠ¨è¯†åˆ«æ— ä¾èµ–æ­¥éª¤
   - ä½¿ç”¨æ‹“æ‰‘æ’åºåˆ†æ‰¹æ‰§è¡Œ
   - æ”¯æŒå¹¶å‘æ•°æ§åˆ¶
   - è¯¦è§ [5. å¹¶è¡Œæ‰§è¡Œæœºåˆ¶](#5-å¹¶è¡Œæ‰§è¡Œæœºåˆ¶)

**å·¥å…·è°ƒç”¨æµç¨‹**:

```rust
// 1. å‡†å¤‡å‚æ•°
let parameters = ParameterResolver::resolve_parameters(step, tool_info, context);

// 2. è°ƒç”¨å·¥å…·æœåŠ¡
let tool_response = self.tool_client.execute_tool(&step.tool, &parameters).await?;

// 3. å¤„ç†ç»“æœ
if tool_response.status == "success" {
    // ä¿å­˜ç»“æœåˆ°æ‰§è¡Œä¸Šä¸‹æ–‡
    context.set_step_result(StepResult {
        step_id: step.step_id.clone(),
        output: tool_response.result,
        is_success: true,
        // ...
    });

    // æµè½¬è¾“å‡ºå‚æ•°åˆ°metadata
    context.sync_step_output_to_runtime_metadata(&step.step_id, &output_params)?;
} else {
    // å¤„ç†å¤±è´¥æƒ…å†µ
}
```

**è¶…æ—¶æ§åˆ¶**:
- å•æ­¥è¶…æ—¶: `execution_timeout`ï¼ˆç»§æ‰¿è‡ª `task_timeout_secs`ï¼‰
- ä½¿ç”¨ `tokio::time::timeout` åŒ…è£…å¼‚æ­¥è°ƒç”¨

---

### 4.4 Evaluatorï¼ˆè¯„ä¼°å™¨ï¼‰

**èŒè´£**: è¯„ä¼°ä»»åŠ¡æ‰§è¡Œçš„è´¨é‡å’Œæ•ˆæœ

**è¯„ä¼°æµç¨‹**:

1. æ”¶é›†æ‰§è¡Œæ•°æ®
   - ä»»åŠ¡æè¿°
   - æ‰§è¡Œè®¡åˆ’
   - æ‰§è¡Œç»“æœï¼ˆæ¯ä¸ªæ­¥éª¤çš„è¾“å‡ºï¼‰
   - è€—æ—¶ç»Ÿè®¡

2. æ„å»ºè¯„ä¼°æç¤ºè¯
   - æ˜ç¡®è¯„ä¼°ç»´åº¦
   - æä¾›è¯„åˆ†æ ‡å‡†
   - è¦æ±‚ç»“æ„åŒ–è¾“å‡º

3. LLMè¯„ä¼°åˆ†æ
   - å¤šç»´åº¦è¯„åˆ†ï¼ˆå®Œæ•´æ€§ã€æ­£ç¡®æ€§ã€æ•ˆç‡ã€å¯é æ€§ï¼‰
   - æ€»ä½“è¯„åˆ†è®¡ç®—
   - æˆåŠŸ/å¤±è´¥åŸå› åˆ†æ
   - æ”¹è¿›å»ºè®®ç”Ÿæˆ

4. è§£æè¯„ä¼°ç»“æœ
   - JSONæ ¼å¼è§£æ
   - æ•°æ®éªŒè¯
   - é»˜è®¤å€¼å¡«å……

**è¾“å‡ºæ ¼å¼**:

```json
{
  "evaluation_id": "eval_xxx",
  "overall_score": 85.0,
  "is_successful": true,
  "dimensions": {
    "completeness": 90.0,
    "correctness": 85.0,
    "efficiency": 80.0,
    "reliability": 85.0
  },
  "successes": [
    "æˆåŠŸå®Œæˆæ•°æ®å¤„ç†",
    "è¾“å‡ºæ ¼å¼æ­£ç¡®"
  ],
  "failures": [],
  "improvement_suggestions": [
    "å¯ä»¥ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½"
  ]
}
```

---

### 4.5 Reflectorï¼ˆåæ€å™¨ï¼‰

**èŒè´£**: æ·±åº¦åˆ†ææ‰§è¡Œç»“æœï¼Œæå‡ºä¼˜åŒ–å»ºè®®

**åæ€ç±»å‹**:

1. **ä»»åŠ¡çº§åæ€** (Task-Level Reflection)
   - è§¦å‘æ¡ä»¶: ä»»åŠ¡æ‰§è¡Œå¤±è´¥æˆ–è¯„åˆ†ä½äºé˜ˆå€¼
   - åˆ†æèŒƒå›´: æ•´ä¸ªä»»åŠ¡çš„è§„åˆ’å’Œæ‰§è¡Œ
   - è¾“å‡º: æ˜¯å¦éœ€è¦é‡æ–°è§„åˆ’ + ä¼˜åŒ–å»ºè®®

2. **æ­¥éª¤çº§åæ€** (Step-Level Reflection)
   - è§¦å‘æ¡ä»¶: å•ä¸ªæ­¥éª¤æ‰§è¡Œå¤±è´¥
   - åˆ†æèŒƒå›´: è¯¥æ­¥éª¤åŠå…¶ä¸Šä¸‹æ–‡
   - è¾“å‡º: ä¿®å¤å»ºè®®ï¼ˆé‡è¯•/æ¢å·¥å…·/é‡æ–°è§„åˆ’ï¼‰

**åæ€åˆ†æç»´åº¦**:

- **æ ¹æœ¬åŸå› åˆ†æ**: ä¸ºä»€ä¹ˆå¤±è´¥ï¼Ÿ
- **é”™è¯¯å‡è®¾è¯†åˆ«**: è§„åˆ’æ—¶çš„è¯¯åˆ¤
- **æ›¿ä»£æ–¹æ³•æ¢ç´¢**: æ˜¯å¦æœ‰æ›´å¥½çš„æ–¹å¼ï¼Ÿ
- **ä¼˜åŒ–å»ºè®®ç”Ÿæˆ**: å¦‚ä½•æ”¹è¿›ï¼Ÿ

**ç¤ºä¾‹è¾“å‡º**:

```json
{
  "reflection_id": "refl_xxx",
  "root_causes": [
    "å·¥å…·å‚æ•°æ ¼å¼ä¸åŒ¹é…",
    "ç¼ºå°‘å¿…è¦çš„å‰ç½®æ­¥éª¤"
  ],
  "incorrect_assumptions": [
    "å‡è®¾æ•°æ®å·²ç»è¿‡æ¸…æ´—"
  ],
  "alternative_approaches": [
    "å…ˆè¿›è¡Œæ•°æ®é¢„å¤„ç†",
    "ä½¿ç”¨ä¸“é—¨çš„æ•°æ®æ¸…æ´—å·¥å…·"
  ],
  "should_replan": true
}
```

---

## 5. å¹¶è¡Œæ‰§è¡Œæœºåˆ¶

### 5.1 å¹¶è¡Œæ‰§è¡Œæ¶æ„

**æ ¸å¿ƒç±»**: `ParallelExecutor`
**ä½ç½®**: [src/core/parallel_executor.rs](src/core/parallel_executor.rs)

**è®¾è®¡ç†å¿µ**:
- è‡ªåŠ¨æ£€æµ‹å¯å¹¶è¡Œæ­¥éª¤
- åŸºäºæ‹“æ‰‘æ’åºåˆ†æ‰¹æ‰§è¡Œ
- ä½¿ç”¨ Semaphore æ§åˆ¶å¹¶å‘æ•°
- ä¿è¯ä¾èµ–å…³ç³»æ­£ç¡®æ€§

### 5.2 ä¾èµ–å›¾æ„å»º

```rust
// æ„å»ºæ­¥éª¤ä¾èµ–å›¾
pub fn build_dependency_graph(plan: &ExecutionPlan) -> DependencyGraph {
    let mut graph = DependencyGraph::new();

    for step in &plan.steps {
        // æ·»åŠ èŠ‚ç‚¹
        graph.add_node(&step.step_id);

        // æ·»åŠ ä¾èµ–è¾¹
        for dep_id in &step.dependencies {
            graph.add_edge(dep_id, &step.step_id);
        }
    }

    graph
}
```

### 5.3 æ‹“æ‰‘æ’åºåˆ†æ‰¹

```rust
// å°†æ­¥éª¤æŒ‰ä¾èµ–å…³ç³»åˆ†æ‰¹
pub fn topological_sort_batched(graph: &DependencyGraph) -> Vec<Vec<String>> {
    let mut batches = Vec::new();
    let mut remaining_steps = graph.all_nodes();
    let mut in_degree = graph.calculate_in_degrees();

    while !remaining_steps.is_empty() {
        // æ‰¾å‡ºæ‰€æœ‰å…¥åº¦ä¸º0çš„æ­¥éª¤ï¼ˆæ— ä¾èµ–æˆ–ä¾èµ–å·²æ»¡è¶³ï¼‰
        let current_batch: Vec<_> = remaining_steps
            .iter()
            .filter(|step_id| in_degree[step_id] == 0)
            .cloned()
            .collect();

        if current_batch.is_empty() {
            // å­˜åœ¨ç¯ï¼Œæ— æ³•ç»§ç»­
            break;
        }

        batches.push(current_batch.clone());

        // æ›´æ–°å…¥åº¦
        for step_id in &current_batch {
            for neighbor in graph.neighbors(step_id) {
                in_degree[neighbor] -= 1;
            }
            remaining_steps.remove(step_id);
        }
    }

    batches
}
```

**ç¤ºä¾‹**:

å‡è®¾æœ‰å¦‚ä¸‹æ‰§è¡Œè®¡åˆ’:

```
æ­¥éª¤1: æ— ä¾èµ–
æ­¥éª¤2: æ— ä¾èµ–
æ­¥éª¤3: ä¾èµ–æ­¥éª¤1
æ­¥éª¤4: ä¾èµ–æ­¥éª¤1ã€æ­¥éª¤2
æ­¥éª¤5: ä¾èµ–æ­¥éª¤3
```

åˆ†æ‰¹ç»“æœ:

```
æ‰¹æ¬¡1: [æ­¥éª¤1, æ­¥éª¤2]       (å¹¶è¡Œæ‰§è¡Œ)
æ‰¹æ¬¡2: [æ­¥éª¤3, æ­¥éª¤4]       (å¹¶è¡Œæ‰§è¡Œï¼Œç­‰å¾…æ‰¹æ¬¡1å®Œæˆ)
æ‰¹æ¬¡3: [æ­¥éª¤5]             (ç­‰å¾…æ‰¹æ¬¡2å®Œæˆ)
```

### 5.4 å¹¶å‘æ§åˆ¶

```rust
// ä½¿ç”¨ Semaphore é™åˆ¶å¹¶å‘æ•°
let semaphore = Arc::new(Semaphore::new(max_concurrent));

// æ‰¹æ¬¡å†…å¹¶è¡Œæ‰§è¡Œ
let batch_tasks: Vec<_> = batch.iter().map(|step| {
    let semaphore_clone = semaphore.clone();
    async move {
        // è·å–è®¸å¯
        let _permit = semaphore_clone.acquire().await.unwrap();

        // æ‰§è¡Œæ­¥éª¤
        execute_step(step).await
    }
}).collect();

// ç­‰å¾…æ‰¹æ¬¡å®Œæˆ
let results = join_all(batch_tasks).await;
```

**å¹¶å‘å‚æ•°**:
- `parallel_max_concurrent`: æœ€å¤§å¹¶å‘æ•°ï¼ˆé»˜è®¤8ï¼‰
- å»ºè®®å€¼:
  - IOå¯†é›†å‹: CPUæ ¸å¿ƒæ•° Ã— 2~4
  - CPUå¯†é›†å‹: CPUæ ¸å¿ƒæ•°
  - æ··åˆå‹: CPUæ ¸å¿ƒæ•° Ã— 2

### 5.5 æ­¥éª¤å†…å¹¶è¡Œï¼ˆActionsï¼‰

**ç‰¹æ€§**: æ”¯æŒå•ä¸ªæ­¥éª¤åŒ…å«å¤šä¸ªå¹¶è¡Œæ“ä½œ

**ä½¿ç”¨åœºæ™¯**:
- æ‰¹é‡æ•°æ®æŸ¥è¯¢
- å¤šæºæ•°æ®èšåˆ
- å¹¶è¡ŒAPIè°ƒç”¨

**é…ç½®ç¤ºä¾‹**:

```json
{
  "step_id": "step_1",
  "name": "æ‰¹é‡æ•°æ®æŸ¥è¯¢",
  "tool": "",
  "parameters": "",
  "dependencies": [],
  "actions": [
    {
      "action_id": "action_1_1",
      "name": "æŸ¥è¯¢æ•°æ®æºA",
      "tool": "query_tool",
      "parameters": "{\"source\": \"A\"}"
    },
    {
      "action_id": "action_1_2",
      "name": "æŸ¥è¯¢æ•°æ®æºB",
      "tool": "query_tool",
      "parameters": "{\"source\": \"B\"}"
    }
  ]
}
```

**æ‰§è¡Œé€»è¾‘** ([src/core/executor.rs:1992](src/core/executor.rs#L1992)):

```rust
async fn execute_step_with_actions(
    &self,
    step: &PlanStep,
    context: &ExecutionContext,
    tool_map: &HashMap<String, ToolInfo>,
) -> Result<StepResult> {
    // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰actions
    let tasks = step.actions.iter().map(|action| {
        async move {
            // è§£æå‚æ•°ï¼ˆæ”¯æŒå ä½ç¬¦ {{action_id.output}}ï¼‰
            let params = resolve_action_parameters(action, context);

            // æ‰§è¡Œå·¥å…·
            execute_tool(&action.tool, &params).await
        }
    });

    let results = join_all(tasks).await;

    // èšåˆç»“æœ
    let aggregated_output = results.iter()
        .map(|r| format!("[{}] {}", r.action_id, r.output))
        .collect::<Vec<_>>()
        .join("\n");

    Ok(StepResult {
        step_id: step.step_id.clone(),
        output: aggregated_output,
        is_success: results.iter().all(|r| r.is_success),
        // ...
    })
}
```

### 5.6 å¹¶è¡Œæ‰§è¡Œå¼€å…³

**é…ç½®ä½ç½®**: `config.toml`

```toml
[orchestrator]
# æ˜¯å¦å¯ç”¨å¹¶è¡Œæ‰§è¡Œï¼ˆç”Ÿäº§çº§ç‰¹æ€§å¼€å…³ï¼‰
enable_parallel_execution = true

# å¹¶è¡Œæ‰§è¡Œçš„æœ€å¤§å¹¶å‘æ•°
parallel_max_concurrent = 8

# å¹¶è¡Œæ‰§è¡Œçš„æœ€å°æ­¥éª¤æ•°é˜ˆå€¼
parallel_min_steps = 2
```

**åŠ¨æ€åˆ¤æ–­é€»è¾‘** ([src/core/executor.rs:1797](src/core/executor.rs#L1797)):

```rust
fn should_use_parallel_execution(&self, plan: &ExecutionPlan) -> bool {
    // æ¡ä»¶1: é…ç½®å¼€å…³å¯ç”¨
    if !self.enable_parallel {
        return false;
    }

    // æ¡ä»¶2: æ­¥éª¤æ•°è¾¾åˆ°é˜ˆå€¼
    if plan.steps.len() < self.parallel_min_steps {
        return false;
    }

    // æ¡ä»¶3: å­˜åœ¨å¯å¹¶è¡Œæ­¥éª¤
    if self.has_no_parallelizable_steps(plan) {
        return false;
    }

    true
}
```

**å›æ»šæœºåˆ¶**:
- å¹¶è¡Œæ‰§è¡Œå¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°ä¸²è¡Œæ‰§è¡Œ
- å¯é€šè¿‡é…ç½®å¿«é€Ÿå…³é—­å¹¶è¡Œç‰¹æ€§

---

## 6. åæ€ä¸é‡è§„åˆ’æœºåˆ¶

### 6.1 åæ€è§¦å‘æ¡ä»¶

| åæ€ç±»å‹ | è§¦å‘æ¡ä»¶ | å¤„ç†æµç¨‹ |
|---------|---------|---------|
| æ­¥éª¤çº§åæ€ | å•ä¸ªæ­¥éª¤æ‰§è¡Œå¤±è´¥ | åˆ†æå¤±è´¥åŸå›  â†’ ç”Ÿæˆä¿®å¤å»ºè®® â†’ é‡è¯•æˆ–é‡æ–°è§„åˆ’ |
| ä»»åŠ¡çº§åæ€ | è¯„ä¼°å¤±è´¥æˆ–è¯„åˆ†ä½ | åˆ†ææ•´ä½“é—®é¢˜ â†’ ç”Ÿæˆä¼˜åŒ–å»ºè®® â†’ é‡æ–°è§„åˆ’ |

### 6.2 æ­¥éª¤çº§åæ€æµç¨‹

**å…¥å£**: `Orchestrator::execute_step_with_reflection()`

```rust
async fn execute_step_with_reflection(
    &self,
    plan: &ExecutionPlan,
    step_index: usize,
    context: &ExecutionContext,
    tools: &[ToolInfo],
) -> Result<StepResult> {
    let step = &plan.steps[step_index];
    let mut retry_count = 0;

    loop {
        // 1. æ‰§è¡Œæ­¥éª¤
        let result = executor.execute_single_step(
            plan,
            step_index,
            context,
            tools,
        ).await?;

        // 2. åˆ¤æ–­æ˜¯å¦æˆåŠŸ
        if result.is_success {
            return Ok(result);
        }

        // 3. æ£€æŸ¥é‡è¯•æ¬¡æ•°
        retry_count += 1;
        if retry_count > max_step_retries {
            // è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œè§¦å‘ä»»åŠ¡é‡æ–°è§„åˆ’
            return Err(ServiceError::StepExecutionFailed(
                format!("æ­¥éª¤{}å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°", step.step_id)
            ));
        }

        // 4. æ­¥éª¤çº§åæ€
        let reflection = reflector.reflect_on_step_failure(
            task_description,
            plan,
            step,
            &result,
            context,
            tools,
        ).await?;

        // 5. æ ¹æ®åæ€å»ºè®®æ‰§è¡Œ
        match reflection.suggested_action {
            StepAction::RetryWithAdjustedParams(params) => {
                // ä½¿ç”¨è°ƒæ•´åçš„å‚æ•°é‡è¯•
                continue;
            }
            StepAction::RetryWithAlternativeTool(tool_id) => {
                // ä½¿ç”¨å¤‡é€‰å·¥å…·é‡è¯•
                continue;
            }
            StepAction::ReplanEntireTask => {
                // è§¦å‘ä»»åŠ¡é‡æ–°è§„åˆ’
                return Err(ServiceError::ReplanRequired);
            }
            StepAction::StopExecution => {
                // åœæ­¢æ‰§è¡Œ
                return Err(ServiceError::ExecutionStopped);
            }
        }
    }
}
```

### 6.3 ä»»åŠ¡çº§åæ€æµç¨‹

```rust
// ä¸»å¾ªç¯ä¸­çš„åæ€é€»è¾‘
for round in 1..=max_reflection_rounds {
    // ... è§„åˆ’ã€æ‰§è¡Œã€è¯„ä¼° ...

    // åˆ¤æ–­æ˜¯å¦éœ€è¦åæ€
    if !evaluation.is_successful && round < max_reflection_rounds {
        // ä»»åŠ¡çº§åæ€
        let reflection = reflector.reflect(
            task_description,
            &plan,
            &execution_result,
            &evaluation,
            round,
        ).await?;

        // åˆ¤æ–­æ˜¯å¦é‡æ–°è§„åˆ’
        if reflection.should_replan {
            info!("åæ€å»ºè®®é‡æ–°è§„åˆ’ï¼Œè¿›å…¥ç¬¬{}è½®", round + 1);

            // ğŸ”‘ å…³é”®: å°†åæ€ç»“æœä½œä¸ºä¸Šä¸‹æ–‡ä¼ é€’ç»™ä¸‹ä¸€è½®è§„åˆ’
            // è¿™æ · Planner å¯ä»¥åŸºäºåæ€å»ºè®®ç”Ÿæˆæ›´å¥½çš„è®¡åˆ’
            context.set_reflection_context(reflection);

            continue; // è¿›å…¥ä¸‹ä¸€è½®
        } else {
            info!("åæ€å»ºè®®åœæ­¢æ‰§è¡Œ");
            break;
        }
    }
}
```

### 6.4 é‡è§„åˆ’ä¸Šä¸‹æ–‡ä¼ é€’

**ä½ç½®**: [src/llm/mod.rs - ReplanningContext](src/llm/mod.rs)

```rust
pub struct ReplanningContext {
    pub task_description: String,
    pub previous_plan: String,                      // ä¸Šä¸€è½®çš„è®¡åˆ’ï¼ˆJSONæ ¼å¼ï¼‰
    pub execution_result: String,                   // æ‰§è¡Œç»“æœ
    pub evaluation_summary: String,                 // è¯„ä¼°æ‘˜è¦
    pub reflection_insights: Vec<String>,           // åæ€æ´å¯Ÿ
    pub successful_steps: Vec<ReplanningSuccessfulStep>,  // æˆåŠŸçš„æ­¥éª¤
    pub failed_steps: Vec<String>,                  // å¤±è´¥çš„æ­¥éª¤
    pub root_causes: Vec<String>,                   // æ ¹æœ¬åŸå› 
    pub optimization_suggestions: Vec<String>,      // ä¼˜åŒ–å»ºè®®
}
```

**ä½¿ç”¨ç¤ºä¾‹**:

```rust
// æ„å»ºé‡è§„åˆ’æç¤ºè¯
let replanning_prompt = ReplanningPromptBuilder::new()
    .with_context(&replanning_context)
    .build();

// LLM ä¼šåŸºäºä¸Šä¸€è½®çš„ç»éªŒç”Ÿæˆæ”¹è¿›çš„è®¡åˆ’
let new_plan = planner.replan(task_description, tools, &replanning_context).await?;
```

---

## 7. é…ç½®ç³»ç»Ÿ

### 7.1 é…ç½®æ–‡ä»¶ç»“æ„

**ä¸»é…ç½®æ–‡ä»¶**: `config.toml`

```toml
# æœåŠ¡å™¨é…ç½®
[server]
host = "127.0.0.1"
port = 8080
request_timeout_secs = 60
max_connections = 1000

# LLMé…ç½®
[llm]
service_name = "llm-service"          # ConsulæœåŠ¡åï¼ˆå¯é€‰ï¼‰
endpoint = "http://localhost:9000"     # ç›´è¿ç«¯ç‚¹ï¼ˆå¤‡ç”¨ï¼‰
fallback_endpoint = "http://backup:9000"  # å¤‡ç”¨ç«¯ç‚¹
api_key = "your_api_key"
default_model = "qwen-plus"
timeout_secs = 60
max_retries = 3
temperature = 0.7
top_p = 0.9
protocol = "grpc"                      # "grpc" æˆ– "http"
enable_streaming = true                # å¯ç”¨æµå¼è¿”å›
max_streaming_indicators = 5           # æµå¼è¿›åº¦å›¾æ ‡æœ€å¤§å¾ªç¯æ•°

# å·¥å…·æœåŠ¡é…ç½®
[tool_service]
service_name = "tool-service"
endpoint = "http://localhost:8100"
fallback_endpoint = "http://backup:8100"
connect_timeout_secs = 5
timeout_secs = 60
max_retries = 3
protocol = "grpc"

# ç¼–æ’å™¨é…ç½®
[orchestrator]
max_reflection_rounds = 5              # æœ€å¤§åæ€è½®æ¬¡
task_timeout_secs = 300                # ä»»åŠ¡è¶…æ—¶ï¼ˆç§’ï¼‰
enable_auto_reflection = true          # å¯ç”¨è‡ªåŠ¨åæ€
success_threshold = 80.0               # æˆåŠŸè¯„åˆ†é˜ˆå€¼
max_concurrent_tasks = 10              # æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°

# ä¸¤é˜¶æ®µè§„åˆ’
enable_two_stage_planning = true       # å¯ç”¨ä¸¤é˜¶æ®µè§„åˆ’
two_stage_tool_threshold = 10          # å·¥å…·æ•°é‡é˜ˆå€¼
enable_builtin_workflows = true        # å¯ç”¨å†…ç½®å·¥ä½œæµ
tool_selection_threshold = 70.0        # å·¥å…·ç­›é€‰ç›¸ä¼¼åº¦é˜ˆå€¼

# å¹¶è¡Œæ‰§è¡Œ
enable_parallel_execution = true       # å¯ç”¨å¹¶è¡Œæ‰§è¡Œ
parallel_max_concurrent = 8            # æœ€å¤§å¹¶å‘æ•°
parallel_min_steps = 2                 # æœ€å°æ­¥éª¤æ•°é˜ˆå€¼

# æ­¥éª¤çº§åæ€é…ç½®
[reflection]
enable_step_level_reflection = true    # å¯ç”¨æ­¥éª¤çº§åæ€
max_step_retries = 3                   # å•ä¸ªæ­¥éª¤æœ€å¤§é‡è¯•æ¬¡æ•°
max_task_replanning_attempts = 1       # ä»»åŠ¡æœ€å¤§é‡æ–°è§„åˆ’æ¬¡æ•°

# å“åº”æ¶ˆæ¯é…ç½®
[response]
mode = "user"                          # "user" æˆ– "developer"

# è°ƒè¯•é…ç½®
[debug]
save_debug_log = false                 # æ˜¯å¦ä¿å­˜è°ƒè¯•æ—¥å¿—
debug_log_file = "debug_log.txt"       # è°ƒè¯•æ—¥å¿—æ–‡ä»¶è·¯å¾„

# æ—¥å¿—é…ç½®
[logging]
level = "info"
console = true
file = false
file_path = "logs/app.log"
format = "text"                        # "text" æˆ– "json"

# Consulé…ç½®ï¼ˆå¯é€‰ï¼‰
[consul]
enabled = false
host = "localhost"
port = 8500
service_name = "task-orchestration-service"
service_host = "127.0.0.1"
service_port = 8080
health_check_interval = 10
health_check_timeout = 5
health_check_url = "http://127.0.0.1:8080/health"

# Database Serviceé…ç½®
[database_service]
service_name = "database-service"
endpoint = "http://localhost:9001"
fallback_endpoint = "http://backup:9001"
connect_timeout_secs = 5
timeout_secs = 60
max_retries = 3
protocol = "grpc"
connection_string = "postgresql://user:password@localhost:5432/mydb"
max_connections = 20

# Kafka Serviceé…ç½®
[kafka_service]
enabled = false
brokers = ["localhost:9092"]
topic = "task-audit-log"
compression = "snappy"
connect_timeout_secs = 5
timeout_secs = 60
max_retries = 3
```

### 7.2 ç¯å¢ƒå˜é‡è¦†ç›–

**æ ¼å¼**: `APP_{SECTION}_{KEY}`

**ç¤ºä¾‹**:

```bash
# è¦†ç›–æœåŠ¡å™¨ç«¯å£
export APP_SERVER_PORT=9090

# è¦†ç›–LLMç«¯ç‚¹
export APP_LLM_ENDPOINT="http://new-llm-server:9000"

# å¯ç”¨å¹¶è¡Œæ‰§è¡Œ
export APP_ORCHESTRATOR_ENABLE_PARALLEL_EXECUTION=true

# è®¾ç½®æœ€å¤§å¹¶å‘æ•°
export APP_ORCHESTRATOR_PARALLEL_MAX_CONCURRENT=16
```

### 7.3 é…ç½®åŠ è½½ä¼˜å…ˆçº§

1. ç¯å¢ƒå˜é‡ (`APP_*`)
2. ç¯å¢ƒç‰¹å®šé…ç½®æ–‡ä»¶ (`config.{env}.toml`)
3. é»˜è®¤é…ç½®æ–‡ä»¶ (`config.toml`)
4. ä»£ç é»˜è®¤å€¼

**åŠ è½½é€»è¾‘** ([src/config/mod.rs:45](src/config/mod.rs#L45)):

```rust
pub fn load() -> Result<Self, config::ConfigError> {
    let env = std::env::var("APP_ENV").unwrap_or_else(|_| "dev".to_string());

    let builder = config::Config::builder()
        .add_source(config::File::with_name("config").required(false))
        .add_source(config::File::with_name(&format!("config.{}", env)).required(false))
        .add_source(config::Environment::with_prefix("APP").separator("_"));

    builder.build()?.try_deserialize()
}
```

---

## 8. æœåŠ¡å‘ç°ä¸é›†æˆ

### 8.1 ConsulæœåŠ¡å‘ç°

**æ¶æ„**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Orchestrator    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Unified Client Layer       â”‚
    â”‚  (LLM / Tool / Database)    â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Client with Discovery      â”‚
    â”‚  (æ”¯æŒæœåŠ¡å‘ç°)               â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Consul   â”‚    â”‚  Fallback  â”‚
    â”‚ Discovery â”‚â”€â”€â”€â–¶â”‚  Endpoint  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç»„ä»¶è¯´æ˜**:

1. **ConsulRegistry**: æœåŠ¡æ³¨å†Œ
   - ä½ç½®: [src/consul/registry.rs](src/consul/registry.rs)
   - åŠŸèƒ½: å°†å½“å‰æœåŠ¡æ³¨å†Œåˆ°Consul

2. **ServiceDiscovery**: æœåŠ¡å‘ç°
   - ä½ç½®: [src/consul/discovery.rs](src/consul/discovery.rs)
   - åŠŸèƒ½: æŸ¥è¯¢å…¶ä»–æœåŠ¡çš„å¥åº·å®ä¾‹

3. **ClientWithDiscovery**: æ”¯æŒæœåŠ¡å‘ç°çš„å®¢æˆ·ç«¯
   - LLMå®¢æˆ·ç«¯: [src/llm/client_with_discovery.rs](src/llm/client_with_discovery.rs)
   - Toolå®¢æˆ·ç«¯: [src/tool/client_with_discovery.rs](src/tool/client_with_discovery.rs)

### 8.2 è´Ÿè½½å‡è¡¡ç­–ç•¥

**æ”¯æŒçš„ç­–ç•¥**:

```rust
pub enum LoadBalanceStrategy {
    RoundRobin,    // è½®è¯¢
    Random,        // éšæœº
    Sticky,        // ç²˜æ€§ï¼ˆå§‹ç»ˆä½¿ç”¨åŒä¸€å®ä¾‹ï¼‰
}
```

**é…ç½®**:

```rust
let discovery = ServiceDiscovery::new(
    consul_registry,
    LoadBalanceStrategy::Sticky,
);
```

### 8.3 é™çº§æœºåˆ¶

**Fallbackç­–ç•¥**:

1. ä¼˜å…ˆä½¿ç”¨æœåŠ¡å‘ç°ï¼ˆå¦‚æœå¯ç”¨Consulï¼‰
2. æœåŠ¡å‘ç°å¤±è´¥æ—¶ä½¿ç”¨ `fallback_endpoint`
3. Fallbackå¤±è´¥æ—¶ä½¿ç”¨ä¸» `endpoint`

**ä»£ç ç¤ºä¾‹** ([src/llm/client_with_discovery.rs](src/llm/client_with_discovery.rs)):

```rust
async fn get_endpoint(&self) -> Result<String> {
    if let Some(ref discovery) = self.service_discovery {
        // å°è¯•æœåŠ¡å‘ç°
        match discovery.discover(&self.service_name).await {
            Ok(endpoint) => return Ok(endpoint),
            Err(e) => {
                warn!("æœåŠ¡å‘ç°å¤±è´¥: {}, ä½¿ç”¨å¤‡ç”¨ç«¯ç‚¹", e);
            }
        }
    }

    // ä½¿ç”¨å¤‡ç”¨ç«¯ç‚¹
    if let Some(ref fallback) = self.fallback_endpoint {
        Ok(fallback.clone())
    } else {
        Ok(self.endpoint.clone())
    }
}
```

### 8.4 å¥åº·æ£€æŸ¥

**é…ç½®**:

```toml
[consul]
health_check_interval = 10      # å¥åº·æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
health_check_timeout = 5         # å¥åº·æ£€æŸ¥è¶…æ—¶ï¼ˆç§’ï¼‰
health_check_url = "http://127.0.0.1:8080/health"
```

**å¥åº·æ£€æŸ¥ç«¯ç‚¹**:

```rust
// GET /health
async fn health_check() -> impl IntoResponse {
    Json(serde_json::json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now().to_rfc3339(),
    }))
}
```

---

## 9. æ—¥å¿—ä¸ç›‘æ§

### 9.1 æ—¥å¿—ç³»ç»Ÿ

**æ—¥å¿—å±‚çº§**:

- `ERROR`: ä¸¥é‡é”™è¯¯ï¼ˆéœ€è¦ç«‹å³å¤„ç†ï¼‰
- `WARN`: è­¦å‘Šï¼ˆå¯èƒ½å½±å“åŠŸèƒ½ï¼‰
- `INFO`: å…³é”®ä¿¡æ¯ï¼ˆæ­£å¸¸æµç¨‹ï¼‰
- `DEBUG`: è°ƒè¯•ä¿¡æ¯ï¼ˆå¼€å‘æ¨¡å¼ï¼‰
- `TRACE`: è¯¦ç»†è¿½è¸ªï¼ˆæ€§èƒ½åˆ†æï¼‰

**æ—¥å¿—è¾“å‡º**:

1. **æ§åˆ¶å°æ—¥å¿—**:
   - æ ¼å¼: å¯è¯»æ–‡æœ¬
   - é¢œè‰²: æ ¹æ®çº§åˆ«åŒºåˆ†
   - é…ç½®: `logging.console = true`

2. **æ–‡ä»¶æ—¥å¿—**:
   - æ ¼å¼: JSONæˆ–æ–‡æœ¬
   - è½®è½¬: æŒ‰å¤§å°æˆ–æ—¶é—´
   - é…ç½®: `logging.file = true`

3. **Kafkaæ—¥å¿—**ï¼ˆå®¡è®¡æ—¥å¿—ï¼‰:
   - æ ¼å¼: ç»“æ„åŒ–JSON
   - ç”¨é€”: é•¿æœŸå­˜å‚¨ã€æ•°æ®åˆ†æ
   - é…ç½®: `kafka_service.enabled = true`

### 9.2 Kafkaå®¡è®¡æ—¥å¿—

**æ—¥å¿—ç»“æ„**:

```json
{
  "timestamp": "2025-12-29T10:30:45.123Z",
  "service": "task-orchestration-service",
  "module": "orchestrator",
  "level": "INFO",
  "message": "ä»»åŠ¡æ‰§è¡Œå®Œæˆ",
  "task_id": "task_abc123",
  "fields": {
    "total_rounds": 1,
    "final_score": 85.0,
    "is_success": true,
    "total_duration_secs": 12
  }
}
```

**å…³é”®æ—¥å¿—ç‚¹**:

| é˜¶æ®µ | æ—¥å¿—äº‹ä»¶ |
|------|---------|
| è§„åˆ’ | å·¥å…·ç­›é€‰å®Œæˆã€è®¡åˆ’ç”Ÿæˆå®Œæˆ |
| æ‰§è¡Œ | æ­¥éª¤å¼€å§‹ã€æ­¥éª¤å®Œæˆã€æ­¥éª¤å¤±è´¥ |
| è¯„ä¼° | è¯„ä¼°å®Œæˆ |
| åæ€ | åæ€å®Œæˆã€é‡æ–°è§„åˆ’å†³ç­– |

### 9.3 è°ƒè¯•æ—¥å¿—

**åŠŸèƒ½**: ä¿å­˜LLMå“åº”å’Œå·¥å…·è°ƒç”¨è¯¦æƒ…åˆ°æ–‡ä»¶

**å¯ç”¨æ–¹å¼**:

```toml
[debug]
save_debug_log = true
debug_log_file = "debug_log.txt"
```

**è®°å½•å†…å®¹**:

- LLMæœ€ç»ˆæç¤ºè¯ï¼ˆSystem + Userï¼‰
- LLMåŸå§‹å“åº”
- å·¥å…·è°ƒç”¨å‚æ•°
- å·¥å…·æ‰§è¡Œç»“æœ
- å¹¶è¡Œæ‰§è¡Œå†³ç­–è¯¦æƒ…

**ä½ç½®**: [src/utils/debug_logger.rs](src/utils/debug_logger.rs)

---

## 10. APIæ¥å£

### 10.1 HTTP API

**åŸºç¡€è·¯å¾„**: `/api/v1`

#### åˆ›å»ºä»»åŠ¡

```
POST /api/v1/tasks
Content-Type: application/json

{
  "task_description": "åˆ†ææ•°æ®å¹¶ç”ŸæˆæŠ¥å‘Š",
  "metadata": {
    "project_id": "proj_123",
    "user_id": "user_456"
  },
  "context": {
    "session_id": "session_789",
    "previous_task_id": "task_prev"
  }
}

å“åº”:
{
  "task_id": "task_abc123",
  "status": "planning"
}
```

#### æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€

```
GET /api/v1/tasks/{task_id}

å“åº”:
{
  "task_id": "task_abc123",
  "status": "executing",
  "current_round": 1,
  "current_step": 2,
  "total_steps": 5
}
```

#### è·å–ä»»åŠ¡ç»“æœ

```
GET /api/v1/tasks/{task_id}/result

å“åº”:
{
  "task_id": "task_abc123",
  "is_success": true,
  "final_score": 85.0,
  "total_rounds": 1,
  "final_output": "ä»»åŠ¡æ‰§è¡Œç»“æœ...",
  "total_duration_secs": 12
}
```

### 10.2 gRPC API

**Protoå®šä¹‰**: [proto/orchestrator.proto](proto/orchestrator.proto)

#### ExecuteTask

```protobuf
rpc ExecuteTask(ExecuteTaskRequest) returns (stream ExecuteTaskResponse);

message ExecuteTaskRequest {
  string task_description = 1;
  map<string, string> metadata = 2;
  TaskContext context = 3;
}

message ExecuteTaskResponse {
  oneof event {
    TaskStarted task_started = 1;
    PlanGenerated plan_generated = 2;
    StepStarted step_started = 3;
    StepCompleted step_completed = 4;
    EvaluationCompleted evaluation_completed = 5;
    TaskCompleted task_completed = 6;
    TaskFailed task_failed = 7;
  }
}
```

**ç‰¹æ€§**:
- æ”¯æŒæµå¼å“åº”ï¼ˆå®æ—¶æ¨é€æ‰§è¡Œè¿›åº¦ï¼‰
- æ”¯æŒåŒå‘æµï¼ˆæœªæ¥å¯æ‰©å±•äº¤äº’å¼ä»»åŠ¡ï¼‰

---

## 11. æ€§èƒ½ä¼˜åŒ–

### 11.1 å¹¶è¡Œæ‰§è¡Œä¼˜åŒ–

**æ€§èƒ½æå‡**:
- æ— ä¾èµ–æ­¥éª¤å¹¶è¡Œæ‰§è¡Œï¼Œç†è®ºåŠ é€Ÿæ¯” = æ­¥éª¤æ•° / æ‰¹æ¬¡æ•°
- å®é™…åŠ é€Ÿæ¯”å—é™äºå·¥å…·æœåŠ¡æ€§èƒ½å’Œç½‘ç»œå»¶è¿Ÿ

**ç¤ºä¾‹**:

å‡è®¾ä¸€ä¸ªä»»åŠ¡åŒ…å«10ä¸ªæ­¥éª¤:
- å‰5ä¸ªæ­¥éª¤æ— ä¾èµ–ï¼ˆå¯å¹¶è¡Œï¼‰
- å5ä¸ªæ­¥éª¤ä¾èµ–å‰5ä¸ªï¼ˆå¯å¹¶è¡Œï¼‰

**ä¸²è¡Œæ‰§è¡Œ**: 10 Ã— å¹³å‡è€—æ—¶ = 100ç§’
**å¹¶è¡Œæ‰§è¡Œ**: 2æ‰¹ Ã— å¹³å‡è€—æ—¶ = 20ç§’
**åŠ é€Ÿæ¯”**: 5å€

### 11.2 LLMè°ƒç”¨ä¼˜åŒ–

**ç­–ç•¥**:

1. **æµå¼è¿”å›**:
   - å‡å°‘é¦–å­—èŠ‚æ—¶é—´ï¼ˆTTFBï¼‰
   - æå‡ç”¨æˆ·ä½“éªŒ
   - é…ç½®: `llm.enable_streaming = true`

2. **ä¸¤é˜¶æ®µè§„åˆ’**:
   - å‡å°‘LLMè¾“å…¥tokenæ•°
   - æå‡è§„åˆ’è´¨é‡
   - é€‚ç”¨äºå·¥å…·æ•°é‡å¤šçš„åœºæ™¯

3. **ç¼“å­˜æœºåˆ¶**ï¼ˆæœªæ¥ï¼‰:
   - ç¼“å­˜ç›¸ä¼¼ä»»åŠ¡çš„è§„åˆ’ç»“æœ
   - ç¼“å­˜å·¥å…·æè¿°

### 11.3 ç½‘ç»œä¼˜åŒ–

**ç­–ç•¥**:

1. **è¿æ¥æ± **:
   - gRPCå®¢æˆ·ç«¯å¤ç”¨è¿æ¥
   - HTTPå®¢æˆ·ç«¯ä½¿ç”¨è¿æ¥æ± 

2. **è¶…æ—¶æ§åˆ¶**:
   - åˆ†å±‚è¶…æ—¶è®¾ç½®ï¼ˆè¿æ¥è¶…æ—¶ã€è¯·æ±‚è¶…æ—¶ï¼‰
   - å¿«é€Ÿå¤±è´¥

3. **é‡è¯•ç­–ç•¥**:
   - æŒ‡æ•°é€€é¿
   - æœ€å¤§é‡è¯•æ¬¡æ•°é™åˆ¶

---

## 12. å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### 12.1 å¹¶è¡Œæ‰§è¡Œä¸ç”Ÿæ•ˆ

**ç—‡çŠ¶**: é…ç½®äº†å¹¶è¡Œæ‰§è¡Œï¼Œä½†æ—¥å¿—æ˜¾ç¤ºä¸²è¡Œæ‰§è¡Œ

**æ’æŸ¥æ­¥éª¤**:

1. æ£€æŸ¥é…ç½®:
   ```toml
   [orchestrator]
   enable_parallel_execution = true
   parallel_min_steps = 2
   ```

2. æ£€æŸ¥æ­¥éª¤æ•°é‡:
   - æ­¥éª¤æ•° â‰¥ `parallel_min_steps`

3. æ£€æŸ¥ä¾èµ–å…³ç³»:
   - ç¡®ä¿è‡³å°‘æœ‰2ä¸ªæ­¥éª¤å¯å¹¶è¡Œ
   - æŸ¥çœ‹è°ƒè¯•æ—¥å¿—ä¸­çš„ä¾èµ–åˆ†æ

4. æŸ¥çœ‹æ—¥å¿—:
   ```
   INFO ä½¿ç”¨ä¸²è¡Œæ‰§è¡Œæ¨¡å¼ï¼ŒåŸå› : æ­¥éª¤æ•°(1)å°‘äºé˜ˆå€¼(2)
   ```

### 12.2 æ­¥éª¤é‡è¯•å¤±è´¥

**ç—‡çŠ¶**: æ­¥éª¤é‡è¯•æ¬¡æ•°è¾¾åˆ°ä¸Šé™ï¼Œä»»åŠ¡å¤±è´¥

**è§£å†³æ–¹æ¡ˆ**:

1. è°ƒæ•´é‡è¯•æ¬¡æ•°:
   ```toml
   [reflection]
   max_step_retries = 5
   ```

2. å¯ç”¨ä»»åŠ¡é‡æ–°è§„åˆ’:
   ```toml
   [reflection]
   max_task_replanning_attempts = 2
   ```

3. æ£€æŸ¥å·¥å…·æœåŠ¡:
   - ç¡®ä¿å·¥å…·æœåŠ¡æ­£å¸¸è¿è¡Œ
   - æ£€æŸ¥å‚æ•°æ ¼å¼æ˜¯å¦æ­£ç¡®

### 12.3 æœåŠ¡å‘ç°å¤±è´¥

**ç—‡çŠ¶**: æ— æ³•è¿æ¥åˆ°LLMæˆ–ToolæœåŠ¡

**è§£å†³æ–¹æ¡ˆ**:

1. é…ç½®å¤‡ç”¨ç«¯ç‚¹:
   ```toml
   [llm]
   endpoint = "http://localhost:9000"
   fallback_endpoint = "http://backup:9000"
   ```

2. æ£€æŸ¥Consulè¿æ¥:
   ```bash
   curl http://localhost:8500/v1/health/service/llm-service
   ```

3. ä½¿ç”¨é™æ€ç«¯ç‚¹:
   ```toml
   [consul]
   enabled = false
   ```

---

## 13. æœ€ä½³å®è·µ

### 13.1 ä»»åŠ¡è®¾è®¡

1. **æ˜ç¡®ä»»åŠ¡æè¿°**: æä¾›è¯¦ç»†çš„ä»»åŠ¡ç›®æ ‡å’Œçº¦æŸæ¡ä»¶
2. **åˆç†è®¾ç½®å…ƒæ•°æ®**: å°†é€šç”¨å‚æ•°æ”¾å…¥metadataï¼Œé¿å…é‡å¤ä¼ é€’
3. **é¢„å®šä¹‰å·¥ä½œæµ**: ä¸ºå¸¸è§ä»»åŠ¡åˆ›å»ºæ ‡å‡†æµç¨‹æ¨¡æ¿

### 13.2 é…ç½®è°ƒä¼˜

1. **å¹¶è¡Œæ‰§è¡Œ**:
   - å¼€å‘ç¯å¢ƒ: å…³é—­ï¼ˆä¾¿äºè°ƒè¯•ï¼‰
   - ç”Ÿäº§ç¯å¢ƒ: å¼€å¯ï¼ˆæå‡æ€§èƒ½ï¼‰

2. **åæ€è½®æ¬¡**:
   - ç®€å•ä»»åŠ¡: 1-2è½®
   - å¤æ‚ä»»åŠ¡: 3-5è½®

3. **æˆåŠŸé˜ˆå€¼**:
   - ä¸¥æ ¼åœºæ™¯: 90.0
   - å®½æ¾åœºæ™¯: 70.0

### 13.3 ç›‘æ§ä¸å‘Šè­¦

1. **å…³é”®æŒ‡æ ‡**:
   - ä»»åŠ¡æˆåŠŸç‡
   - å¹³å‡æ‰§è¡Œæ—¶é—´
   - åæ€è§¦å‘ç‡
   - å·¥å…·è°ƒç”¨å¤±è´¥ç‡

2. **å‘Šè­¦è§„åˆ™**:
   - ä»»åŠ¡æˆåŠŸç‡ < 80%
   - å•æ¬¡ä»»åŠ¡è€—æ—¶ > 10åˆ†é’Ÿ
   - å·¥å…·æœåŠ¡è¿æ¥å¤±è´¥

---

## 14. æ€»ç»“

ä»»åŠ¡ç¼–æ’æœåŠ¡é€šè¿‡ **Reflective Planning** ç†å¿µï¼Œå®ç°äº†æ™ºèƒ½åŒ–çš„ä»»åŠ¡è§„åˆ’ä¸æ‰§è¡Œã€‚æ ¸å¿ƒç‰¹æ€§åŒ…æ‹¬:

1. **æ™ºèƒ½è§„åˆ’**: åŸºäºLLMçš„ä¸¤é˜¶æ®µè§„åˆ’ï¼Œè‡ªåŠ¨ç­›é€‰å·¥å…·å¹¶ç”Ÿæˆæ‰§è¡Œè®¡åˆ’
2. **å¹¶è¡Œæ‰§è¡Œ**: è‡ªåŠ¨è¯†åˆ«æ— ä¾èµ–æ­¥éª¤ï¼Œæ™ºèƒ½å¹¶è¡Œæ‰§è¡Œæå‡æ€§èƒ½
3. **è‡ªé€‚åº”åæ€**: æ”¯æŒä»»åŠ¡çº§å’Œæ­¥éª¤çº§åæ€ï¼Œè‡ªåŠ¨è°ƒæ•´æ‰§è¡Œç­–ç•¥
4. **çµæ´»é…ç½®**: æ”¯æŒç¯å¢ƒå˜é‡ã€é…ç½®æ–‡ä»¶å¤šå±‚çº§é…ç½®
5. **ç”Ÿäº§çº§ç‰¹æ€§**: æœåŠ¡å‘ç°ã€é™çº§æœºåˆ¶ã€å…¨é“¾è·¯ç›‘æ§

é€šè¿‡åˆç†é…ç½®å’Œä½¿ç”¨ï¼Œå¯ä»¥å®ç°é«˜æ•ˆã€å¯é çš„å¤æ‚ä»»åŠ¡è‡ªåŠ¨åŒ–ç¼–æ’ã€‚

---

**æ–‡æ¡£ç»´æŠ¤**:
- æ›´æ–°é¢‘ç‡: æ¯æ¬¡é‡å¤§ç‰ˆæœ¬å‘å¸ƒ
- ç»´æŠ¤äººå‘˜: æ¶æ„ç»„
- åé¦ˆæ¸ é“: GitHub Issues

**ç‰ˆæœ¬å†å²**:
- v1.0 (2025-12-29): åˆå§‹ç‰ˆæœ¬ï¼ŒåŸºäº parallel_execution_version åˆ†æ”¯
