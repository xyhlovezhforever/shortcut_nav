# 04 - 数据流转与参数解析机制

> **文档版本**: v1.0
> **创建日期**: 2026-01-05
> **迁移优先级**: ⭐⭐⭐⭐⭐ (最高)

---

## 1. 机制概述

数据流转机制是任务编排服务的核心能力之一，负责在多步骤执行过程中自动管理和传递数据。该机制确保前置步骤的输出能够正确地流转到后续步骤的输入。

### 1.1 核心能力

- **三层数据存储**: initial_metadata、runtime_metadata、step_results
- **智能参数解析**: 支持多种占位符格式
- **自动数据流转**: 步骤输出自动同步到metadata
- **重试保持**: 重规划时保留历史数据

---

## 2. 三层数据存储架构

### 2.1 架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                     ExecutionContext (执行上下文)                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 第1层: initial_metadata (初始元数据)                         │   │
│  │                                                             │   │
│  │ - 任务提交时由用户提供的全局数据                              │   │
│  │ - 只读，整个任务执行过程中不修改                              │   │
│  │ - 优先级最低                                                 │   │
│  │                                                             │   │
│  │ 示例:                                                        │   │
│  │   project_id: "proj_001"                                    │   │
│  │   file_path: "/data/load.csv"                               │   │
│  │   city_name: "杭州"                                         │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 第2层: runtime_metadata (运行时元数据)                       │   │
│  │                                                             │   │
│  │ - 动态流转，从步骤输出中提取的关键参数                        │   │
│  │ - 可读写，随执行过程更新                                      │   │
│  │ - 优先级高于 initial_metadata                                │   │
│  │                                                             │   │
│  │ 示例:                                                        │   │
│  │   datasource_id: "ds_001"      (来自 step_2 输出)           │   │
│  │   step_2_datasource_id: "ds_001"  (带步骤前缀)              │   │
│  │   model_id: "model_123"         (来自 step_5 输出)           │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 第3层: step_results (步骤执行结果)                           │   │
│  │                                                             │   │
│  │ - 完整保留每个步骤的执行结果                                  │   │
│  │ - 键: step_id, 值: StepExecutionResult                      │   │
│  │ - 用于占位符深度解析                                         │   │
│  │                                                             │   │
│  │ 示例:                                                        │   │
│  │   "step_1": {output: "{\"status\":\"success\"}", ...}       │   │
│  │   "step_2": {output: "{\"datasource_id\":\"ds_001\"}", ...} │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 优先级规则

参数解析时的查找优先级：

```
runtime_metadata > initial_metadata > step_results
```

即：
1. 先从 `runtime_metadata` 查找
2. 未找到则从 `initial_metadata` 查找
3. 最后从 `step_results` 深度解析

---

## 3. 占位符格式详解

### 3.1 支持的格式

| 格式 | 示例 | 说明 | 使用场景 |
|------|------|------|---------|
| **三重大括号** | `{{{step_1.outputs.id}}}` | Handlebars风格 | LLM常用 |
| **双大括号(outputs)** | `{{step_1.outputs.id}}` | 标准格式 | 推荐使用 |
| **双大括号(output)** | `{{step_1.output.id}}` | 兼容格式 | 向后兼容 |
| **简化格式** | `{{step_1.id}}` | 直接字段引用 | 简化写法 |
| **模板格式** | `${step_1.output.id}` | 模板占位符 | 特殊场景 |
| **纯字段名** | `{{datasource_id}}` | 从metadata查找 | 全局参数 |

### 3.2 解析优先级

```
1. 完整路径: {{step_id.outputs.field}} 或 {{step_id.output.field}}
   └─> 从 step_results 中解析

2. 简化路径: {{step_id.field}}
   └─> 先尝试 runtime_metadata
   └─> 再尝试 step_results

3. 纯字段名: {{field}}
   └─> 从 runtime_metadata 查找
   └─> 从 initial_metadata 查找
```

### 3.3 嵌套路径支持

支持深层JSON路径访问：

```json
// 步骤输出
{
  "result": {
    "data": {
      "model_id": "model_123"
    }
  }
}

// 占位符引用
"{{step_3.outputs.result.data.model_id}}"
// 解析结果: "model_123"
```

---

## 4. 数据流转流程

### 4.1 完整流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│                         数据流转完整流程                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────┐                                                   │
│  │ 1. 任务开始 │                                                   │
│  └──────┬──────┘                                                   │
│         │                                                           │
│         ▼                                                           │
│  ┌─────────────────────────────────────┐                           │
│  │ 2. 初始化 ExecutionContext          │                           │
│  │    - 创建三层存储结构               │                           │
│  │    - 加载 initial_metadata          │                           │
│  └──────┬──────────────────────────────┘                           │
│         │                                                           │
│         ▼                                                           │
│  ┌─────────────────────────────────────┐                           │
│  │ 3. 遍历执行步骤                      │◄──────────────────┐      │
│  └──────┬──────────────────────────────┘                   │      │
│         │                                                   │      │
│         ▼                                                   │      │
│  ┌─────────────────────────────────────┐                   │      │
│  │ 4. ParameterResolver 解析参数       │                   │      │
│  │    - 解析步骤参数JSON               │                   │      │
│  │    - 处理占位符                      │                   │      │
│  │    - 从 Context 提取实际值          │                   │      │
│  └──────┬──────────────────────────────┘                   │      │
│         │                                                   │      │
│         ▼                                                   │      │
│  ┌─────────────────────────────────────┐                   │      │
│  │ 5. 执行工具调用                      │                   │      │
│  └──────┬──────────────────────────────┘                   │      │
│         │                                                   │      │
│         ▼                                                   │      │
│  ┌────────────────┐                                        │      │
│  │ 6. 执行成功?   │                                        │      │
│  └───┬────────┬───┘                                        │      │
│      │是      │否                                           │      │
│      ▼        ▼                                             │      │
│  ┌──────────┐  ┌──────────┐                                │      │
│  │保存结果  │  │记录错误  │                                │      │
│  │到 step_  │  │触发反思  │                                │      │
│  │results   │  └──────────┘                                │      │
│  └────┬─────┘                                              │      │
│       │                                                     │      │
│       ▼                                                     │      │
│  ┌─────────────────────────────────────┐                   │      │
│  │ 7. 同步输出到 runtime_metadata      │                   │      │
│  │    - 获取工具 output_params 定义     │                   │      │
│  │    - 提取指定字段                   │                   │      │
│  │    - 写入 runtime_metadata          │                   │      │
│  └──────┬──────────────────────────────┘                   │      │
│         │                                                   │      │
│         ▼                                                   │      │
│  ┌────────────────┐                                        │      │
│  │ 8. 还有步骤?   │──────────────────────────────────是────┘      │
│  └───┬────────────┘                                               │
│      │否                                                           │
│      ▼                                                             │
│  ┌─────────────┐                                                   │
│  │ 9. 任务完成 │                                                   │
│  └─────────────┘                                                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 同步到 runtime_metadata 的逻辑

```rust
/// 将步骤输出同步到 runtime_metadata
fn sync_step_output_to_metadata(
    step_id: &str,
    tool_id: &str,
    step_output: &str,
    context: &ExecutionContext,
    available_tools: &[ToolInfo],
) {
    // 策略1: 从工具的 output_params 定义获取要同步的字段名
    let mut param_names: Vec<String> = Vec::new();

    if let Some(tool) = available_tools.iter().find(|t| t.id == tool_id) {
        if let Some(output_params_json) = &tool.output_params {
            if let Ok(Value::Object(obj)) = serde_json::from_str(output_params_json) {
                param_names = obj.keys().cloned().collect();
            }
        }
    }

    // 策略2: 如果没有 output_params 定义，从实际输出中自动提取
    if param_names.is_empty() {
        if let Ok(Value::Object(obj)) = serde_json::from_str(step_output) {
            param_names = obj.keys().cloned().collect();
        }
    }

    // 执行同步
    if !param_names.is_empty() {
        context.sync_step_output_to_runtime_metadata(step_id, &param_names);
    }
}
```

---

## 5. 实际应用示例

### 5.1 负荷预测流程示例

```
任务: 对某区域进行负荷预测，文件路径: /data/load.csv

初始 metadata:
{
  "project_id": "proj_001",
  "file_path": "/data/load.csv"
}

─────────────────────────────────────────────────────────────────

步骤1: check_csv_file (校验CSV文件)
  输入参数: {"file_path": "{{file_path}}"}
  解析后:   {"file_path": "/data/load.csv"}
  输出:     {"is_valid": true, "row_count": 1000}
  同步:     is_valid, row_count → runtime_metadata

─────────────────────────────────────────────────────────────────

步骤2: add_datasource (注册数据源)
  输入参数: {
    "project_id": "{{project_id}}",
    "file_path": "{{file_path}}"
  }
  解析后:   {"project_id": "proj_001", "file_path": "/data/load.csv"}
  输出:     {"datasource_id": "ds_001", "datasource_name": "my_datasource"}
  同步:     datasource_id, datasource_name → runtime_metadata

─────────────────────────────────────────────────────────────────

步骤3: data_upload (上传数据)
  输入参数: {
    "project_id": "{{project_id}}",
    "datasource_id": "{{step_2.outputs.datasource_id}}"
  }
  解析后:   {"project_id": "proj_001", "datasource_id": "ds_001"}
  输出:     {"upload_status": "success", "record_count": 1000}

─────────────────────────────────────────────────────────────────

步骤4: get_data (获取数据)
  输入参数: {"datasource_id": "{{datasource_id}}"}
  解析后:   {"datasource_id": "ds_001"}  # 从 runtime_metadata 获取
  输出:     {"data_json": "[...]", "record_count": 1000}
  同步:     data_json → runtime_metadata

─────────────────────────────────────────────────────────────────

... 后续步骤继续引用前面的输出 ...
```

### 5.2 引用方式对比

同一个参数，多种引用方式都有效：

```json
// 以下都能正确获取 step_2 的 datasource_id

// 方式1: 完整路径 (推荐)
"{{step_2.outputs.datasource_id}}"

// 方式2: output 别名
"{{step_2.output.datasource_id}}"

// 方式3: 三重大括号
"{{{step_2.outputs.datasource_id}}}"

// 方式4: 从 runtime_metadata 直接获取
"{{datasource_id}}"

// 方式5: 带步骤前缀从 runtime_metadata 获取
"{{step_2_datasource_id}}"
```

---

## 6. 重试与重规划时的数据保持

### 6.1 关键设计

在重试和重规划场景下，数据流转机制需要特殊处理：

```
┌─────────────────────────────────────────────────────────────────────┐
│                    重试/重规划时的数据保持                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  场景: step_3 执行失败，需要重试或重规划                              │
│                                                                     │
│  ┌─────────────────────────────────────┐                           │
│  │ step_1: 成功                        │                           │
│  │   output: {"data_id": "d1"}         │──┐                        │
│  └─────────────────────────────────────┘  │                        │
│                                           │ 保留                    │
│  ┌─────────────────────────────────────┐  │                        │
│  │ step_2: 成功                        │  │                        │
│  │   output: {"datasource_id": "ds1"}  │──┤                        │
│  └─────────────────────────────────────┘  │                        │
│                                           │                        │
│  ┌─────────────────────────────────────┐  │                        │
│  │ step_3: 失败 ❌                      │  │                        │
│  │   error: "参数错误"                  │  │                        │
│  └─────────────────────────────────────┘  │                        │
│                                           │                        │
│                   ▼                       │                        │
│  ┌─────────────────────────────────────┐  │                        │
│  │ 重规划生成新步骤:                    │  │                        │
│  │                                     │  │                        │
│  │ step_3_new: 修复后的步骤            │  │                        │
│  │   input: {                          │  │                        │
│  │     "datasource_id":                │◄─┘                        │
│  │       "{{step_2.outputs.datasource_id}}"                        │
│  │   }                                 │                           │
│  │   ✅ 可以引用之前成功步骤的输出      │                           │
│  └─────────────────────────────────────┘                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 6.2 ExecutionContext.clear() 的特殊处理

```rust
/// 清理执行上下文（重规划时调用）
pub fn clear(&self) {
    // 关键: 不清除 step_results 和 runtime_metadata
    // 这样重规划后的新步骤可以引用之前成功步骤的输出

    info!(
        plan_id = %self.plan_id.read().unwrap(),
        step_results_count = self.step_results.read().unwrap().len(),
        runtime_metadata_count = self.runtime_metadata.read().unwrap().len(),
        "执行上下文重置：保留已有的步骤结果和运行时元数据"
    );

    // 注意: 不执行以下操作
    // self.step_results.write().unwrap().clear();
    // self.runtime_metadata.write().unwrap().clear();
}
```

### 6.3 重试成功后的同步

重试成功后，必须同步输出到 metadata：

```rust
// 在 orchestrator.rs 中

// 参数调整重试成功
if retry_result.is_success {
    // 保存到 step_results
    context.set_step_result(retry_result.clone());

    // 关键: 同步到 runtime_metadata
    self.sync_step_output_to_metadata(
        &retry_result.step_id,
        &retry_result.tool_id,
        &retry_result.output,
        &context,
        &available_tools,
    );
}

// 备选工具重试成功 - 同样需要同步
// 单步修复成功 - 同样需要同步
```

---

## 7. 代码位置索引

### 7.1 核心文件

| 文件 | 关键方法 | 行号范围 | 功能 |
|------|---------|---------|------|
| `execution_context.rs` | `new()` | 54-62 | 创建上下文 |
| `execution_context.rs` | `init_metadata()` | 65-81 | 初始化metadata |
| `execution_context.rs` | `get_all_metadata()` | 97-130 | 获取合并后metadata |
| `execution_context.rs` | `sync_step_output_to_runtime_metadata()` | 196-309 | 同步输出 |
| `execution_context.rs` | `clear()` | 322-344 | 清理上下文 |
| `parameter_resolver.rs` | `resolve_parameters()` | 312-437 | 解析参数 |
| `parameter_resolver.rs` | `process_parameter_value()` | 526-785 | 处理占位符 |
| `parameter_resolver.rs` | `extract_from_step_output()` | 449-514 | 提取步骤输出 |
| `executor.rs` | 数据流转逻辑 | 406-501 | 执行后同步 |
| `orchestrator.rs` | `sync_step_output_to_metadata()` | 1575-1679 | 同步辅助函数 |

### 7.2 关键数据结构

```rust
// 执行上下文中的步骤结果
pub struct ExecutionContextStepResult {
    pub step_id: String,
    pub step_name: String,
    pub tool_id: String,
    pub output: String,      // JSON字符串
    pub is_success: bool,
    pub error_message: Option<String>,
}
```

---

## 8. 调试与问题排查

### 8.1 常见问题

#### 问题1: 参数没有正确传递

**症状**: 后续步骤收到的参数为占位符原文

**排查步骤**:
1. 检查前置步骤是否成功执行
2. 检查工具的 `output_params` 定义是否包含该字段
3. 检查步骤输出JSON是否包含该字段
4. 查看日志中的 "同步到runtime_metadata" 记录

#### 问题2: 占位符未被解析

**症状**: 参数值仍然是 `{{step_1.outputs.id}}` 形式

**排查步骤**:
1. 检查占位符格式是否正确
2. 确认引用的 step_id 是否存在
3. 确认字段路径是否正确
4. 使用 `context.get_all_metadata()` 检查可用参数

### 8.2 调试日志

```rust
// 在参数解析时添加调试日志
info!(
    step_id = %step.step_id,
    original_params = %step.parameters,
    resolved_params = ?parameters,
    "参数解析完成"
);

// 在数据同步时添加调试日志
info!(
    step_id = %step_id,
    synced_fields = ?param_names,
    sync_count = count,
    "同步输出到runtime_metadata"
);
```

---

## 9. 迁移检查项

- [ ] 实现 ExecutionContext 三层存储结构
- [ ] 实现 ParameterResolver 占位符解析
- [ ] 支持所有占位符格式（三重大括号、双大括号、模板格式）
- [ ] 实现嵌套JSON路径解析
- [ ] 实现步骤输出到metadata的自动同步
- [ ] 实现重规划时的数据保持
- [ ] 添加调试日志支持

---

## 下一步

阅读 [05-LLM交互与提示词系统.md](./05-LLM交互与提示词系统.md) 了解LLM交互和提示词设计。
