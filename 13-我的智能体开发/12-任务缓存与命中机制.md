# 任务缓存与命中机制

> **文档版本**: v1.0
> **创建日期**: 2026-01-05
> **适用场景**: 任务经验复用与执行计划缓存

---

## 1. 功能概述

任务缓存与命中机制是一个**智能计划复用系统**，核心功能：

- **保存成功经验**：将成功完成的任务执行计划保存到持久化存储
- **智能命中匹配**：当新任务描述与历史任务相似时，直接复用已验证的执行计划
- **跳过LLM规划**：命中缓存后无需调用LLM重新规划，大幅提升响应速度

```
┌─────────────────────────────────────────────────────────────────┐
│                    任务缓存与命中流程                             │
│                                                                  │
│  ┌──────────┐   是否命中？   ┌──────────────┐                    │
│  │  新任务   │──────────────>│   缓存查询    │                    │
│  └──────────┘               └───────┬──────┘                    │
│                                     │                           │
│              ┌──────────────────────┼──────────────────────┐    │
│              │                      │                      │    │
│              ▼                      ▼                      │    │
│      ┌──────────────┐       ┌──────────────┐               │    │
│      │   命中缓存    │       │   未命中     │               │    │
│      │ (跳过LLM)    │       │ (LLM规划)    │               │    │
│      └──────┬───────┘       └──────┬───────┘               │    │
│             │                      │                       │    │
│             ▼                      ▼                       │    │
│      ┌──────────────┐       ┌──────────────┐               │    │
│      │  直接执行     │       │  执行新计划   │               │    │
│      │  历史计划     │       │              │               │    │
│      └──────┬───────┘       └──────┬───────┘               │    │
│             │                      │                       │    │
│             │                      ▼                       │    │
│             │               ┌──────────────┐               │    │
│             │               │ 成功后保存到  │               │    │
│             │               │    缓存       │               │    │
│             │               └──────────────┘               │    │
│             │                      │                       │    │
│             └──────────────────────┴───────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 核心数据结构

### 2.1 TaskExperience - 任务经验

```rust
/// 任务经验结构
/// 存储成功完成的任务执行计划，用于后续复用
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskExperience {
    /// 任务唯一标识
    pub task_id: String,

    /// 任务描述（用于匹配）
    pub task_description: String,

    /// 执行计划（JSON格式）
    /// 包含完整的步骤定义和参数配置
    pub execution_plan: String,

    /// 执行轮次
    /// 记录完成此任务所经历的Reflective Planning轮次
    pub rounds: u32,

    /// 创建时间戳（毫秒）
    pub created_at: i64,
}

impl TaskExperience {
    /// 创建新的任务经验
    pub fn new(
        task_id: String,
        task_description: String,
        execution_plan: String,
        rounds: u32,
    ) -> Self {
        Self {
            task_id,
            task_description,
            execution_plan,
            rounds,
            created_at: chrono::Utc::now().timestamp_millis(),
        }
    }

    /// 从执行上下文创建任务经验
    pub fn from_context(context: &ExecutionContext) -> Self {
        Self {
            task_id: context.task_id.clone(),
            task_description: context.task_description.clone(),
            execution_plan: serde_json::to_string(&context.current_plan)
                .unwrap_or_default(),
            rounds: context.current_round,
            created_at: chrono::Utc::now().timestamp_millis(),
        }
    }
}
```

### 2.2 执行计划JSON结构

```json
{
  "plan_id": "plan_abc123",
  "task_description": "查询设备状态并生成报告",
  "steps": [
    {
      "step_id": "step_1",
      "step_name": "获取设备列表",
      "tool_id": "device_query",
      "parameters": {
        "filter": "active"
      },
      "dependencies": [],
      "output_mapping": {
        "devices": "$.data.devices"
      }
    },
    {
      "step_id": "step_2",
      "step_name": "查询设备详情",
      "tool_id": "device_detail",
      "parameters": {
        "device_id": "${step_1.devices[0].id}"
      },
      "dependencies": ["step_1"],
      "output_mapping": {
        "status": "$.data.status"
      }
    }
  ],
  "metadata": {
    "created_by": "planner",
    "version": "1.0"
  }
}
```

---

## 3. 存储层实现

### 3.1 RocksDB存储

```rust
use rocksdb::{DB, Options};

/// 任务经验存储
pub struct TaskExperienceStore {
    /// RocksDB实例
    db: DB,
    /// 存储路径
    path: PathBuf,
}

impl TaskExperienceStore {
    /// 创建或打开存储
    pub fn open(path: &str) -> Result<Self> {
        let mut opts = Options::default();
        opts.create_if_missing(true);
        opts.set_max_open_files(100);

        let db = DB::open(&opts, path)?;

        Ok(Self {
            db,
            path: PathBuf::from(path),
        })
    }

    /// 保存任务经验
    pub fn save(&self, experience: &TaskExperience) -> Result<()> {
        let key = self.build_key(&experience.task_description);
        let value = serde_json::to_vec(experience)?;
        self.db.put(key.as_bytes(), &value)?;
        Ok(())
    }

    /// 查询任务经验
    pub fn find(&self, task_description: &str) -> Result<Option<TaskExperience>> {
        let key = self.build_key(task_description);
        match self.db.get(key.as_bytes())? {
            Some(value) => {
                let experience: TaskExperience = serde_json::from_slice(&value)?;
                Ok(Some(experience))
            }
            None => Ok(None),
        }
    }

    /// 构建存储键
    /// 使用任务描述的哈希值作为键
    fn build_key(&self, task_description: &str) -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let mut hasher = DefaultHasher::new();
        task_description.hash(&mut hasher);
        format!("task_exp_{}", hasher.finish())
    }

    /// 列出所有任务经验
    pub fn list_all(&self) -> Result<Vec<TaskExperience>> {
        let mut experiences = Vec::new();
        let iter = self.db.iterator(rocksdb::IteratorMode::Start);

        for item in iter {
            let (_, value) = item?;
            if let Ok(exp) = serde_json::from_slice::<TaskExperience>(&value) {
                experiences.push(exp);
            }
        }

        Ok(experiences)
    }

    /// 删除过期经验
    pub fn cleanup_expired(&self, max_age_days: u32) -> Result<usize> {
        let cutoff = chrono::Utc::now().timestamp_millis()
            - (max_age_days as i64 * 24 * 60 * 60 * 1000);

        let mut deleted = 0;
        let iter = self.db.iterator(rocksdb::IteratorMode::Start);

        for item in iter {
            let (key, value) = item?;
            if let Ok(exp) = serde_json::from_slice::<TaskExperience>(&value) {
                if exp.created_at < cutoff {
                    self.db.delete(&key)?;
                    deleted += 1;
                }
            }
        }

        Ok(deleted)
    }
}
```

### 3.2 内存缓存层

```rust
use dashmap::DashMap;
use std::time::{Duration, Instant};

/// 内存缓存层
/// 提供快速访问，减少磁盘IO
pub struct TaskExperienceCache {
    /// 缓存数据
    cache: DashMap<String, (TaskExperience, Instant)>,
    /// 持久化存储
    store: TaskExperienceStore,
    /// 缓存TTL
    ttl: Duration,
}

impl TaskExperienceCache {
    /// 创建缓存
    pub fn new(store: TaskExperienceStore, ttl_secs: u64) -> Self {
        Self {
            cache: DashMap::new(),
            store,
            ttl: Duration::from_secs(ttl_secs),
        }
    }

    /// 查询经验（优先内存缓存）
    pub fn get(&self, task_description: &str) -> Option<TaskExperience> {
        let key = self.normalize_description(task_description);

        // 1. 检查内存缓存
        if let Some(entry) = self.cache.get(&key) {
            if entry.1.elapsed() < self.ttl {
                return Some(entry.0.clone());
            }
            // 过期移除
            drop(entry);
            self.cache.remove(&key);
        }

        // 2. 查询持久化存储
        if let Ok(Some(exp)) = self.store.find(task_description) {
            // 加入内存缓存
            self.cache.insert(key, (exp.clone(), Instant::now()));
            return Some(exp);
        }

        None
    }

    /// 保存经验（同时写入缓存和存储）
    pub fn save(&self, experience: TaskExperience) -> Result<()> {
        let key = self.normalize_description(&experience.task_description);

        // 1. 写入持久化存储
        self.store.save(&experience)?;

        // 2. 更新内存缓存
        self.cache.insert(key, (experience, Instant::now()));

        Ok(())
    }

    /// 规范化任务描述
    /// 移除多余空白，统一格式
    fn normalize_description(&self, description: &str) -> String {
        description
            .trim()
            .to_lowercase()
            .split_whitespace()
            .collect::<Vec<_>>()
            .join(" ")
    }
}
```

---

## 4. 命中触发机制

### 4.1 metadata["hit"]字段

任务命中通过请求中的 `metadata["hit"]` 字段触发：

```rust
/// 任务元数据中的命中配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HitConfig {
    /// 是否启用命中
    pub enabled: bool,

    /// 命中的任务ID（可选）
    /// 如果指定，则直接使用该任务的执行计划
    pub task_id: Option<String>,

    /// 相似度阈值（0.0-1.0）
    /// 用于语义匹配
    pub similarity_threshold: Option<f64>,
}

impl HitConfig {
    /// 从metadata解析
    pub fn from_metadata(metadata: &serde_json::Value) -> Option<Self> {
        metadata.get("hit").and_then(|v| {
            serde_json::from_value(v.clone()).ok()
        })
    }
}
```

### 4.2 请求示例

```json
{
  "task_id": "task_new_001",
  "task_description": "查询设备状态并生成报告",
  "metadata": {
    "hit": {
      "enabled": true,
      "similarity_threshold": 0.85
    }
  }
}
```

或指定具体任务ID：

```json
{
  "task_id": "task_new_002",
  "task_description": "查询设备状态",
  "metadata": {
    "hit": {
      "enabled": true,
      "task_id": "task_abc123"
    }
  }
}
```

---

## 5. Orchestrator集成

### 5.1 命中检查流程

```rust
impl Orchestrator {
    /// 执行任务编排
    pub async fn orchestrate(&self, request: OrchestrationRequest) -> Result<OrchestrationResult> {
        let context = ExecutionContext::new(request.clone());

        // 1. 检查是否启用命中
        if let Some(hit_config) = HitConfig::from_metadata(&request.metadata) {
            if hit_config.enabled {
                // 2. 尝试命中缓存
                if let Some(experience) = self.try_hit_cache(&request, &hit_config).await? {
                    tracing::info!(
                        task_id = %request.task_id,
                        hit_task_id = %experience.task_id,
                        "Task cache hit, skipping LLM planning"
                    );

                    // 3. 直接使用缓存的执行计划
                    return self.execute_cached_plan(context, experience).await;
                }
            }
        }

        // 4. 未命中，执行正常的Reflective Planning流程
        self.execute_with_planning(context).await
    }

    /// 尝试命中缓存
    async fn try_hit_cache(
        &self,
        request: &OrchestrationRequest,
        hit_config: &HitConfig,
    ) -> Result<Option<TaskExperience>> {
        // 如果指定了task_id，直接查找
        if let Some(task_id) = &hit_config.task_id {
            return self.experience_cache.get_by_id(task_id);
        }

        // 否则进行语义匹配
        let threshold = hit_config.similarity_threshold.unwrap_or(0.8);
        self.experience_cache.find_similar(
            &request.task_description,
            threshold,
        )
    }

    /// 执行缓存的计划
    async fn execute_cached_plan(
        &self,
        mut context: ExecutionContext,
        experience: TaskExperience,
    ) -> Result<OrchestrationResult> {
        // 解析缓存的执行计划
        let plan: ExecutionPlan = serde_json::from_str(&experience.execution_plan)?;

        // 设置当前计划
        context.current_plan = Some(plan);
        context.hit_source = Some(experience.task_id.clone());

        // 发送缓存命中事件
        self.send_event(OrchestrationEvent::CacheHit {
            task_id: context.task_id.clone(),
            source_task_id: experience.task_id.clone(),
            rounds_saved: experience.rounds,
        }).await;

        // 直接进入执行阶段
        self.executor.execute_plan(&mut context).await?;

        // 评估结果
        self.evaluator.evaluate(&mut context).await
    }
}
```

### 5.2 经验保存流程

```rust
impl Orchestrator {
    /// 保存成功的任务经验
    async fn save_task_experience(&self, context: &ExecutionContext) -> Result<()> {
        // 仅保存成功完成的任务
        if context.status != TaskStatus::Completed {
            return Ok(());
        }

        // 创建任务经验
        let experience = TaskExperience::from_context(context);

        // 保存到缓存
        self.experience_cache.save(experience.clone())?;

        tracing::info!(
            task_id = %context.task_id,
            rounds = context.current_round,
            "Task experience saved"
        );

        // 发送经验保存事件
        self.send_event(OrchestrationEvent::ExperienceSaved {
            task_id: context.task_id.clone(),
            plan_steps: context.current_plan.as_ref()
                .map(|p| p.steps.len())
                .unwrap_or(0),
        }).await;

        Ok(())
    }
}
```

---

## 6. 语义匹配

### 6.1 相似度计算

```rust
impl TaskExperienceCache {
    /// 查找相似任务
    pub fn find_similar(
        &self,
        task_description: &str,
        threshold: f64,
    ) -> Option<TaskExperience> {
        let all_experiences = self.store.list_all().ok()?;

        let mut best_match: Option<(TaskExperience, f64)> = None;

        for exp in all_experiences {
            let similarity = self.calculate_similarity(
                task_description,
                &exp.task_description,
            );

            if similarity >= threshold {
                if best_match.is_none() || similarity > best_match.as_ref().unwrap().1 {
                    best_match = Some((exp, similarity));
                }
            }
        }

        best_match.map(|(exp, _)| exp)
    }

    /// 计算文本相似度
    /// 使用Jaccard相似系数
    fn calculate_similarity(&self, text1: &str, text2: &str) -> f64 {
        let words1: HashSet<&str> = text1.split_whitespace().collect();
        let words2: HashSet<&str> = text2.split_whitespace().collect();

        let intersection = words1.intersection(&words2).count();
        let union = words1.union(&words2).count();

        if union == 0 {
            0.0
        } else {
            intersection as f64 / union as f64
        }
    }
}
```

### 6.2 高级语义匹配（可选）

```rust
/// 基于Embedding的语义匹配
pub struct SemanticMatcher {
    llm_client: Arc<UnifiedLlmClient>,
    embedding_cache: DashMap<String, Vec<f64>>,
}

impl SemanticMatcher {
    /// 计算语义相似度
    pub async fn semantic_similarity(
        &self,
        text1: &str,
        text2: &str,
    ) -> Result<f64> {
        let emb1 = self.get_embedding(text1).await?;
        let emb2 = self.get_embedding(text2).await?;

        Ok(self.cosine_similarity(&emb1, &emb2))
    }

    /// 获取文本Embedding
    async fn get_embedding(&self, text: &str) -> Result<Vec<f64>> {
        // 检查缓存
        if let Some(emb) = self.embedding_cache.get(text) {
            return Ok(emb.clone());
        }

        // 调用LLM获取Embedding
        let embedding = self.llm_client.get_embedding(text).await?;

        // 缓存结果
        self.embedding_cache.insert(text.to_string(), embedding.clone());

        Ok(embedding)
    }

    /// 余弦相似度
    fn cosine_similarity(&self, a: &[f64], b: &[f64]) -> f64 {
        let dot: f64 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
        let norm_a: f64 = a.iter().map(|x| x * x).sum::<f64>().sqrt();
        let norm_b: f64 = b.iter().map(|x| x * x).sum::<f64>().sqrt();

        if norm_a == 0.0 || norm_b == 0.0 {
            0.0
        } else {
            dot / (norm_a * norm_b)
        }
    }
}
```

---

## 7. 事件通知

### 7.1 TaskExperience事件

当任务成功完成并保存经验后，系统会向客户端推送事件：

```protobuf
// Proto定义
message TaskExperienceEvent {
    string task_id = 1;
    string task_description = 2;
    string execution_plan = 3;
    uint32 rounds = 4;
    int64 created_at = 5;
}
```

### 7.2 事件推送实现

```rust
impl Orchestrator {
    /// 推送任务经验事件
    async fn push_experience_event(
        &self,
        experience: &TaskExperience,
        event_tx: &mpsc::Sender<StreamEvent>,
    ) -> Result<()> {
        let event = StreamEvent::TaskExperience {
            task_id: experience.task_id.clone(),
            task_description: experience.task_description.clone(),
            execution_plan: experience.execution_plan.clone(),
            rounds: experience.rounds,
            created_at: experience.created_at,
        };

        event_tx.send(event).await?;

        Ok(())
    }
}
```

### 7.3 客户端处理示例

```rust
// 客户端处理TaskExperience事件
async fn handle_experience_event(event: TaskExperienceEvent) {
    println!("Task experience received:");
    println!("  Task ID: {}", event.task_id);
    println!("  Description: {}", event.task_description);
    println!("  Rounds: {}", event.rounds);

    // 可以将此经验用于后续的命中请求
    let hit_request = OrchestrationRequest {
        task_id: generate_task_id(),
        task_description: "类似的任务描述".to_string(),
        metadata: json!({
            "hit": {
                "enabled": true,
                "task_id": event.task_id  // 使用返回的task_id
            }
        }),
        ..Default::default()
    };
}
```

---

## 8. 配置选项

### 8.1 缓存配置

```toml
# config.toml

[task_cache]
# 是否启用任务缓存
enabled = true

# RocksDB存储路径
storage_path = "./data/task_experience"

# 内存缓存TTL（秒）
memory_cache_ttl_secs = 3600

# 经验最大保留天数
max_age_days = 30

# 默认相似度阈值
default_similarity_threshold = 0.8
```

### 8.2 环境变量

```bash
# 启用/禁用任务缓存
export TASK_CACHE_ENABLED=true

# 存储路径
export TASK_CACHE_PATH=./data/task_experience

# 内存缓存TTL
export TASK_CACHE_TTL=3600
```

---

## 9. 性能优势

### 9.1 对比分析

| 指标 | 无缓存命中 | 有缓存命中 | 提升 |
|------|-----------|-----------|------|
| LLM调用次数 | 2-5次 | 0次 | 100% |
| 规划延迟 | 3-10秒 | <100ms | 95%+ |
| Token消耗 | 2000-8000 | 0 | 100% |
| 总执行时间 | 10-30秒 | 5-15秒 | 50%+ |

### 9.2 适用场景

- **重复性任务**：相同或相似的任务描述频繁出现
- **模板化流程**：标准化的业务流程
- **批量处理**：同类任务的批量执行
- **测试验证**：开发测试阶段的重复执行

---

## 10. 迁移实现清单

### 10.1 数据结构

- [ ] 实现 `TaskExperience` 结构
- [ ] 实现 `HitConfig` 解析
- [ ] 定义Proto消息类型

### 10.2 存储层

- [ ] 集成RocksDB依赖
- [ ] 实现 `TaskExperienceStore`
- [ ] 实现 `TaskExperienceCache` 内存层
- [ ] 实现过期清理机制

### 10.3 核心逻辑

- [ ] 在Orchestrator中集成命中检查
- [ ] 实现 `try_hit_cache` 方法
- [ ] 实现 `execute_cached_plan` 方法
- [ ] 实现 `save_task_experience` 方法

### 10.4 语义匹配

- [ ] 实现基础Jaccard相似度
- [ ] （可选）集成Embedding语义匹配

### 10.5 事件通知

- [ ] 实现TaskExperience事件推送
- [ ] 集成到gRPC流式响应

---

## 11. 相关文档

- [02-核心架构设计](./02-核心架构设计.md) - Reflective Planning循环
- [03-核心模块实现详解](./03-核心模块实现详解.md) - Orchestrator实现
- [04-数据流转与参数解析机制](./04-数据流转与参数解析机制.md) - ExecutionContext结构
- [08-API与服务接口](./08-API与服务接口.md) - 事件类型定义

---

**文档维护者**: Task Orchestration Team
**最后更新**: 2026-01-05
