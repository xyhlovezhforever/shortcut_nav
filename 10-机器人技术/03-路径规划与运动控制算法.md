# 路径规划与运动控制算法

## 引言：从A到B的智慧之路

如何让机器人从当前位置安全、快速、平滑地到达目标？这看似简单的问题，背后涉及复杂的算法和数学。**路径规划（Path Planning）**和**运动控制（Motion Control）**是移动机器人的大脑和小脑——前者决定"走哪条路"，后者决定"怎么走"。

从仓库AGV到无人驾驶，从无人机送货到手术机器人，路径规划与运动控制无处不在。本文将深入探讨经典算法、现代方法和实际应用。

---

## 一、路径规划概述

### 1.1 问题定义

**输入：**
- 起点 s
- 终点 g
- 地图/环境模型
- 机器人模型（几何、运动约束）

**输出：**
- 可行路径 π = (s, ..., g)
- 满足约束：无碰撞、可达、平滑

### 1.2 路径规划分类

#### **按维度分类**

1. **2D规划**：平面移动机器人
2. **3D规划**：无人机、水下机器人
3. **高维规划**：机械臂（关节空间）

#### **按环境分类**

1. **静态环境**：障碍物固定
2. **动态环境**：障碍物移动
3. **未知环境**：边探索边规划

#### **按方法分类**

1. **基于搜索**：Dijkstra、A*、JPS
2. **基于采样**：RRT、PRM
3. **基于优化**：梯度下降、优化算法
4. **基于学习**：强化学习、模仿学习

---

## 二、基于搜索的规划

### 2.1 Dijkstra算法

**思想：**从起点开始，逐步扩展到所有可达节点，保证找到最短路径。

**算法：**

```python
import heapq
import numpy as np

def dijkstra(grid, start, goal):
    """
    Dijkstra路径规划

    grid: 二维栅格地图 (0: 空闲, 1: 障碍)
    start: 起点 (row, col)
    goal: 终点 (row, col)
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    cost = np.full_like(grid, np.inf, dtype=float)
    parent = {}

    cost[start] = 0
    heap = [(0, start)]

    while heap:
        current_cost, current = heapq.heappop(heap)

        if current == goal:
            # 回溯路径
            path = []
            while current in parent:
                path.append(current)
                current = parent[current]
            path.append(start)
            return path[::-1]

        if visited[current]:
            continue
        visited[current] = True

        # 扩展邻居（8方向）
        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1),
                      (-1,-1), (-1,1), (1,-1), (1,1)]:
            nr, nc = current[0] + dr, current[1] + dc

            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 0:
                move_cost = 1.414 if abs(dr) + abs(dc) == 2 else 1.0
                new_cost = cost[current] + move_cost

                if new_cost < cost[nr, nc]:
                    cost[nr, nc] = new_cost
                    parent[(nr, nc)] = current
                    heapq.heappush(heap, (new_cost, (nr, nc)))

    return None  # 无解
```

**特点：**
- 保证最优
- 复杂度O((V + E) log V)
- 无启发式，搜索面积大

### 2.2 A*算法

**核心思想：**引入启发函数，优先扩展更有希望的节点。

**评价函数：**
```
f(n) = g(n) + h(n)

g(n): 从起点到n的实际代价
h(n): 从n到终点的启发式估计
```

**常用启发函数：**

1. **欧几里得距离**
   ```
   h(n) = ||n - goal||₂
   ```

2. **曼哈顿距离**（4方向移动）
   ```
   h(n) = |n_x - goal_x| + |n_y - goal_y|
   ```

3. **对角距离**（8方向移动）
   ```
   h(n) = max(|Δx|, |Δy|) + (√2 - 1) min(|Δx|, |Δy|)
   ```

**A*实现：**

```python
def astar(grid, start, goal):
    """A*路径规划"""
    rows, cols = grid.shape
    closed_set = set()
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}

    open_heap = [(f_score[start], start)]

    def heuristic(a, b):
        """欧几里得距离"""
        return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

    while open_heap:
        _, current = heapq.heappop(open_heap)

        if current == goal:
            # 重构路径
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]

        closed_set.add(current)

        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1),
                      (-1,-1), (-1,1), (1,-1), (1,1)]:
            neighbor = (current[0] + dr, current[1] + dc)

            if (neighbor[0] < 0 or neighbor[0] >= rows or
                neighbor[1] < 0 or neighbor[1] >= cols or
                grid[neighbor] == 1 or
                neighbor in closed_set):
                continue

            move_cost = 1.414 if abs(dr) + abs(dc) == 2 else 1.0
            tentative_g = g_score[current] + move_cost

            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g
                f_score[neighbor] = tentative_g + heuristic(neighbor, goal)
                heapq.heappush(open_heap, (f_score[neighbor], neighbor))

    return None
```

**优化：A*变种**

1. **Weighted A***
   ```
   f(n) = g(n) + ε h(n),  ε > 1

   ε越大，搜索越快，但路径可能次优
   ```

2. **Bidirectional A***
   - 从起点和终点同时搜索
   - 中间相遇即停止

3. **Anytime A***
   - 先快速找到次优解
   - 逐步改进至最优

### 2.3 JPS（Jump Point Search）

**思想：**在A*基础上，跳过中间冗余节点，减少扩展数量。

**跳点规则：**

1. **强制邻居**：必须考虑的邻居
2. **跳跃**：沿一个方向直线跳跃，直到遇到障碍或强制邻居

**特点：**
- 加速10-30倍
- 路径与A*相同
- 适合大规模栅格地图

### 2.4 D* Lite

**适用场景：**动态环境，障碍物出现/消失。

**核心思想：**
- 从goal到start反向搜索
- 增量更新：仅重新计算受影响部分
- 机器人移动时持续规划

**应用：**
- 火星探测车（Opportunity）
- 动态环境导航

---

## 三、基于采样的规划

### 3.1 PRM（Probabilistic Roadmap）

**两阶段：**

**1. 学习阶段（离线）**
```
重复：
    随机采样配置 q
    if 无碰撞:
        添加到路线图V
        连接附近节点（局部规划器）
```

**2. 查询阶段（在线）**
```
连接 start 和 goal 到路线图
在路线图上搜索最短路径（Dijkstra/A*）
```

**Python实现（简化）：**

```python
class PRM:
    def __init__(self, map_bounds, obstacle_checker, n_samples=500, k_nearest=10):
        self.map_bounds = map_bounds
        self.obstacle_checker = obstacle_checker
        self.n_samples = n_samples
        self.k_nearest = k_nearest
        self.roadmap = []
        self.edges = []

    def sample_free_configuration(self):
        """随机采样无碰撞配置"""
        while True:
            x = np.random.uniform(*self.map_bounds[0])
            y = np.random.uniform(*self.map_bounds[1])
            if not self.obstacle_checker(x, y):
                return (x, y)

    def build_roadmap(self):
        """构建路线图"""
        print("构建路线图...")

        # 采样节点
        for _ in range(self.n_samples):
            node = self.sample_free_configuration()
            self.roadmap.append(node)

        # 连接节点
        from sklearn.neighbors import NearestNeighbors
        nn = NearestNeighbors(n_neighbors=self.k_nearest)
        nn.fit(self.roadmap)

        for i, node in enumerate(self.roadmap):
            _, indices = nn.kneighbors([node])
            for j in indices[0]:
                if i != j and self.is_collision_free_path(node, self.roadmap[j]):
                    self.edges.append((i, j))

    def is_collision_free_path(self, p1, p2, resolution=0.1):
        """检查路径是否无碰撞"""
        dist = np.linalg.norm(np.array(p2) - np.array(p1))
        steps = int(dist / resolution)

        for i in range(steps + 1):
            alpha = i / steps
            x = p1[0] + alpha * (p2[0] - p1[0])
            y = p1[1] + alpha * (p2[1] - p1[1])
            if self.obstacle_checker(x, y):
                return False
        return True

    def query(self, start, goal):
        """查询路径"""
        # 连接start和goal到路线图
        roadmap_with_endpoints = self.roadmap + [start, goal]
        n = len(roadmap_with_endpoints)

        # 构建邻接表
        adj = {i: [] for i in range(n)}
        for i, j in self.edges:
            adj[i].append(j)
            adj[j].append(i)

        # 连接start和goal
        start_idx = n - 2
        goal_idx = n - 1

        # ...（使用A*在路线图上搜索）
```

**优点：**
- 适合高维空间
- 多次查询高效

**缺点：**
- 离线构建耗时
- 狭窄通道难以采样

### 3.2 RRT（Rapidly-exploring Random Tree）

**单查询算法，逐步生长树。**

**基本RRT：**

```python
class RRT:
    def __init__(self, start, goal, map_bounds, obstacle_checker,
                 step_size=0.5, max_iter=5000):
        self.start = np.array(start)
        self.goal = np.array(goal)
        self.map_bounds = map_bounds
        self.obstacle_checker = obstacle_checker
        self.step_size = step_size
        self.max_iter = max_iter

        self.tree = [start]
        self.parent = {0: None}

    def sample_random_point(self):
        """随机采样（有一定概率采样目标点）"""
        if np.random.rand() < 0.05:
            return self.goal
        else:
            x = np.random.uniform(*self.map_bounds[0])
            y = np.random.uniform(*self.map_bounds[1])
            return np.array([x, y])

    def nearest_node(self, point):
        """找最近节点"""
        distances = [np.linalg.norm(np.array(node) - point) for node in self.tree]
        return np.argmin(distances)

    def steer(self, from_node, to_point):
        """从from_node向to_point扩展step_size"""
        direction = to_point - np.array(self.tree[from_node])
        distance = np.linalg.norm(direction)

        if distance < self.step_size:
            return to_point
        else:
            return np.array(self.tree[from_node]) + (direction / distance) * self.step_size

    def is_collision_free(self, from_idx, to_point, resolution=0.05):
        """检查路径是否无碰撞"""
        from_point = np.array(self.tree[from_idx])
        dist = np.linalg.norm(to_point - from_point)
        steps = int(dist / resolution)

        for i in range(steps + 1):
            alpha = i / steps
            x = from_point[0] + alpha * (to_point[0] - from_point[0])
            y = from_point[1] + alpha * (to_point[1] - from_point[1])
            if self.obstacle_checker(x, y):
                return False
        return True

    def plan(self):
        """RRT规划"""
        for _ in range(self.max_iter):
            # 1. 随机采样
            rand_point = self.sample_random_point()

            # 2. 找最近节点
            nearest_idx = self.nearest_node(rand_point)

            # 3. 扩展
            new_point = self.steer(nearest_idx, rand_point)

            # 4. 碰撞检测
            if self.is_collision_free(nearest_idx, new_point):
                # 添加到树
                new_idx = len(self.tree)
                self.tree.append(new_point.tolist())
                self.parent[new_idx] = nearest_idx

                # 检查是否到达目标
                if np.linalg.norm(new_point - self.goal) < self.step_size:
                    # 回溯路径
                    path = [self.goal.tolist()]
                    current = new_idx
                    while current is not None:
                        path.append(self.tree[current])
                        current = self.parent[current]
                    return path[::-1]

        return None  # 未找到路径
```

**RRT***（RRT-star）：

**改进：**重新连线（rewire），找到更优路径。

```python
def rrt_star(self):
    """RRT*算法"""
    cost = {0: 0}  # 从起点到每个节点的代价

    for _ in range(self.max_iter):
        rand_point = self.sample_random_point()
        nearest_idx = self.nearest_node(rand_point)
        new_point = self.steer(nearest_idx, rand_point)

        if not self.is_collision_free(nearest_idx, new_point):
            continue

        # 找附近节点
        radius = min(self.step_size * 2, 50 * (np.log(len(self.tree)) / len(self.tree))**0.5)
        near_indices = self.near_nodes(new_point, radius)

        # 选择代价最小的父节点
        min_cost = cost[nearest_idx] + np.linalg.norm(new_point - self.tree[nearest_idx])
        min_idx = nearest_idx

        for idx in near_indices:
            edge_cost = np.linalg.norm(new_point - self.tree[idx])
            if cost[idx] + edge_cost < min_cost:
                if self.is_collision_free(idx, new_point):
                    min_cost = cost[idx] + edge_cost
                    min_idx = idx

        # 添加新节点
        new_idx = len(self.tree)
        self.tree.append(new_point.tolist())
        self.parent[new_idx] = min_idx
        cost[new_idx] = min_cost

        # 重新连线（Rewire）
        for idx in near_indices:
            edge_cost = np.linalg.norm(np.array(self.tree[idx]) - new_point)
            if cost[new_idx] + edge_cost < cost[idx]:
                if self.is_collision_free(new_idx, self.tree[idx]):
                    self.parent[idx] = new_idx
                    cost[idx] = cost[new_idx] + edge_cost
```

**RRT-Connect：**

双向RRT，从起点和终点同时生长，加快搜索。

---

## 四、轨迹优化

### 4.1 路径平滑

**问题：**A*/RRT生成的路径折线化，不适合实际执行。

**方法1：简化路径**

移除冗余点：
```python
def simplify_path(path, obstacle_checker):
    """移除冗余点"""
    if len(path) <= 2:
        return path

    simplified = [path[0]]
    i = 0

    while i < len(path) - 1:
        j = len(path) - 1
        while j > i + 1:
            if is_line_collision_free(path[i], path[j], obstacle_checker):
                break
            j -= 1
        simplified.append(path[j])
        i = j

    return simplified
```

**方法2：样条插值**

B样条/贝塞尔曲线平滑：
```python
from scipy.interpolate import splprep, splev

def smooth_path_spline(path, num_points=100):
    """B样条平滑"""
    path = np.array(path)
    tck, u = splprep([path[:, 0], path[:, 1]], s=0)
    u_new = np.linspace(0, 1, num_points)
    smooth_path = splev(u_new, tck)
    return np.column_stack(smooth_path)
```

### 4.2 时间最优轨迹

**考虑速度、加速度约束，生成时间最优轨迹。**

**梯形速度曲线：**

```python
def trapezoidal_velocity_profile(total_distance, v_max, a_max):
    """梯形速度规划"""
    # 加速到最大速度需要的距离
    d_accel = v_max**2 / (2 * a_max)

    if 2 * d_accel <= total_distance:
        # 能达到最大速度
        t_accel = v_max / a_max
        t_const = (total_distance - 2 * d_accel) / v_max
        t_decel = t_accel
        total_time = t_accel + t_const + t_decel
    else:
        # 三角形速度曲线
        v_peak = np.sqrt(total_distance * a_max)
        t_accel = v_peak / a_max
        t_const = 0
        t_decel = t_accel
        total_time = 2 * t_accel

    return {
        't_accel': t_accel,
        't_const': t_const,
        't_decel': t_decel,
        'total_time': total_time
    }
```

### 4.3 最小抖动轨迹

**五次多项式满足位置、速度、加速度边界条件：**

```python
def quintic_polynomial_trajectory(q0, q1, v0, v1, a0, a1, T):
    """五次多项式轨迹生成"""
    # 求解系数
    A = np.array([
        [1, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0],
        [0, 0, 2, 0, 0, 0],
        [1, T, T**2, T**3, T**4, T**5],
        [0, 1, 2*T, 3*T**2, 4*T**3, 5*T**4],
        [0, 0, 2, 6*T, 12*T**2, 20*T**3]
    ])

    b = np.array([q0, v0, a0, q1, v1, a1])
    coeffs = np.linalg.solve(A, b)

    def position(t):
        return np.polyval(coeffs[::-1], t)

    def velocity(t):
        return np.polyval(np.polyder(coeffs[::-1]), t)

    def acceleration(t):
        return np.polyval(np.polyder(coeffs[::-1], 2), t)

    return position, velocity, acceleration
```

---

## 五、运动控制

### 5.1 差速驱动机器人

**运动学模型：**
```
ẋ = v cos(θ)
ẏ = v sin(θ)
θ̇ = ω

控制输入：[v, ω] （线速度、角速度）
```

**Pure Pursuit控制器：**

```python
class PurePursuitController:
    def __init__(self, lookahead_distance=1.0, max_linear_vel=1.0, max_angular_vel=1.0):
        self.lookahead_distance = lookahead_distance
        self.max_linear_vel = max_linear_vel
        self.max_angular_vel = max_angular_vel

    def find_lookahead_point(self, path, robot_pose):
        """找前瞻点"""
        x, y, theta = robot_pose

        for i in range(len(path) - 1):
            p1 = np.array(path[i])
            p2 = np.array(path[i + 1])
            robot_pos = np.array([x, y])

            # 计算最近点
            v = p2 - p1
            u = robot_pos - p1
            t = np.clip(np.dot(u, v) / (np.dot(v, v) + 1e-6), 0, 1)
            closest_point = p1 + t * v

            dist = np.linalg.norm(closest_point - robot_pos)

            if dist >= self.lookahead_distance:
                # 计算交点
                lookahead_point = closest_point
                return lookahead_point

        return path[-1]

    def compute_control(self, robot_pose, path):
        """计算控制命令"""
        x, y, theta = robot_pose

        # 找前瞻点
        lookahead_point = self.find_lookahead_point(path, robot_pose)

        # 转换到机器人坐标系
        dx = lookahead_point[0] - x
        dy = lookahead_point[1] - y

        # 机器人坐标系下的前瞻点
        lookahead_x = dx * np.cos(theta) + dy * np.sin(theta)
        lookahead_y = -dx * np.sin(theta) + dy * np.cos(theta)

        # Pure Pursuit公式
        curvature = 2 * lookahead_y / (lookahead_x**2 + lookahead_y**2 + 1e-6)

        # 计算控制
        v = self.max_linear_vel
        omega = v * curvature
        omega = np.clip(omega, -self.max_angular_vel, self.max_angular_vel)

        return v, omega
```

**Stanley控制器：**

```python
def stanley_control(robot_pose, path, k=0.5, k_soft=1.0):
    """
    Stanley控制器

    k: 增益系数
    k_soft: 软化系数
    """
    x, y, theta, v = robot_pose

    # 找最近路径点
    path_array = np.array(path)
    distances = np.linalg.norm(path_array - np.array([x, y]), axis=1)
    nearest_idx = np.argmin(distances)

    # 横向误差
    nearest_point = path[nearest_idx]
    cross_track_error = distances[nearest_idx]

    # 计算误差符号（左正右负）
    path_heading = np.arctan2(path[nearest_idx+1][1] - nearest_point[1],
                              path[nearest_idx+1][0] - nearest_point[0])

    heading_error = path_heading - theta
    heading_error = np.arctan2(np.sin(heading_error), np.cos(heading_error))

    cross_track_term = np.arctan(k * cross_track_error / (v + k_soft))

    # 总转向角
    steering = heading_error + cross_track_term

    return steering
```

### 5.2 Ackermann转向车辆

**运动学模型（自行车模型）：**
```
ẋ = v cos(θ)
ẏ = v sin(θ)
θ̇ = (v / L) tan(δ)

δ: 前轮转角
L: 轴距
```

**MPC控制：**

```python
import casadi as ca

class MPCController:
    def __init__(self, L=2.5, dt=0.1, N=10):
        self.L = L
        self.dt = dt
        self.N = N

        # 构建优化问题
        self.build_optimizer()

    def bicycle_model(self, state, control):
        """自行车模型"""
        x, y, theta, v = state
        a, delta = control

        x_dot = v * ca.cos(theta)
        y_dot = v * ca.sin(theta)
        theta_dot = v * ca.tan(delta) / self.L
        v_dot = a

        return ca.vertcat(x_dot, y_dot, theta_dot, v_dot)

    def build_optimizer(self):
        """构建MPC优化器"""
        # 状态和控制变量
        x = ca.MX.sym('x', 4, self.N+1)
        u = ca.MX.sym('u', 2, self.N)
        ref = ca.MX.sym('ref', 4, self.N+1)

        # 代价函数
        Q = ca.diag([1.0, 1.0, 0.5, 0.1])
        R = ca.diag([0.1, 0.1])

        cost = 0
        g = []  # 约束

        for k in range(self.N):
            # 阶段代价
            cost += ca.mtimes([(x[:, k] - ref[:, k]).T, Q, x[:, k] - ref[:, k]])
            cost += ca.mtimes([u[:, k].T, R, u[:, k]])

            # 动力学约束
            x_next = x[:, k] + self.dt * self.bicycle_model(x[:, k], u[:, k])
            g.append(x[:, k+1] - x_next)

        # 终端代价
        cost += ca.mtimes([(x[:, self.N] - ref[:, self.N]).T, Q, x[:, self.N] - ref[:, self.N]])

        # 创建求解器
        opt_variables = ca.vertcat(ca.reshape(x, -1, 1), ca.reshape(u, -1, 1))
        nlp = {'x': opt_variables, 'f': cost, 'g': ca.vertcat(*g), 'p': ca.reshape(ref, -1, 1)}

        self.solver = ca.nlpsol('solver', 'ipopt', nlp)
```

### 5.3 动态窗口法（DWA）

**适用：**动态避障的局部规划。

**思想：**在速度空间搜索可行速度，优化评价函数。

```python
class DWA:
    def __init__(self, max_v=1.0, max_w=1.0, max_accel=0.5, max_dalpha=1.0,
                 dt=0.1, predict_time=3.0, resolution=0.1):
        self.max_v = max_v
        self.max_w = max_w
        self.max_accel = max_accel
        self.max_dalpha = max_dalpha
        self.dt = dt
        self.predict_time = predict_time
        self.resolution = resolution

    def dynamic_window(self, v, w):
        """计算动态窗口"""
        # 速度约束
        Vs = [0, self.max_v, -self.max_w, self.max_w]

        # 加速度约束
        Vd = [v - self.max_accel * self.dt,
              v + self.max_accel * self.dt,
              w - self.max_dalpha * self.dt,
              w + self.max_dalpha * self.dt]

        # 交集
        return [max(Vs[0], Vd[0]), min(Vs[1], Vd[1]),
                max(Vs[2], Vd[2]), min(Vs[3], Vd[3])]

    def predict_trajectory(self, x, y, theta, v, w):
        """预测轨迹"""
        trajectory = [(x, y, theta)]
        for _ in np.arange(0, self.predict_time, self.dt):
            x += v * np.cos(theta) * self.dt
            y += v * np.sin(theta) * self.dt
            theta += w * self.dt
            trajectory.append((x, y, theta))
        return trajectory

    def evaluate_trajectory(self, trajectory, goal, obstacles):
        """评价轨迹"""
        # 1. 目标方向得分
        last_point = trajectory[-1]
        goal_heading = np.arctan2(goal[1] - last_point[1],
                                  goal[0] - last_point[0])
        heading_error = abs(goal_heading - last_point[2])
        heading_score = 1.0 - heading_error / np.pi

        # 2. 距离得分
        dist_to_goal = np.linalg.norm([last_point[0] - goal[0],
                                       last_point[1] - goal[1]])
        dist_score = 1.0 / (1.0 + dist_to_goal)

        # 3. 障碍物距离得分
        min_dist_to_obs = float('inf')
        for point in trajectory:
            for obs in obstacles:
                dist = np.linalg.norm([point[0] - obs[0], point[1] - obs[1]])
                min_dist_to_obs = min(min_dist_to_obs, dist)

        if min_dist_to_obs < 0.3:  # 碰撞
            return -float('inf')

        obstacle_score = min_dist_to_obs

        # 综合得分
        return 0.5 * heading_score + 0.3 * dist_score + 0.2 * obstacle_score

    def compute_control(self, x, y, theta, v, w, goal, obstacles):
        """计算最优控制"""
        dw = self.dynamic_window(v, w)

        best_v, best_w = v, w
        best_score = -float('inf')

        for test_v in np.arange(dw[0], dw[1], self.resolution):
            for test_w in np.arange(dw[2], dw[3], self.resolution * 2):
                trajectory = self.predict_trajectory(x, y, theta, test_v, test_w)
                score = self.evaluate_trajectory(trajectory, goal, obstacles)

                if score > best_score:
                    best_score = score
                    best_v, best_w = test_v, test_w

        return best_v, best_w
```

---

## 六、实际应用案例

### 6.1 仓库AGV

**需求：**
- 多机器人协调
- 动态避障
- 高效路径

**方案：**
- A*全局规划
- DWA局部避障
- 多机器人调度（优先级、预订机制）

### 6.2 自动驾驶

**层次化规划：**
1. **全局路径**：A*在路网图
2. **局部轨迹**：考虑车道线、交规
3. **运动控制**：MPC/LQR

**挑战：**
- 高速动态环境
- 不确定性（其他车辆行为）
- 舒适性（加速度限制）

### 6.3 无人机

**3D规划：**
- RRT*/PRM在3D空间
- 考虑风场扰动
- 能量最优

**控制：**
- 内环：姿态控制（PID）
- 外环：轨迹跟踪（MPC）

---

## 七、前沿方向

### 7.1 学习型规划

**强化学习：**
- 端到端学习导航策略
- 适应复杂、动态环境

**模仿学习：**
- 从专家轨迹学习
- 减少探索成本

### 7.2 社会感知规划

**考虑人类行为：**
- 预测行人轨迹
- 遵守社交规范（保持距离、礼让）

### 7.3 多机器人协同

**挑战：**
- 避免碰撞
- 通信延迟
- 分布式优化

**方法：**
- 优先级规划
- 速度障碍法（VO）
- 一致性协议

---

## 八、总结

### 8.1 算法对比

| 算法 | 完备性 | 最优性 | 复杂度 | 适用场景 |
|------|--------|--------|--------|----------|
| Dijkstra | 完备 | 最优 | O(V log V) | 小规模静态 |
| A* | 完备 | 最优 | O(V log V) | 静态已知地图 |
| RRT | 概率完备 | 次优 | O(n log n) | 高维、复杂 |
| RRT* | 概率完备 | 渐进最优 | O(n log n) | 高质量路径 |
| DWA | 不完备 | 局部最优 | O(nv²) | 动态避障 |

### 8.2 选择指南

**静态环境 + 2D：**A*

**高维空间：**RRT/RRT*

**动态避障：**DWA + 全局规划

**时间最优：**优化方法（MPC）

**实时性要求高：**采样法 + 局部规划

### 8.3 推荐资源

**教材：**
- 《Planning Algorithms》- Steven LaValle（免费）
- 《Principles of Robot Motion》- Choset et al.

**开源库：**
- OMPL（Open Motion Planning Library）
- MoveIt!（ROS）
- PythonRobotics

**课程：**
- Coursera: Robotics Specialization
- MIT: Algorithmic Robotics

路径规划与运动控制是移动机器人的核心，掌握这些算法，你将能够设计出高效、安全、智能的机器人系统！
