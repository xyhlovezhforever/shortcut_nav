# 机器人学基础：运动学与动力学

## 引言：机器人的数学之美

当你看到工业机器人精准地装配零件，或是波士顿动力的机器狗敏捷地跳跃，背后都是精密的数学模型和控制算法。**机器人学（Robotics）**是融合机械、电子、控制、计算机等多学科的综合领域，而**运动学**和**动力学**则是机器人学的两大理论基石。

本文将系统介绍机器人运动学和动力学的核心概念、数学工具和实际应用，为你打开机器人学的大门。

---

## 一、机器人学概述

### 1.1 什么是机器人？

**定义：**能够自动执行工作的机械装置，具有感知、决策、执行能力。

**核心组成：**
1. **机械本体**：链接、关节、末端执行器
2. **传感系统**：视觉、力/力矩、编码器、IMU
3. **控制系统**：运动规划、轨迹跟踪、反馈控制
4. **计算系统**：处理器、算法、软件架构

### 1.2 机器人的分类

#### **按结构分类**

1. **串联机器人（Serial）**
   - 关节串联连接
   - 工作空间大
   - 刚度低
   - 例：工业六轴机械臂

2. **并联机器人（Parallel）**
   - 多链并联
   - 刚度高、精度高
   - 工作空间小
   - 例：Stewart平台、Delta机器人

3. **混合机器人（Hybrid）**
   - 串并联结合
   - 综合优势

#### **按应用分类**

- 工业机器人：焊接、喷涂、装配
- 服务机器人：清洁、医疗、餐饮
- 特种机器人：救援、探测、军事
- 移动机器人：AGV、无人机、自动驾驶

### 1.3 机器人学的核心问题

1. **运动学（Kinematics）**
   - 正运动学：关节空间 → 操作空间
   - 逆运动学：操作空间 → 关节空间

2. **动力学（Dynamics）**
   - 正动力学：力/力矩 → 加速度
   - 逆动力学：加速度 → 力/力矩

3. **轨迹规划（Trajectory Planning）**
   - 路径规划
   - 时间最优
   - 避障

4. **控制（Control）**
   - 位置控制
   - 力控制
   - 柔顺控制

---

## 二、数学基础

### 2.1 齐次变换矩阵

#### **刚体位姿表示**

**位置（Position）：**向量 p = [x, y, z]^T

**姿态（Orientation）：**旋转矩阵 R ∈ SO(3)

**齐次变换（Homogeneous Transformation）：**
```
T = [R  p]  ∈ SE(3)
    [0  1]
```

**性质：**
- T^(-1) = [R^T  -R^T p]
           [0      1    ]
- T_1 T_2 表示连续变换

#### **旋转表示方法**

**1. 旋转矩阵（Rotation Matrix）**
```
R = [r_11  r_12  r_13]
    [r_21  r_22  r_23]
    [r_31  r_32  r_33]

约束：R^T R = I, det(R) = 1
```

**2. 欧拉角（Euler Angles）**

**ZYX欧拉角（Roll-Pitch-Yaw）：**
```
R = R_z(yaw) · R_y(pitch) · R_x(roll)

R_x(α) = [1   0      0    ]
         [0  cos(α) -sin(α)]
         [0  sin(α)  cos(α)]

R_y(β) = [ cos(β)  0  sin(β)]
         [  0      1    0   ]
         [-sin(β)  0  cos(β)]

R_z(γ) = [cos(γ) -sin(γ)  0]
         [sin(γ)  cos(γ)  0]
         [  0       0     1]
```

**优点：**直观易懂

**缺点：**
- 万向节死锁（Gimbal Lock）
- 不唯一
- 难以插值

**3. 轴角表示（Axis-Angle）**
```
R = I + sin(θ) [k]_× + (1 - cos(θ)) [k]_×^2

其中k是旋转轴，θ是旋转角

[k]_× = [ 0   -k_z   k_y]
        [ k_z   0   -k_x]
        [-k_y  k_x   0  ]  （反对称矩阵）
```

**4. 四元数（Quaternion）**
```
q = [q_w, q_x, q_y, q_z] = [cos(θ/2), sin(θ/2) k]

||q|| = 1  （单位四元数）
```

**旋转矩阵与四元数转换：**
```
R = [1-2(q_y²+q_z²)   2(q_xq_y-q_wq_z)   2(q_xq_z+q_wq_y)]
    [2(q_xq_y+q_wq_z) 1-2(q_x²+q_z²)     2(q_yq_z-q_wq_x)]
    [2(q_xq_z-q_wq_y) 2(q_yq_z+q_wq_x)   1-2(q_x²+q_y²)  ]
```

**优点：**
- 无奇异性
- 插值平滑（SLERP）
- 计算效率高

**四元数运算：**
```python
import numpy as np

def quaternion_multiply(q1, q2):
    """四元数乘法"""
    w1, x1, y1, z1 = q1
    w2, x2, y2, z2 = q2
    return np.array([
        w1*w2 - x1*x2 - y1*y2 - z1*z2,
        w1*x2 + x1*w2 + y1*z2 - z1*y2,
        w1*y2 - x1*z2 + y1*w2 + z1*x2,
        w1*z2 + x1*y2 - y1*x2 + z1*w2
    ])

def quaternion_conjugate(q):
    """四元数共轭"""
    return np.array([q[0], -q[1], -q[2], -q[3]])

def quaternion_inverse(q):
    """四元数逆"""
    return quaternion_conjugate(q) / np.dot(q, q)

def slerp(q1, q2, t):
    """球面线性插值"""
    dot = np.dot(q1, q2)
    if dot < 0:
        q2 = -q2
        dot = -dot

    theta = np.arccos(np.clip(dot, -1, 1))
    if theta < 1e-6:
        return q1

    return (np.sin((1-t)*theta) * q1 + np.sin(t*theta) * q2) / np.sin(theta)
```

### 2.2 DH参数

**Denavit-Hartenberg参数**是描述连杆关系的标准方法。

#### **标准DH参数**

每个关节用4个参数描述：

| 参数 | 含义 |
|------|------|
| a_i | 连杆长度（沿x_i） |
| α_i | 连杆扭角（绕x_i） |
| d_i | 连杆偏距（沿z_(i-1)） |
| θ_i | 关节角（绕z_(i-1)） |

**变换矩阵：**
```
T_i = Rot_z(θ_i) · Trans_z(d_i) · Trans_x(a_i) · Rot_x(α_i)

    = [cos(θ_i)  -sin(θ_i)cos(α_i)   sin(θ_i)sin(α_i)   a_i cos(θ_i)]
      [sin(θ_i)   cos(θ_i)cos(α_i)  -cos(θ_i)sin(α_i)   a_i sin(θ_i)]
      [   0          sin(α_i)            cos(α_i)            d_i     ]
      [   0             0                   0                1       ]
```

**例子：PUMA机器人DH参数**

| i | a_i | α_i | d_i | θ_i |
|---|-----|-----|-----|-----|
| 1 | 0 | 90° | 0 | θ_1 |
| 2 | a_2 | 0 | 0 | θ_2 |
| 3 | 0 | 90° | d_3 | θ_3 |
| 4 | 0 | -90° | d_4 | θ_4 |
| 5 | 0 | 90° | 0 | θ_5 |
| 6 | 0 | 0 | d_6 | θ_6 |

---

## 三、正运动学

### 3.1 定义与计算

**正运动学（Forward Kinematics, FK）：**已知关节角度，求末端位姿。

```
给定：θ = [θ_1, θ_2, ..., θ_n]
求解：T_0^n = T_1 · T_2 · ... · T_n
```

### 3.2 Python实现

```python
import numpy as np

class RobotKinematics:
    def __init__(self, dh_params):
        """
        DH参数表：[[a, alpha, d, theta], ...]
        """
        self.dh_params = dh_params
        self.n = len(dh_params)

    def dh_transform(self, a, alpha, d, theta):
        """单个DH变换矩阵"""
        ct = np.cos(theta)
        st = np.sin(theta)
        ca = np.cos(alpha)
        sa = np.sin(alpha)

        return np.array([
            [ct, -st*ca,  st*sa, a*ct],
            [st,  ct*ca, -ct*sa, a*st],
            [0,   sa,     ca,    d   ],
            [0,   0,      0,     1   ]
        ])

    def forward_kinematics(self, joint_angles):
        """正运动学"""
        T = np.eye(4)

        for i, theta in enumerate(joint_angles):
            a, alpha, d, _ = self.dh_params[i]
            T_i = self.dh_transform(a, alpha, d, theta)
            T = T @ T_i

        return T

    def get_position(self, T):
        """提取位置"""
        return T[:3, 3]

    def get_rotation(self, T):
        """提取旋转矩阵"""
        return T[:3, :3]


# 示例：平面二连杆
dh = [
    [1.0, 0, 0, 0],  # 连杆1
    [1.0, 0, 0, 0]   # 连杆2
]

robot = RobotKinematics(dh)

# 计算正运动学
theta = [np.pi/4, np.pi/6]
T = robot.forward_kinematics(theta)

print("末端位姿：")
print(T)
print(f"末端位置：{robot.get_position(T)}")
```

### 3.3 雅可比矩阵

**雅可比矩阵（Jacobian Matrix）：**关节速度与末端速度的映射。

```
v = J(θ) θ̇

其中：
v = [ẋ, ẏ, ż, ω_x, ω_y, ω_z]^T  （末端速度）
θ̇ = [θ̇_1, ..., θ̇_n]^T          （关节速度）
J ∈ R^(6×n)                      （雅可比矩阵）
```

**几何方法计算：**

```
J = [J_v]  = [z_0 × (p_n - p_0), ..., z_(n-1) × (p_n - p_(n-1))]
    [J_ω]    [z_0,                ..., z_(n-1)                  ]

其中：
z_i：第i个关节的旋转轴
p_i：第i个坐标系的原点
```

**Python实现：**

```python
def compute_jacobian(robot, joint_angles):
    """计算雅可比矩阵"""
    n = len(joint_angles)
    J = np.zeros((6, n))

    # 计算所有变换矩阵
    T_list = [np.eye(4)]
    for i, theta in enumerate(joint_angles):
        a, alpha, d, _ = robot.dh_params[i]
        T_i = robot.dh_transform(a, alpha, d, theta)
        T_list.append(T_list[-1] @ T_i)

    p_n = T_list[-1][:3, 3]  # 末端位置

    for i in range(n):
        z_i = T_list[i][:3, 2]  # 第i个z轴
        p_i = T_list[i][:3, 3]  # 第i个原点

        # 线速度雅可比
        J[:3, i] = np.cross(z_i, p_n - p_i)

        # 角速度雅可比
        J[3:, i] = z_i

    return J
```

**应用：**
1. **速度映射**：v = J θ̇
2. **静力映射**：τ = J^T F（虚功原理）
3. **奇异性分析**：det(J) = 0时奇异
4. **逆运动学**：θ̇ = J^(-1) v

---

## 四、逆运动学

### 4.1 定义与挑战

**逆运动学（Inverse Kinematics, IK）：**已知末端位姿，求关节角度。

```
给定：T_desired
求解：θ = [θ_1, ..., θ_n]
使得：FK(θ) = T_desired
```

**挑战：**
1. **非线性**：三角函数、多项式
2. **多解**：同一位姿多种关节配置
3. **无解**：超出工作空间
4. **奇异**：雅可比矩阵退化

### 4.2 解析解方法

**适用：**特殊几何结构（如6轴机械臂）

**PUMA机器人IK：**

**步骤1：位置解耦**
```
腕点位置 p_wrist = p_target - d_6 * n_target

其中n_target是接近向量
```

**步骤2：求θ_1**
```
θ_1 = atan2(p_y, p_x)
```

**步骤3：求θ_2, θ_3**
```
通过几何关系（余弦定理等）
```

**步骤4：求θ_4, θ_5, θ_6（姿态）**
```
R_3^6 = R_0^3^T · R_0^6
分解欧拉角
```

### 4.3 数值解方法

#### **1. 雅可比逆迭代**

```
θ_(k+1) = θ_k + α J^(-1)(θ_k) Δx

其中：
Δx = x_desired - FK(θ_k)
α：步长
```

**Python实现：**

```python
def inverse_kinematics_jacobian(robot, T_target, theta_init, max_iter=100, tol=1e-3):
    """基于雅可比逆的逆运动学"""
    theta = theta_init.copy()

    for iter in range(max_iter):
        # 当前位姿
        T_current = robot.forward_kinematics(theta)

        # 位置误差
        pos_error = T_target[:3, 3] - T_current[:3, 3]

        # 姿态误差（用轴角表示）
        R_error = T_target[:3, :3] @ T_current[:3, :3].T
        axis_angle = rotation_matrix_to_axis_angle(R_error)

        # 总误差
        error = np.concatenate([pos_error, axis_angle])

        # 收敛判断
        if np.linalg.norm(error) < tol:
            return theta, True

        # 计算雅可比
        J = compute_jacobian(robot, theta)

        # 伪逆（处理奇异）
        J_pinv = np.linalg.pinv(J)

        # 更新
        delta_theta = J_pinv @ error
        theta += 0.5 * delta_theta  # 0.5是步长

    return theta, False


def rotation_matrix_to_axis_angle(R):
    """旋转矩阵转轴角"""
    theta = np.arccos((np.trace(R) - 1) / 2)

    if theta < 1e-6:
        return np.zeros(3)

    axis = 1 / (2 * np.sin(theta)) * np.array([
        R[2,1] - R[1,2],
        R[0,2] - R[2,0],
        R[1,0] - R[0,1]
    ])

    return theta * axis
```

#### **2. 阻尼最小二乘法（DLS）**

处理奇异性：
```
J^T (JJ^T + λ²I)^(-1)

λ：阻尼系数
```

#### **3. 优化方法**

```python
from scipy.optimize import minimize

def ik_optimization(robot, T_target, theta_init):
    """基于优化的逆运动学"""

    def objective(theta):
        T_current = robot.forward_kinematics(theta)

        # 位置误差
        pos_error = np.linalg.norm(T_target[:3, 3] - T_current[:3, 3])

        # 姿态误差
        R_error = T_target[:3, :3] @ T_current[:3, :3].T
        ori_error = np.linalg.norm(rotation_matrix_to_axis_angle(R_error))

        return pos_error + ori_error

    result = minimize(objective, theta_init, method='SLSQP')

    return result.x, result.success
```

---

## 五、机器人动力学

### 5.1 拉格朗日法

**拉格朗日方程：**
```
d/dt (∂L/∂θ̇_i) - ∂L/∂θ_i = τ_i

其中：
L = T - V  （拉格朗日函数）
T：动能
V：势能
τ_i：第i个关节力矩
```

**动力学方程：**
```
M(θ) θ̈ + C(θ, θ̇) θ̇ + G(θ) = τ

M(θ)：惯性矩阵
C(θ, θ̇)：科里奥利和离心力矩阵
G(θ)：重力向量
```

**性质：**
1. M(θ)正定对称
2. Ṁ - 2C 反对称
3. 线性参数化

### 5.2 牛顿-欧拉法

**递归算法：**

**前向递归（速度、加速度）：**
```
for i = 1 to n:
    ω_i = R_i^(i-1) ω_(i-1) + θ̇_i z_i
    α_i = R_i^(i-1) α_(i-1) + θ̈_i z_i + ω_i × (θ̇_i z_i)
    v_i = R_i^(i-1) (v_(i-1) + ω_(i-1) × p_(i-1))
    a_i = R_i^(i-1) a_(i-1) + α_i × r_i + ω_i × (ω_i × r_i)
```

**后向递归（力、力矩）：**
```
for i = n to 1:
    f_i = R_(i+1)^i f_(i+1) + m_i a_i
    n_i = R_(i+1)^i n_(i+1) + r_i × f_i + I_i α_i + ω_i × (I_i ω_i)
    τ_i = n_i^T z_i
```

**优势：**
- 计算效率O(n)
- 数值稳定

### 5.3 Python实现（简化平面二连杆）

```python
class RobotDynamics:
    def __init__(self, m, l, I):
        """
        m: 连杆质量 [m1, m2]
        l: 连杆长度 [l1, l2]
        I: 转动惯量 [I1, I2]
        """
        self.m = m
        self.l = l
        self.I = I
        self.g = 9.81

    def inertia_matrix(self, theta):
        """惯性矩阵 M(θ)"""
        q1, q2 = theta
        m1, m2 = self.m
        l1, l2 = self.l
        I1, I2 = self.I

        M11 = I1 + I2 + m2*l1**2 + 2*m2*l1*l2*np.cos(q2)
        M12 = I2 + m2*l1*l2*np.cos(q2)
        M22 = I2

        M = np.array([[M11, M12],
                      [M12, M22]])
        return M

    def coriolis_matrix(self, theta, theta_dot):
        """科里奥利矩阵 C(θ, θ̇)"""
        q1, q2 = theta
        dq1, dq2 = theta_dot
        m2 = self.m[1]
        l1, l2 = self.l

        h = -m2*l1*l2*np.sin(q2)

        C = np.array([[-h*dq2, -h*(dq1+dq2)],
                      [ h*dq1,      0       ]])
        return C

    def gravity_vector(self, theta):
        """重力向量 G(θ)"""
        q1, q2 = theta
        m1, m2 = self.m
        l1, l2 = self.l

        G1 = (m1 + m2) * self.g * l1 * np.cos(q1) + m2 * self.g * l2 * np.cos(q1 + q2)
        G2 = m2 * self.g * l2 * np.cos(q1 + q2)

        G = np.array([G1, G2])
        return G

    def forward_dynamics(self, theta, theta_dot, tau):
        """正动力学：τ → θ̈"""
        M = self.inertia_matrix(theta)
        C = self.coriolis_matrix(theta, theta_dot)
        G = self.gravity_vector(theta)

        theta_ddot = np.linalg.solve(M, tau - C @ theta_dot - G)
        return theta_ddot

    def inverse_dynamics(self, theta, theta_dot, theta_ddot):
        """逆动力学：θ̈ → τ"""
        M = self.inertia_matrix(theta)
        C = self.coriolis_matrix(theta, theta_dot)
        G = self.gravity_vector(theta)

        tau = M @ theta_ddot + C @ theta_dot + G
        return tau
```

---

## 六、轨迹规划

### 6.1 关节空间规划

#### **多项式插值**

**三次多项式：**
```
θ(t) = a_0 + a_1 t + a_2 t² + a_3 t³

边界条件：
θ(0) = θ_start,  θ(T) = θ_end
θ̇(0) = 0,        θ̇(T) = 0
```

**五次多项式：**
```
θ(t) = a_0 + a_1 t + a_2 t² + a_3 t³ + a_4 t⁴ + a_5 t⁵

额外约束：θ̈(0) = θ̈(T) = 0
```

**Python实现：**

```python
def cubic_trajectory(q0, qf, T, N=100):
    """三次多项式轨迹"""
    # 系数
    a0 = q0
    a1 = 0
    a2 = 3 * (qf - q0) / T**2
    a3 = -2 * (qf - q0) / T**3

    t = np.linspace(0, T, N)
    q = a0 + a1*t + a2*t**2 + a3*t**3
    qd = a1 + 2*a2*t + 3*a3*t**2
    qdd = 2*a2 + 6*a3*t

    return t, q, qd, qdd


def quintic_trajectory(q0, qf, T, N=100):
    """五次多项式轨迹"""
    a0 = q0
    a1 = 0
    a2 = 0
    a3 = 10 * (qf - q0) / T**3
    a4 = -15 * (qf - q0) / T**4
    a5 = 6 * (qf - q0) / T**5

    t = np.linspace(0, T, N)
    q = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 + a5*t**5
    qd = a1 + 2*a2*t + 3*a3*t**2 + 4*a4*t**3 + 5*a5*t**4
    qdd = 2*a2 + 6*a3*t + 12*a4*t**2 + 20*a5*t**3

    return t, q, qd, qdd
```

#### **梯形速度规划**

```
加速段：θ̇ = a * t
匀速段：θ̇ = v_max
减速段：θ̇ = v_max - a * t
```

### 6.2 笛卡尔空间规划

**直线轨迹：**
```
p(t) = p_start + (p_end - p_start) * s(t)

其中s(t)是归一化时间函数（如五次多项式）
```

**圆弧轨迹：**
```
p(t) = center + R * [cos(θ(t)), sin(θ(t)), 0]^T
```

**姿态插值：**
- **SLERP**（球面线性插值）：用于四元数
- **旋转向量插值**

---

## 七、实际应用案例

### 7.1 工业机械臂抓取

**流程：**
1. **视觉定位**：相机识别物体位姿
2. **路径规划**：避障、关节限位
3. **轨迹生成**：平滑插值
4. **控制执行**：PID/计算力矩控制
5. **力控夹取**：恒力抓取

### 7.2 协作机器人

**特点：**
- 轻量化设计
- 力/力矩传感
- 柔顺控制
- 碰撞检测

**控制策略：**
- **阻抗控制**：模拟弹簧阻尼系统
- **导纳控制**：力输入位置输出

### 7.3 移动机械臂

**挑战：**
- 基座运动影响
- 全系统冗余
- 动态环境

**解决方案：**
- 全身运动规划
- 移动基座与机械臂协调
- 实时感知与重规划

---

## 八、总结与展望

### 8.1 核心要点

**运动学：**
- 正运动学：DH参数、齐次变换
- 逆运动学：解析解、数值解
- 雅可比：速度映射、奇异性

**动力学：**
- 拉格朗日法：能量角度
- 牛顿-欧拉法：力平衡角度
- 逆动力学：前馈控制、轨迹跟踪

### 8.2 学习路径

1. **数学基础**
   - 线性代数
   - 刚体运动学
   - 微分方程

2. **理论学习**
   - 机器人学教材
   - 在线课程

3. **编程实践**
   - ROS（Robot Operating System）
   - MoveIt!（运动规划）
   - 仿真器（Gazebo、CoppeliaSim）

4. **硬件实验**
   - Arduino机械臂
   - ROS机械臂
   - 开源机器人平台

### 8.3 推荐资源

**教材：**
- 《机器人学导论》- 蔡自兴
- 《Robotics: Modelling, Planning and Control》- Siciliano
- 《Modern Robotics》- Kevin Lynch（免费教材）

**软件工具：**
- ROS/ROS2
- MATLAB Robotics Toolbox
- Python Robotics库

**在线课程：**
- Coursera: Modern Robotics
- MIT OpenCourseWare: Introduction to Robotics
- ETH Zurich: Robotics

机器人学是理论与实践高度融合的学科，掌握运动学和动力学，你就拥有了设计和控制机器人的核心能力！
